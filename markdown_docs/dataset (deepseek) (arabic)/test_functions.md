<div dir="rtl">

## ClassDef CompileTest
**CompileTest**: وظيفة CompileTest هي اختبار وظائف SQL وتأكيد صحة ترجمتها (compilation) إلى استعلامات SQL صحيحة.

**attributes**: السمات الخاصة بهذا الكلاس.
· __dialect__: يُستخدم لتحديد اللهجة (dialect) الافتراضية التي سيتم استخدامها في الاختبارات. القيمة الافتراضية هي "default".

**Code Description**: 
يُعتبر CompileTest كلاسًا مخصصًا لاختبار وظائف SQL وتأكيد صحة ترجمتها إلى استعلامات SQL صحيحة. هذا الكلاس يرث من fixtures.TestBase و AssertsCompiledSQL، مما يمنحه القدرة على تنفيذ اختبارات قاعدة البيانات والتحقق من صحة استعلامات SQL المترجمة.

يحتوي الكلاس على عدة طرق رئيسية:
1. **setup_test**: تُستخدم لإعداد البيئة قبل تنفيذ كل اختبار. تقوم بنسخ عميقة للسجل (registry) الخاص بالوظائف (functions) وحفظه في متغير داخلي.
2. **teardown_test**: تُستخدم لتنظيف البيئة بعد تنفيذ كل اختبار. تقوم باستعادة السجل الأصلي للوظائف.
3. **test_compile**: تقوم باختبار ترجمة عدة وظائف SQL مثل CURRENT_TIMESTAMP و LOCALTIME ووظائف أخرى مخصصة. يتم التحقق من صحة الترجمة لكل لهجة (dialect) متاحة.
4. **test_operators_custom**: تختبر استخدام العوامل (operators) مع الوظائف المخصصة، مثل IN و + و =.
5. **test_use_labels**: تختبر استخدام التسميات (labels) مع الوظائف.
6. **test_underscores**: تختبر الوظائف التي تحتوي على شرطات سفلية (underscores) في أسمائها.
7. **test_uppercase**: تختبر الوظائف التي تحتوي على أحرف كبيرة (uppercase) في أسمائها.
8. **test_mixed_case**: تختبر الوظائف التي تحتوي على مزيج من الأحرف الكبيرة والصغيرة.
9. **test_quote_special_chars**: تختبر الوظائف التي تحتوي على أحرف خاصة وتحتاج إلى اقتباس (quoting).
10. **test_generic_now**: تختبر وظيفة NOW() وتأكد من أنها تُرجم بشكل صحيح لكل لهجة.
11. **test_generic_random**: تختبر وظيفة RANDOM() وتأكد من أنها تُرجم بشكل صحيح لكل لهجة.
12. **test_return_type_aggregate_strings**: تختبر نوع الإرجاع لوظيفة تجميع السلاسل (aggregate strings).
13. **test_aggregate_strings**: تختبر ترجمة وظيفة تجميع السلاسل (aggregate strings) لكل لهجة.
14. **test_cube_operators**: تختبر استخدام وظائف CUBE و ROLLUP و GROUPING SETS في استعلامات SQL.
15. **test_generic_annotation**: تختبر إضافة تعليقات (annotations) إلى الوظائف.
16. **test_custom_default_namespace**: تختبر إنشاء وظائف مخصصة باستخدام مساحة اسم افتراضية.
17. **test_custom_type**: تختبر إنشاء وظائف مخصصة مع تحديد نوع الإرجاع.
18. **test_custom_legacy_type**: تختبر إنشاء وظائف مخصصة باستخدام نظام قديم لتحديد نوع الإرجاع.
19. **test_case_sensitive**: تختبر حساسية الحالة (case sensitivity) في أسماء الوظائف.
20. **test_replace_function**: تختبر استبدال الوظائف المخصصة.
21. **test_custom_w_custom_name**: تختبر إنشاء وظائف مخصصة مع أسماء مخصصة.
22. **test_custom_w_quoted_name**: تختبر إنشاء وظائف مخصصة مع أسماء مقتبسة (quoted names).
23. **test_custom_package_namespace**: تختبر إنشاء وظائف مخصصة ضمن مساحات أسماء (namespaces) مخصصة.
24. **test_custom_name**: تختبر إنشاء وظائف مخصصة مع أسماء مخصصة ومعلمات إضافية.
25. **test_custom_registered_identifier**: تختبر تسجيل الوظائف المخصصة باستخدام معرفات (identifiers) مخصصة.
26. **test_custom_args**: تختبر إنشاء وظائف مخصصة مع معلمات إضافية.
27. **test_namespacing_conflicts**: تختبر التعارضات في مساحات الأسماء.
28. **test_generic_count**: تختبر وظيفة COUNT() وتأكد من أنها تُرجم بشكل صحيح.
29. **test_ansi_functions_with_args**: تختبر الوظائف القياسية (ANSI) مع معلمات إضافية.
30. **test_char_length_fixed_args**: تختبر وظيفة CHAR_LENGTH() مع معلمات ثابتة.
31. **test_return_type_detection**: تختبر اكتشاف نوع الإرجاع للوظائف المختلفة.
32. **test_assorted**: تختبر مجموعة متنوعة من الوظائف واستخداماتها في استعلامات SQL.
33. **test_pickle_over**: تختبر عملية التخزين المؤقت (pickling) للوظائف.
34. **test_pickle_within_group**: تختبر عملية التخزين المؤقت (pickling) للوظائف مع استخدام WITHIN GROUP.
35. **test_functions_with_cols**: تختبر استخدام الوظائف مع الأعمدة في استعلامات SQL.
36. **test_non_functions**: تختبر الوظائف غير القياسية مثل CAST و EXTRACT.
37. **test_select_method_one**: تختبر استخدام الوظائف في استعلامات SELECT.
38. **test_alias_method_one**: تختبر استخدام الوظائف مع الأسماء المستعارة (aliases).
39. **test_select_method_two**: تختبر استخدام الوظائف في استعلامات SELECT مع استعلامات فرعية.
40. **test_select_method_three**: تختبر استخدام الوظائف في استعلامات SELECT مع أعمدة محددة.
41. **test_alias_method_two**: تختبر استخدام الوظائف مع الأسماء المستعارة (aliases) في استعلامات SELECT.
42. **test_alias_method_columns**: تختبر تصدير الأعمدة من الوظائف المستعارة.
43. **test_funcfilter_empty**: تختبر استخدام الفلاتر (filters) مع الوظائف بدون شروط.
44. **test_funcfilter_criterion**: تختبر استخدام الفلاتر (filters) مع الوظائف مع شروط محددة.
45. **test_funcfilter_compound_criterion**: تختبر استخدام الفلاتر (filters) مع الوظائف مع شروط مركبة.
46. **test_funcfilter_arrayagg_subscript**: تختبر استخدام الفلاتر (filters) مع وظائف تجميع المصفوفات (array aggregation).
47. **test_funcfilter_label**: تختبر استخدام الفلاتر (filters) مع التسميات (labels).
48. **test_funcfilter_fromobj_fromfunc**: تختبر إنشاء الكائنات (objects) من الوظائف مع الفلاتر.
49. **test_funcfilter_fromobj_fromcriterion**: تختبر إنشاء الكائنات (objects) من الشروط مع الفلاتر.
50. **test_funcfilter_chaining**: تختبر تسلسل الفلاتر (filters) مع الوظائف.
51. **test_funcfilter_windowing_orderby**: تختبر استخدام الفلاتر (filters) مع وظائف النوافذ (window functions) مع ترتيب.
52. **test_funcfilter_windowing_orderby_partitionby**: تختبر استخدام الفلاتر (filters) مع وظائف النوافذ (window functions) مع ترتيب وتقسيم.
53. **test_funcfilter_windowing_range**: تختبر استخدام الفلاتر (filters) مع وظائف النوافذ (window functions) مع نطاق.
54. **test_funcfilter_windowing_range_positional**: تختبر استخدام الفلاتر (filters) مع وظائف النوافذ (window functions) مع نطاق باستخدام المعلمات الموضعية.
55. **test_funcfilter_windowing_rows**: تختبر استخدام الفلاتر (filters) مع وظائف النوافذ (window functions) مع الصفوف.
56. **test_funcfilter_more_criteria**: تختبر استخدام الفلاتر (filters) مع شروط إضافية.
57. **test_funcfilter_within_group**: تختبر استخدام الفلاتر (filters) مع وظائف WITHIN GROUP.
58. **test_within_group**: تختبر استخدام وظائف WITHIN GROUP.
59. **test_within_group_multi**: تختبر استخدام وظائف WITHIN GROUP مع معلمات متعددة.
60. **test_within_group_desc**: تختبر استخدام وظائف WITHIN GROUP مع ترتيب تنازلي.
61. **test_within_group_w_over**: تختبر استخدام وظائف WITHIN GROUP مع وظائف النوافذ (window functions).
62. **test_within_group_filter**: تختبر استخدام وظائف WITHIN GROUP مع الفلاتر (filters).
63. **test_incorrect_none_type**: تختبر الحالات التي يكون فيها نوع الإرجاع غير صحيح.
64. **test_as_comparison**: تختبر استخدام الوظائف كمقارنات (comparisons).
65. **test_as_comparison_annotate**: تختبر استخدام الوظائف كمقارنات (comparisons) مع التعليقات (annotations).
66. **test_as_comparison_many_argument**: تختبر استخدام الوظائف كمقارنات (comparisons) مع معلمات متعددة.

**Note**: 
- يجب التأكد من أن السجل (registry) للوظائف يتم استعادته بشكل صحيح بعد كل اختبار لتجنب أي تأثيرات جانبية.
- عند اختبار الوظائف المخصصة، يجب التأكد من تنظيف السجل بعد كل اختبار لتجنب التعارضات.

**Output Example**: 
```sql
SELECT CURRENT_TIMESTAMP
```
هذا مثال على استعلام SQL الذي يمكن أن يُرجع نتيجة اختبار ترجمة وظيفة CURRENT_TIMESTAMP.
### FunctionDef setup_test(self)
**setup_test**: وظيفة `setup_test` هي نسخ سجل الوظائف (registry) الحالي وحفظه في متغير داخلي.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters).

**Code Description**: تقوم هذه الوظيفة بنسخ السجل الحالي للوظائف (`_registry`) من الكائن `functions` وحفظه في المتغير الداخلي `self._registry`. يتم استخدام الدالة `deepcopy` من مكتبة `copy` لضمان إنشاء نسخة عميقة (deep copy) من السجل، مما يعني أن أي تغييرات لاحقة على النسخة الأصلية لن تؤثر على النسخة المحفوظة في `self._registry`. هذا مفيد في الحالات التي تحتاج فيها إلى الحفاظ على حالة السجل في وقت معين دون التأثر بالتعديلات اللاحقة.

**Note**: تأكد من أن الكائن `functions` يحتوي على السجل (`_registry`) قبل استدعاء هذه الوظيفة. أيضًا، يجب أن تكون مكتبة `copy` مستوردة بشكل صحيح في الكود حيث يتم استخدام `deepcopy`.
***
### FunctionDef teardown_test(self)
**teardown_test**: وظيفة `teardown_test` هي استعادة الحالة الأصلية للسجل (`_registry`) بعد انتهاء الاختبار.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.

**Code Description**: تقوم هذه الدالة باستعادة الحالة الأصلية للسجل (`_registry`) عن طريق تعيين قيمة `_registry` في الكائن الحالي (`self._registry`) إلى المتغير `_registry` الموجود في وحدة `functions`. يتم ذلك من خلال السطر التالي:
```python
functions._registry = self._registry
```
هذا يعني أن الدالة تعيد تعيين السجل (`_registry`) إلى الحالة التي كانت عليها قبل بدء الاختبار، مما يضمن عدم تأثر الاختبارات الأخرى بالتغييرات التي قد تحدث أثناء تنفيذ الاختبار الحالي.

**Note**: يُستخدم هذا النوع من الدوال عادةً في سياق اختبارات الوحدة (unit tests) لضمان أن كل اختبار يعمل في بيئة نظيفة ولا يتأثر بالاختبارات الأخرى. يجب التأكد من أن `self._registry` يحتوي على الحالة الأصلية للسجل قبل تنفيذ الاختبار.
***
### FunctionDef test_compile(self)
**test_compile**: وظيفة `test_compile` هي اختبار عملية الترجمة (compile) للدوال العامة (Generic Functions) والوظائف المضمنة (built-in functions) باستخدام مختلف اللهجات (dialects) في قاعدة البيانات.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) خارجية، حيث يتم تنفيذها داخل سياق كائن (self) من الفئة التي تنتمي إليها.

**Code Description**: 
- تقوم الوظيفة باختبار ترجمة عدة دوال باستخدام جميع اللهجات المتاحة (dialects) التي يتم الحصول عليها من خلال الدالة `all_dialects()`.
- يتم استخدام الدالة `self.assert_compile` للتحقق من أن ترجمة الدوال المحددة تتم بشكل صحيح وفقًا للهجة المحددة (dialect).
- يتم اختبار الدوال المضمنة مثل `current_timestamp()` و`localtime()` و`nosuchfunction()` للتأكد من أن ترجمتها تعطي النتائج المتوقعة.
- يتم أيضًا اختبار دالة مخصصة (fake_func) تم إنشاؤها داخل الوظيفة نفسها. هذه الدالة هي عبارة عن دالة عامة (GenericFunction) تُرجع نوعًا صحيحًا (Integer) وتأخذ معاملًا واحدًا (arg). يتم التحقق من أن ترجمة هذه الدالة تتم بشكل صحيح باستخدام القالب المناسب (bindtemplate) للهجة المحددة.
- بعد الانتهاء من الاختبار، يتم إزالة الدالة المخصصة (fake_func) من السجل (registry) للدوال العامة لضمان عدم تأثيرها على الاختبارات الأخرى.

**Note**: 
- يجب التأكد من أن جميع اللهجات (dialects) المدعومة يتم اختبارها بشكل صحيح.
- الدالة المخصصة (fake_func) يتم إنشاؤها فقط لأغراض الاختبار ويتم إزالتها بعد الانتهاء من الاختبار لتجنب أي تأثيرات جانبية.

**Output Example**: 
لا تُرجع هذه الوظيفة أي قيمة مباشرة، ولكنها تقوم برفع استثناء (AssertionError) في حالة فشل أي من اختبارات الترجمة. على سبيل المثال، إذا فشل اختبار ترجمة دالة `current_timestamp()`، سيتم رفع استثناء مع رسالة توضح الخطأ.
#### ClassDef fake_func
**fake_func**: وظيفة `fake_func` هي توفير دالة وهمية (fake function) تعمل كدالة عامة (GenericFunction) تُستخدم في سياق قواعد البيانات، حيث تُرجع نوعًا محددًا من البيانات وهو `Integer`.

**attributes**: السمات الخاصة بهذا الكلاس.
· `inherit_cache`: قيمة منطقية (Boolean) تُحدد ما إذا كان سيتم توريث ذاكرة التخزين المؤقت (cache) من الكلاس الأب. القيمة الافتراضية هنا هي `True`.
· `__return_type__`: يُحدد نوع البيانات الذي سترجعه الدالة. في هذه الحالة، النوع المُحدد هو `sqltypes.Integer`.

**Code Description**: وصف الكود.
- الكلاس `fake_func` يرث من الكلاس `GenericFunction`، مما يعني أنه يمكن استخدامه كدالة عامة في سياق قواعد البيانات.
- السمة `inherit_cache` مُعينة إلى `True`، مما يشير إلى أن هذه الدالة ستستخدم ذاكرة التخزين المؤقت الموروثة من الكلاس الأب.
- السمة `__return_type__` تُحدد أن نوع البيانات الذي سترجعه الدالة هو `Integer`، وهو نوع بيانات عدد صحيح في SQL.
- الدالة `__init__` هي دالة البناء (constructor) للكلاس، وتقوم باستدعاء دالة البناء الخاصة بالكلاس الأب (`GenericFunction`) مع تمرير الوسيطات المطلوبة (`arg` و `**kwargs`).

**Note**: ملاحظات حول استخدام الكود.
- يجب التأكد من أن الوسيطات الممررة إلى الدالة `fake_func` متوافقة مع توقعات الكلاس الأب `GenericFunction`.
- يمكن استخدام هذه الدالة في سياق استعلامات SQL حيث تكون هناك حاجة إلى دالة وهمية تُرجع قيمًا عددية صحيحة.

**Output Example**: مثال على القيمة المُرجعة من الكود.
```python
# مثال على استخدام fake_func
result = fake_func(5)
# النتيجة المتوقعة هي قيمة عددية صحيحة (Integer) بناءً على الوسيطة الممررة.
```
##### FunctionDef __init__(self, arg)
**__init__**: وظيفة `__init__` هي تهيئة الكائن عند إنشائه.

**parameters**: معاملات هذه الوظيفة.
· `arg`: معامل إلزامي يتم تمريره لتهيئة الكائن.
· `**kwargs`: معاملات اختيارية إضافية يتم تمريرها كمعاملات مفتاحية (keyword arguments).

**Code Description**: 
تقوم هذه الوظيفة بتهيئة الكائن عن طريق استدعاء دالة `__init__` من الفئة الأم `GenericFunction`. يتم تمرير المعامل الإلزامي `arg` والمعاملات الاختيارية `**kwargs` إلى دالة التهيئة الخاصة بالفئة الأم. هذا النمط من التهيئة يضمن أن الكائن الجديد يرث جميع الخصائص والسلوكيات المحددة في الفئة الأم، مع إمكانية إضافة معاملات إضافية إذا لزم الأمر.

**Note**: 
- يجب التأكد من أن الفئة الأم `GenericFunction` تحتوي على دالة `__init__` يمكن استدعاؤها بهذه الطريقة.
- يمكن استخدام `**kwargs` لتمرير أي عدد من المعاملات الاختيارية دون الحاجة إلى تعريفها مسبقًا في الدالة.
***
***
***
### FunctionDef test_operators_custom(self, op, other, expected, use_custom)
**test_operators_custom**: وظيفة `test_operators_custom` هي اختبار استخدام العوامل (operators) المخصصة في بناء الاستعلامات باستخدام SQLAlchemy.

**parameters**: معاملات هذه الوظيفة.
· `op`: العامل (operator) الذي يتم اختباره، مثل عمليات المقارنة (==, !=, >, <, إلخ).
· `other`: القيمة أو التعبير الذي يتم تطبيق العامل عليه.
· `expected`: النتيجة المتوقعة للاستعلام بعد تطبيق العامل.
· `use_custom`: قيمة منطقية (boolean) تحدد ما إذا كان سيتم استخدام دالة مخصصة (custom function) أم لا.

**Code Description**: 
تقوم هذه الوظيفة باختبار كيفية عمل العوامل المخصصة في SQLAlchemy عند بناء استعلامات SQL. يتم ذلك من خلال إنشاء دالة مخصصة تسمى `MyFunc` إذا كانت قيمة `use_custom` تساوي `True`. هذه الدالة المخصصة ترث من `FunctionElement` وتحدد نوع البيانات الذي تعيده (`Integer`). يتم بعد ذلك استخدام الدالة `@compiles` لتحديد كيفية ترجمة هذه الدالة إلى نص SQL، حيث يتم إرجاع نص SQL على شكل `myfunc(<clauses>)`.

إذا كانت `use_custom` تساوي `True`، يتم إنشاء تعبير باستخدام العامل `op` مع تطبيقه على `MyFunc()` والقيمة `other`. إذا كانت `use_custom` تساوي `False`، يتم استخدام الدالة `func.myfunc` مباشرة مع تحديد نوع البيانات (`Integer`).

بعد ذلك، يتم استخدام `self.assert_compile` لاختبار ما إذا كان الاستعلام المترجم يتطابق مع النتيجة المتوقعة (`expected`). يتم استخدام `literal_binds=True` لضمان أن القيم المرفقة بالاستعلام تكون حرفية (literals)، و`render_postcompile=True` لضمان أن الاستعلام يعرض بشكل صحيح بعد الترجمة. يتم استخدام `dialect="default_enhanced"` لتحديد اللهجة (dialect) المستخدمة في الترجمة.

**Note**: 
- يجب التأكد من أن القيمة المتوقعة (`expected`) تتطابق مع الناتج الفعلي للاستعلام بعد الترجمة.
- عند استخدام `use_custom=True`، يتم إنشاء دالة مخصصة، مما قد يؤثر على الأداء إذا تم استخدامها بشكل متكرر.

**Output Example**: 
إذا كانت القيم المدخلة كالتالي:
```python
op = operator.eq
other = 5
expected = "myfunc(5) = 5"
use_custom = True
```
فإن الناتج المتوقع سيكون:
```sql
SELECT 1 WHERE myfunc(5) = 5
```
#### ClassDef MyFunc
**MyFunc**: وظيفة MyFunc هي توفير عنصر دالة (FunctionElement) مخصص يعيد قيمة من نوع Integer.

**attributes**: السمات الخاصة بهذا الكلاس.
· inherit_cache: قيمة منطقية (Boolean) تُحدد ما إذا كان سيتم توريث ذاكرة التخزين المؤقت للدالة. القيمة الافتراضية هي True.
· name: اسم الدالة، وهو "myfunc" في هذه الحالة.
· type: نوع القيمة التي تُرجعها الدالة، وهو Integer في هذه الحالة.

**Code Description**: 
يُعرِّف هذا الكلاس دالة مخصصة تُسمى "myfunc" والتي ترث من الكلاس FunctionElement. يتم تعيين سمة inherit_cache إلى True، مما يعني أن الدالة ستستخدم ذاكرة التخزين المؤقت الموروثة لتحسين الأداء. يتم تعيين اسم الدالة إلى "myfunc" عبر السمة name، مما يسمح باستخدام هذا الاسم عند استدعاء الدالة. بالإضافة إلى ذلك، يتم تعيين نوع القيمة المُرجعة من الدالة إلى Integer عبر السمة type، مما يشير إلى أن الدالة ستُرجع قيمة عددية صحيحة.

**Note**: 
- يُفضل استخدام هذا الكلاس عند الحاجة إلى تعريف دالة مخصصة تُرجع قيمة عددية صحيحة.
- يمكن تعديل اسم الدالة أو نوع القيمة المُرجعة حسب الحاجة، ولكن يجب التأكد من توافق هذه التعديلات مع باقي أجزاء النظام.
***
#### FunctionDef visit_myfunc(element, compiler)
**visit_myfunc**: وظيفة `visit_myfunc` هي معالجة عنصر معين وإرجاع تمثيل نصي له باستخدام مُعالج (compiler) معين.

**parameters**: معاملات هذه الوظيفة.
· `element`: العنصر الذي يتم معالجته. يحتوي هذا العنصر على جزء يسمى `clauses` والذي يتم تمريره إلى المُعالج.
· `compiler`: المُعالج (compiler) المسؤول عن معالجة `clauses` الخاص بالعنصر.
· `**kw`: معاملات إضافية اختيارية يمكن تمريرها إلى المُعالج.

**Code Description**: تقوم هذه الوظيفة بمعالجة العنصر الممرر إليها (`element`) باستخدام المُعالج (`compiler`). يتم استخراج جزء `clauses` من العنصر ومعالجته باستخدام دالة `process` الخاصة بالمُعالج. النتيجة النهائية هي سلسلة نصية (string) تأخذ الشكل `"myfunc(<result>)"`، حيث `<result>` هو الناتج النصي الذي تم الحصول عليه من معالجة `clauses`.

**Note**: 
- يجب أن يحتوي العنصر الممرر على جزء `clauses` حتى تعمل الوظيفة بشكل صحيح.
- يمكن تمرير معاملات إضافية إلى المُعالج عبر `**kw` إذا كانت هناك حاجة إلى تخصيص إضافي في عملية المعالجة.

**Output Example**: إذا كانت نتيجة معالجة `clauses` هي `"clause_result"`، فإن الناتج النهائي للوظيفة سيكون:
```
"myfunc(clause_result)"
```
***
***
### FunctionDef test_use_labels(self)
**test_use_labels**: وظيفة `test_use_labels` هي التحقق من أن الترجمة (compile) لاستعلام SQL يتم بشكل صحيح عند استخدام التسميات (labels) بنمط محدد.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على الدالة `self.assert_compile` الموروثة من الفئة الأم.

**Code Description**: تقوم هذه الدالة باختبار عملية الترجمة لاستعلام SQL باستخدام الدالة `func.foo()` والتي تمثل دالة SQL عامة. يتم تعيين نمط التسمية (label style) باستخدام `LABEL_STYLE_TABLENAME_PLUS_COL`، وهو نمط يضيف اسم الجدول واسم العمود إلى التسمية. بعد ذلك، يتم استخدام الدالة `self.assert_compile` لمقارنة الناتج المتوقع مع الناتج الفعلي للاستعلام. الناتج المتوقع في هذه الحالة هو النص `"SELECT foo() AS foo_1"`، حيث يتم إضافة التسمية `foo_1` تلقائيًا بناءً على نمط التسمية المحدد.

**Note**: 
- يجب التأكد من أن نمط التسمية `LABEL_STYLE_TABLENAME_PLUS_COL` مدعوم بشكل صحيح في النظام.
- هذه الدالة تعتمد على دالة `self.assert_compile`، لذا يجب أن تكون هذه الدالة مُعرفة بشكل صحيح في الفئة الأم لضمان عمل الاختبار بشكل سليم.
***
### FunctionDef test_use_labels_function_element(self)
**test_use_labels_function_element**: وظيفة `test_use_labels_function_element` هي اختبار استخدام التسميات (labels) مع عناصر الدوال (FunctionElement) في استعلامات SQL.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة بخلاف `self` الذي يشير إلى نسخة الكائن الحالي.

**Code Description**: 
- تقوم الدالة بإنشاء فئة `max_` التي ترث من `FunctionElement`. هذه الفئة تمثل دالة SQL تسمى `max`، وتحتوي على خاصية `name` بقيمة `"max"` وخاصية `inherit_cache` بقيمة `True`، مما يعني أن النتائج المؤقتة (cache) لهذه الدالة ستُورث.
- يتم تعريف دالة `visit_max` باستخدام الديكوراتور `@compiles`، حيث يتم تحديد كيفية تحويل عنصر `max_` إلى نص SQL. في هذه الحالة، يتم إرجاع النص `"max(%s)"` حيث يتم استبدال `%s` بنتيجة معالجة `element.clauses` باستخدام `compiler.process`.
- يتم استخدام `self.assert_compile` لاختبار ما إذا كان الاستعلام الذي يستخدم `max_` مع التسميات (labels) يتم تحويله بشكل صحيح إلى نص SQL. يتم استخدام `select(max_(5, 6))` لإنشاء استعلام SQL يطبق الدالة `max` على القيمتين `5` و `6`. يتم تعيين نمط التسمية باستخدام `set_label_style(LABEL_STYLE_TABLENAME_PLUS_COL)`، مما يؤدي إلى إضافة تسمية إلى النتيجة.
- النتيجة المتوقعة هي النص `"SELECT max(:max_2, :max_3) AS max_1"`، حيث يتم تطبيق الدالة `max` على القيمتين `5` و `6` مع إضافة تسمية `max_1` إلى النتيجة.

**Note**: 
- يجب التأكد من أن نمط التسمية المستخدم (`LABEL_STYLE_TABLENAME_PLUS_COL`) متوافق مع قاعدة البيانات المستخدمة.
- الدالة `visit_max` يجب أن تكون متوافقة مع كيفية تحويل الدوال في SQLAlchemy.

**Output Example**: 
```sql
SELECT max(:max_2, :max_3) AS max_1
```
#### ClassDef max_
**max_**: وظيفة max_ هي تمثيل دالة الـ `max` في سياق معين، حيث يتم استخدامها كعنصر دالة (FunctionElement) ضمن هيكل مشروع معين.

**السمات (attributes)**:
· `name`: اسم الدالة، وهو هنا `"max"`، مما يشير إلى أن هذا العنصر يمثل دالة الـ `max`.
· `inherit_cache`: قيمة منطقية (Boolean) تُحدد ما إذا كان هذا العنصر يرث ذاكرة التخزين المؤقت (cache) من العناصر الأخرى. هنا القيمة هي `True`، مما يعني أن العنصر يستخدم ذاكرة التخزين المؤقت الموروثة.

**وصف الكود (Code Description)**:
هذا الكود يعرّف فئة (Class) تُسمى `max_`، والتي ترث من الفئة `FunctionElement`. الفئة `FunctionElement` تُستخدم عادةً لتمثيل عناصر الدوال في سياق برمجي معين. الفئة `max_` هنا تمثل دالة الـ `max`، والتي تُستخدم عادةً لإيجاد القيمة القصوى بين مجموعة من القيم.

السمة `name` تُحدد اسم الدالة التي يمثلها هذا العنصر، وهو هنا `"max"`. هذا يعني أن هذا العنصر سيتم التعامل معه على أنه دالة الـ `max` في السياق الذي يتم استخدامه فيه.

السمة `inherit_cache` تُحدد ما إذا كان هذا العنصر يستخدم ذاكرة التخزين المؤقت الموروثة من العناصر الأخرى. القيمة `True` تعني أن العنصر سيستخدم ذاكرة التخزين المؤقت، مما قد يحسن الأداء في حالات معينة عن طريق تجنب إعادة الحسابات غير الضرورية.

**ملاحظة (Note)**:
عند استخدام هذه الفئة، يجب التأكد من أن السياق الذي يتم استخدامها فيه يدعم دالة الـ `max` وأن ذاكرة التخزين المؤقت الموروثة تعمل بشكل صحيح. إذا كانت ذاكرة التخزين المؤقت غير مطلوبة أو تسبب مشاكل، يمكن تغيير قيمة `inherit_cache` إلى `False`.
***
#### FunctionDef visit_max(element, compiler)
**visit_max**: وظيفة `visit_max` هي تحويل عنصر يحتوي على دالة `max` إلى تمثيل نصي باستخدام المُصرِّف (compiler).

**parameters**: معاملات هذه الوظيفة.
· `element`: العنصر الذي يحتوي على الدالة `max` والتي سيتم تحويلها.
· `compiler`: المُصرِّف (compiler) المستخدم لمعالجة العنصر وتحويله إلى تمثيل نصي.
· `**kw`: معاملات إضافية اختيارية يمكن تمريرها إلى المُصرِّف.

**Code Description**: تقوم هذه الوظيفة بتحويل عنصر يحتوي على دالة `max` إلى تمثيل نصي باستخدام المُصرِّف. يتم ذلك عن طريق استدعاء الدالة `process` الخاصة بالمُصرِّف (`compiler.process`) لمعالجة الأجزاء الفرعية (`clauses`) للعنصر. النتيجة النهائية هي سلسلة نصية تحتوي على الدالة `max` مع الأجزاء الفرعية المعالجة داخلها. على سبيل المثال، إذا كانت الأجزاء الفرعية للعنصر هي `(a, b, c)`، فإن النتيجة ستكون `"max(a, b, c)"`.

**Note**: يجب أن يحتوي العنصر (`element`) على خاصية `clauses` حتى تعمل الوظيفة بشكل صحيح. كما يجب أن يدعم المُصرِّف (`compiler`) الدالة `process` لمعالجة الأجزاء الفرعية.

**Output Example**: إذا كانت الأجزاء الفرعية للعنصر هي `(x, y, z)`، فإن الناتج سيكون:
```
"max(x, y, z)"
```
***
***
### FunctionDef test_underscores(self)
**test_underscores**: وظيفة `test_underscores` هي التحقق من أن الدالة `if_` تُترجم بشكل صحيح إلى النص "if()".

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث إنها تعتمد على الدالة `self.assert_compile` للتحقق من النتيجة.

**Code Description**: تقوم هذه الدالة باختبار وظيفة `if_` الموجودة في الكائن `func`. يتم استخدام الدالة `self.assert_compile` للتحقق من أن استدعاء `func.if_()` يُرجع النص "if()". بمعنى آخر، يتم التأكد من أن الدالة `if_` تُترجم بشكل صحيح إلى النص المطلوب.

**Note**: يُفترض أن تكون الدالة `if_` جزءًا من الكائن `func`، ويجب أن تكون قادرة على إرجاع النص "if()" عند استدعائها. إذا لم يتم تحقيق ذلك، فإن الاختبار سيفشل.
***
### FunctionDef test_underscores_packages(self)
**test_underscores_packages**: وظيفة `test_underscores_packages` هي التحقق من أن الترجمة البرمجية للدالة `func.foo_.bar_.if_()` تعطي النتيجة المتوقعة وهي `"foo.bar.if()"`.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على الكائن `self` الذي يتم تمريره تلقائيًا في سياق اختبار وحدة (unit test).

**Code Description**: تقوم هذه الدالة باختبار عملية الترجمة البرمجية (compilation) لدالة معينة تحتوي على شرطات سفلية (underscores) في أسماء الحزم (packages) أو الوحدات (modules). يتم استخدام الدالة `assert_compile` للتحقق من أن استدعاء الدالة `func.foo_.bar_.if_()` ينتج عنه النص `"foo.bar.if()"`. 

- `func.foo_.bar_.if_()`: تمثل هذه الدالة استدعاءً لوظيفة معينة تحتوي على شرطات سفلية في أسماء الحزم أو الوحدات.
- `"foo.bar.if()"`: هذا هو الناتج المتوقع من عملية الترجمة البرمجية للدالة المذكورة أعلاه.

**Note**: 
- هذه الدالة جزء من اختبار وحدة (unit test) وتستخدم للتحقق من صحة الترجمة البرمجية للدوال التي تحتوي على شرطات سفلية في أسماء الحزم أو الوحدات.
- يجب التأكد من أن الدالة `assert_compile` معرّفة بشكل صحيح في الكائن `self` وأنها قادرة على مقارنة النتائج بشكل دقيق.
- يُفضل استخدام هذه الدالة في سياق اختبارات البرمجيات للتأكد من أن التسميات التي تحتوي على شرطات سفلية تعمل بشكل صحيح.
***
### FunctionDef test_uppercase(self)
**test_uppercase**: وظيفة `test_uppercase` هي التحقق من أن الدالة `UNREGISTERED_FN` تُترجم بشكل صحيح إلى نص بأحرف كبيرة عند استخدامها في عملية الترجمة (compilation).  
**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.  
**Code Description**:  
تقوم هذه الدالة باختبار عملية الترجمة (compilation) للدالة `UNREGISTERED_FN`. يتم استخدام الأسلوب `assert_compile` للتحقق من أن نتيجة ترجمة الدالة `UNREGISTERED_FN()` هي النص `"UNREGISTERED_FN()"`. يتم التأكد من أن النتيجة تحتوي على الأحرف الكبيرة (uppercase) كما هو متوقع.  

الهدف من هذا الاختبار هو ضمان أن الدالة `UNREGISTERED_FN` تُترجم بشكل صحيح مع الحفاظ على حالة الأحرف (case insensitivity) في الوقت الحالي.  

**Note**:  
- يتم استخدام `assert_compile` للتحقق من صحة الترجمة.  
- يجب ملاحظة أن الاختبار يتوقع نتيجة بأحرف كبيرة (uppercase) للدالة `UNREGISTERED_FN`.  
- قد يتم تعديل هذا الاختبار في المستقبل إذا تغيرت متطلبات حالة الأحرف (case sensitivity).
***
### FunctionDef test_uppercase_packages(self)
**test_uppercase_packages**: وظيفة `test_uppercase_packages` هي التحقق من أن الدالة `func.FOO.BAR.NOW()` تُترجم بشكل صحيح إلى النص "FOO.BAR.NOW()" مع الحفاظ على حساسية الحروف الكبيرة.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.

**Code Description**:  
تقوم هذه الدالة باختبار ما إذا كانت الدالة `func.FOO.BAR.NOW()` تُرجع النص "FOO.BAR.NOW()" بشكل صحيح. يتم ذلك باستخدام الأسلوب `assert_compile` الذي يتحقق من أن الناتج النهائي للدالة يتطابق مع النص المتوقع. في هذه الحالة، يتم التحقق من أن النص الناتج يحتوي على الحروف الكبيرة "FOO.BAR.NOW()"، مما يشير إلى أن الدالة تعمل بشكل صحيح مع الحفاظ على حساسية الحروف الكبيرة.

**Note**:  
- هذه الدالة تعتمد على أسلوب `assert_compile` للتحقق من الناتج، لذا يجب التأكد من أن هذا الأسلوب يعمل بشكل صحيح قبل استخدام هذه الدالة.  
- يتم التركيز هنا على الحفاظ على حساسية الحروف الكبيرة، لذا يجب التأكد من أن أي تغييرات في الدالة `func.FOO.BAR.NOW()` لا تؤثر على هذا السلوك.
***
### FunctionDef test_mixed_case(self)
**test_mixed_case**: وظيفة `test_mixed_case` هي التحقق من أن الدالة `SomeFunction` تُترجم بشكل صحيح مع الحفاظ على حالة الحروف (case insensitivity).

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذها باستخدام `self` فقط.

**Code Description**: تقوم هذه الدالة باختبار ما إذا كانت الدالة `SomeFunction` تُترجم بشكل صحيح مع الحفاظ على حالة الحروف. يتم ذلك من خلال استخدام الدالة `assert_compile` التي تقارن نتيجة ترجمة `SomeFunction()` مع النص المتوقع `"SomeFunction()"`. الهدف من هذا الاختبار هو التأكد من أن الدالة تُترجم بشكل صحيح حتى في حالة استخدام حالة حروف مختلطة (mixed case).

**Note**: من المهم ملاحظة أن هذا الاختبار يعتمد على الحفاظ على حالة الحروف (case insensitivity) في الوقت الحالي، مما يعني أن الدالة يجب أن تعمل بشكل صحيح بغض النظر عن حالة الحروف المستخدمة في الاسم.
***
### FunctionDef test_mixed_case_packages(self)
**test_mixed_case_packages**: وظيفة `test_mixed_case_packages` هي التحقق من أن الترجمة (compilation) للدالة `SomeFunction` الموجودة ضمن الحزم ذات الحروف المختلطة (mixed case) تعمل بشكل صحيح.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة يتم تمريرها إليها بشكل مباشر.

**Code Description**: تقوم هذه الدالة باختبار عملية الترجمة (compilation) لدالة معينة تسمى `SomeFunction` والتي تكون جزءًا من هيكل حزم (packages) بأسماء تحتوي على حروف كبيرة وصغيرة (mixed case). يتم ذلك من خلال استدعاء الدالة `assert_compile` والتي تأخذ كمعاملين: الأول هو استدعاء الدالة `SomeFunction` من خلال المسار `func.Foo.Bar.SomeFunction()`، والثاني هو النص المتوقع بعد الترجمة، وهو `"Foo.Bar.SomeFunction()"`. الهدف من هذا الاختبار هو التأكد من أن النظام يدعم الحساسية لحالة الأحرف (case insensitivity) في أسماء الحزم والدوال.

**Note**: من المهم ملاحظة أن هذا الاختبار يعتمد على افتراض أن النظام يجب أن يدعم الحساسية لحالة الأحرف (case insensitivity) في أسماء الحزم والدوال. أي أن النظام يجب أن يتعامل مع `Foo.Bar.SomeFunction()` و `foo.bar.somefunction()` بنفس الطريقة.
***
### FunctionDef test_quote_special_chars(self)
**test_quote_special_chars**: وظيفة `test_quote_special_chars` هي اختبار كيفية تعامل الدالة مع الأسماء التي تحتوي على أحرف خاصة أو مسافات عند تحويلها إلى نص برمجي (compile).

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على الكائن `self` الذي يتم تمريره تلقائيًا في سياق اختبار وحدة (unit test).

**Code Description**: تقوم هذه الدالة باختبار عملية التحويل (compile) لدالة تحتوي على اسم يحتوي على أحرف خاصة أو مسافات. يتم ذلك باستخدام الدالة `assert_compile`، والتي تقارن الناتج الفعلي مع الناتج المتوقع. 

في هذا الاختبار، يتم استدعاء دالة ذات اسم غير تقليدي (`"im a function"`) باستخدام `getattr`، حيث يتم تمرير اسم الدالة كسلسلة نصية. بعد ذلك، يتم مقارنة الناتج النصي الناتج من عملية التحويل مع النص المتوقع `'"im a function"()'`. الهدف من هذا الاختبار هو التأكد من أن الأسماء التي تحتوي على أحرف خاصة أو مسافات يتم اقتباسها بشكل صحيح عند تحويلها إلى نص برمجي.

**Note**: 
- هذا الاختبار مفيد بشكل خاص عند التعامل مع أسماء الدوال أو المعرفات التي تحتوي على أحرف غير قياسية أو مسافات، حيث يجب التأكد من أن النظام يعالجها بشكل صحيح.
- يجب أن تكون النتيجة المتوقعة (`'"im a function"()'`) مطابقة تمامًا للناتج الفعلي، حيث إن أي اختلاف قد يشير إلى وجود مشكلة في آلية الاقتباس أو التحويل.
***
### FunctionDef test_quote_special_chars_packages(self)
**test_quote_special_chars_packages**: وظيفة `test_quote_special_chars_packages` هي التحقق من أن الأسماء التي تحتوي على أحرف خاصة أو مسافات يتم اقتباسها بشكل صحيح عند استخدامها في سياق تعريف الحزم والدوال.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذها كجزء من فئة اختبار (test class) وتعتمد على الدوال الموروثة من الفئة الأم.

**Code Description**: تقوم هذه الدالة باختبار عملية الاقتباس (quoting) للأسماء التي تحتوي على أحرف خاصة أو مسافات في سياق تعريف الحزم والدوال. يتم ذلك من خلال استدعاء دالة `assert_compile` التي تقارن بين الناتج الفعلي والناتج المتوقع. 

في الكود، يتم استخدام الدالة `getattr` بشكل متداخل للوصول إلى دالة معينة داخل حزمتين تحتويان على أسماء تحتوي على مسافات. يتم استدعاء الدالة النهائية باستخدام الأقواس `()`. الناتج المتوقع هو سلسلة نصية تحتوي على أسماء الحزم والدالة مقتبسة بشكل صحيح باستخدام علامات الاقتباس المزدوجة (`"`). على سبيل المثال، `"im foo package"."im bar package"."im a function"()`.

**Note**: 
- يجب التأكد من أن الأسماء التي تحتوي على مسافات أو أحرف خاصة يتم اقتباسها بشكل صحيح عند استخدامها في تعريف الحزم والدوال.
- هذه الدالة جزء من اختبارات التحويل (compilation tests) وتستخدم للتحقق من صحة عملية الاقتباس في سياق معين.
***
### FunctionDef test_generic_now(self)
**test_generic_now**: وظيفة `test_generic_now` هي التحقق من أن دالة `now()` تعمل بشكل صحيح عبر قواعد بيانات مختلفة وتعيد نوع البيانات المناسب.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) لأنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى الكائن الحالي.

**Code Description**: تقوم هذه الدالة باختبار وظيفة `now()` من خلال الخطوات التالية:
1. **التحقق من نوع البيانات**: يتم التحقق من أن نوع البيانات الذي تُعيده الدالة `now()` هو من نوع `sqltypes.DateTime` باستخدام `isinstance()`. وهذا يؤكد أن الدالة تُعيد قيمة تاريخ ووقت صحيحة.
2. **اختبار الترجمة (Compilation) عبر قواعد بيانات مختلفة**: يتم اختبار كيفية ترجمة الدالة `now()` إلى صيغ SQL مختلفة بناءً على نوع قاعدة البيانات (dialect). يتم ذلك من خلال تمرير قائمة تحتوي على أزواج من القيم المتوقعة (`ret`) ونوع قاعدة البيانات (`dialect`) لكل من:
   - SQLite: حيث يُتوقع أن تُترجم الدالة إلى `"CURRENT_TIMESTAMP"`.
   - PostgreSQL: حيث يُتوقع أن تُترجم الدالة إلى `"now()"`.
   - MySQL: حيث يُتوقع أن تُترجم الدالة إلى `"now()"`.
   - Oracle: حيث يُتوقع أن تُترجم الدالة إلى `"CURRENT_TIMESTAMP"`.
   
   يتم استخدام الدالة `self.assert_compile()` للتحقق من أن الترجمة تتم بشكل صحيح لكل نوع قاعدة بيانات.

**Note**: 
- هذه الدالة مخصصة للاختبار (unit testing) وتُستخدم للتحقق من أن دالة `now()` تعمل بشكل صحيح عبر أنظمة قواعد بيانات متعددة.
- يجب أن تكون الدالة `now()` مُعرفة بشكل صحيح في الكود الأساسي حتى تعمل هذه الاختبارات بشكل صحيح.
- يتم استخدام `sqltypes.DateTime` للتحقق من نوع البيانات، مما يعني أن الدالة `now()` يجب أن تُعيد قيمة من نوع التاريخ والوقت.
***
### FunctionDef test_generic_random(self)
**test_generic_random**: وظيفة `test_generic_random` هي اختبار وظيفة `random` من مكتبة `func` للتأكد من أنها تعمل بشكل صحيح مع أنواع البيانات المختلفة ولهجات قواعد البيانات المختلفة.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على `self` كمعامل ضمني لكونها جزءًا من فئة (class).

**Code Description**: تقوم هذه الوظيفة باختبار سلوك وظيفة `random` من مكتبة `func` في عدة حالات:

1. **الاختبار الأول**: يتم التحقق من أن نوع القيمة المُرجعة من `func.random()` هو `sqltypes.NULLTYPE`، مما يعني أن الوظيفة تُرجع قيمة بدون نوع محدد بشكل افتراضي.

2. **الاختبار الثاني**: يتم التحقق من أن نوع القيمة المُرجعة من `func.random(type_=Integer)` هو `Integer`، مما يعني أن الوظيفة يمكنها إرجاع قيم من نوع محدد إذا تم تمرير النوع كمعامل.

3. **الاختبار الثالث**: يتم التحقق من أن ترجمة (compile) وظيفة `random` تعمل بشكل صحيح مع لهجات قواعد البيانات المختلفة. يتم ذلك من خلال تمرير لهجات قواعد البيانات مثل `sqlite`، `postgresql`، `mysql`، و`oracle`، والتأكد من أن الناتج المترجم يتطابق مع التوقعات لكل لهجة. على سبيل المثال:
   - مع `sqlite` و`postgresql` و`oracle`، يتم توقع أن الناتج سيكون `"random()"`.
   - مع `mysql`، يتم توقع أن الناتج سيكون `"rand()"`.

**Note**: 
- هذه الوظيفة مخصصة للاختبار ولا تُستخدم في الإنتاج.
- يجب التأكد من أن مكتبة `func` وأنواع البيانات مثل `Integer` و`sqltypes.NULLTYPE` متاحة في البيئة التي يتم تشغيل الاختبار فيها.
- يتم استخدام `self.assert_compile` للتحقق من أن الترجمة تعمل بشكل صحيح مع كل لهجة من لهجات قواعد البيانات.
***
### FunctionDef test_return_type_aggregate_strings(self)
**test_return_type_aggregate_strings**: وظيفة `test_return_type_aggregate_strings` هي التحقق من أن نوع القيمة المُرجعة من دالة تجميع النصوص (`aggregate_strings`) هو من نوع `String`.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على الكائن `self` الذي يمثل حالة الاختبار الحالية.

**Code Description**: 
- تقوم الدالة بإنشاء جدول افتراضي باسم `t` يحتوي على عمود واحد باسم `value` من نوع `String`.
- يتم استخدام الدالة `func.aggregate_strings` لتجميع القيم الموجودة في العمود `value` مع فصلها بفاصلة `,`.
- يتم التحقق من أن نوع القيمة المُرجعة من التعبير `expr` هو من نوع `String` باستخدام الدالة `is_`، حيث يتم مقارنة `expr.type._type_affinity` مع `String`.

**Note**: 
- هذه الدالة جزء من اختبارات وحدة (unit tests) تهدف إلى التأكد من أن دالة تجميع النصوص تعيد نوع البيانات المتوقع.
- يجب أن يكون العمود `value` من نوع `String` حتى تعمل الدالة بشكل صحيح.

**Output Example**: لا تُرجع هذه الدالة أي قيمة (void)، حيث إنها تقوم بإجراء اختبار فقط. إذا كان الاختبار ناجحًا، فلن يتم إرجاع أي أخطاء. إذا فشل الاختبار، سيتم إرجاع خطأ يشير إلى أن نوع البيانات المُرجَع غير متطابق مع `String`.
***
### FunctionDef test_aggregate_strings(self, expected_sql, dialect)
**test_aggregate_strings**: وظيفة `test_aggregate_strings` هي اختبار وظيفة تجميع النصوص (`aggregate_strings`) في استعلام SQL باستخدام مكتبة SQLAlchemy.

**parameters**: معاملات هذه الوظيفة.
· `expected_sql`: الناتج المتوقع من عملية التجميع في صيغة SQL.
· `dialect`: لهجة SQL التي سيتم استخدامها لتحقيق الاستعلام (مثل MySQL، PostgreSQL، إلخ).

**Code Description**: 
تقوم هذه الوظيفة بإنشاء جدول افتراضي باسم `t` يحتوي على عمود واحد باسم `value` من نوع `String`. بعد ذلك، يتم إنشاء استعلام SQL باستخدام الدالة `select` من مكتبة SQLAlchemy، حيث يتم استدعاء الدالة `aggregate_strings` لتجميع القيم في العمود `value` مع فصلها بفاصلة (`,`). 

الوظيفة `assert_compile` تُستخدم لمقارنة الناتج الفعلي للاستعلام مع الناتج المتوقع (`expected_sql`) باستخدام اللهجة المحددة (`dialect`). إذا تطابقت النتائج، فإن الاختبار يعتبر ناجحًا.

**Note**: 
- يجب التأكد من أن اللهجة (`dialect`) المحددة متوافقة مع قاعدة البيانات المستخدمة.
- الوظيفة `aggregate_strings` يجب أن تكون معرّفة مسبقًا في المشروع أو المكتبة المستخدمة.
- هذه الوظيفة تُستخدم بشكل أساسي في اختبارات الوحدة (unit tests) للتحقق من صحة بناء استعلامات SQL.
***
### FunctionDef test_cube_operators(self)
**test_cube_operators**: وظيفة `test_cube_operators` هي اختبار وظائف التجميع باستخدام `CUBE`، `ROLLUP`، و`GROUPING SETS` في SQL.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على `self` كمعامل ضمني للوصول إلى وظائف الفئة التي تنتمي إليها.

**Code Description**: تقوم هذه الوظيفة باختبار كيفية ترجمة واستخدام وظائف التجميع `CUBE`، `ROLLUP`، و`GROUPING SETS` في SQL. يتم ذلك من خلال إنشاء جدول افتراضي باسم `t` يحتوي على أعمدة `value`، `x`، `y`، `z`، و`q`. بعد ذلك، يتم إنشاء استعلام `SELECT` يقوم بحساب مجموع القيم في العمود `value`.

1. **اختبار `CUBE`**: يتم استخدام `func.cube(t.c.x, t.c.y)` لتجميع البيانات بناءً على الأعمدة `x` و`y` باستخدام `CUBE`. يتم التحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع:
   ```sql
   SELECT sum(t.value) AS sum_1 FROM t GROUP BY CUBE(t.x, t.y)
   ```

2. **اختبار `ROLLUP`**: يتم استخدام `func.rollup(t.c.x, t.c.y)` لتجميع البيانات باستخدام `ROLLUP`. يتم التحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع:
   ```sql
   SELECT sum(t.value) AS sum_1 FROM t GROUP BY ROLLUP(t.x, t.y)
   ```

3. **اختبار `GROUPING SETS`**: يتم استخدام `func.grouping_sets(t.c.x, t.c.y)` لتجميع البيانات باستخدام `GROUPING SETS`. يتم التحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع:
   ```sql
   SELECT sum(t.value) AS sum_1 FROM t GROUP BY GROUPING SETS(t.x, t.y)
   ```

4. **اختبار `GROUPING SETS` مع `tuple_`**: يتم استخدام `func.grouping_sets` مع `sql.tuple_` لتجميع البيانات بناءً على مجموعات محددة من الأعمدة. يتم التحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع:
   ```sql
   SELECT sum(t.value) AS sum_1 FROM t GROUP BY GROUPING SETS((t.x, t.y), (t.z, t.q))
   ```

**Note**: 
- هذه الوظيفة مخصصة للاختبار ولا تقوم بتنفيذ الاستعلامات فعليًا، بل تتحقق من صحة الترجمة النصية للاستعلامات.
- يجب التأكد من أن الأعمدة المستخدمة في التجميع موجودة في الجدول المحدد.
- يمكن استخدام هذه الوظيفة كمرجع لفهم كيفية استخدام وظائف التجميع في SQLAlchemy.
***
### FunctionDef test_generic_annotation(self)
**test_generic_annotation**: وظيفة `test_generic_annotation` هي اختبار إضافة تعليقات عامة (annotations) إلى دالة معينة والتحقق من صحة الترجمة (compilation) لهذه الدالة.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على الدوال والخصائص المضمنة في الكائن `self`.

**Code Description**: تقوم هذه الدالة بإنشاء دالة `fn` باستخدام الدالة `coalesce` التي تأخذ معاملين وهما `"x"` و`"y"`. بعد ذلك، يتم إضافة تعليق عام (annotation) إلى الدالة `fn` باستخدام الدالة `_annotate`، حيث يتم تمرير قاموس يحتوي على زوج مفتاح-قيمة وهو `{"foo": "bar"}`. أخيرًا، يتم التحقق من صحة الترجمة (compilation) للدالة `fn` باستخدام الدالة `self.assert_compile`، حيث يتم مقارنة الناتج مع النص المتوقع `"coalesce(:coalesce_1, :coalesce_2)"`.

**Note**: يجب التأكد من أن الدالة `coalesce` والدالة `_annotate` تعملان بشكل صحيح قبل استخدام هذه الدالة. بالإضافة إلى ذلك، يجب أن تكون الدالة `self.assert_compile` قادرة على التحقق من صحة الترجمة بشكل دقيق.
***
### FunctionDef test_annotation_dialect_specific(self)
**test_annotation_dialect_specific**: وظيفة `test_annotation_dialect_specific` هي اختبار كيفية تعامل الدالة `current_date` مع التعليقات التوضيحية (annotations) عند استخدامها مع dialect محدد مثل SQLite.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على `self` كمعامل ضمني لكونها جزءًا من فئة اختبار (test class).

**Code Description**: تقوم هذه الدالة باختبار سلوك الدالة `current_date` من مكتبة `func` عند استخدامها مع dialect محدد وهو SQLite. يتم ذلك عبر الخطوات التالية:

1. يتم استدعاء الدالة `current_date` من مكتبة `func` وتخزين النتيجة في المتغير `fn`.
2. يتم استخدام الدالة `assert_compile` للتحقق من أن الترجمة (compilation) للدالة `fn` تعطي النتيجة المتوقعة وهي النص `"CURRENT_DATE"` عند استخدام dialect SQLite.
3. يتم إضافة تعليق توضيحي (annotation) إلى الدالة `fn` باستخدام الدالة `_annotate`، حيث يتم تمرير قاموس يحتوي على زوج مفتاح-قيمة (`{"foo": "bar"}`).
4. يتم إعادة استخدام الدالة `assert_compile` للتحقق من أن الترجمة لا تزال تعطي النتيجة المتوقعة `"CURRENT_DATE"` حتى بعد إضافة التعليق التوضيحي.

**Note**: 
- هذه الدالة مخصصة للاختبارات (unit testing) وتتحقق من أن إضافة التعليقات التوضيحية لا تؤثر على ترجمة الدالة عند استخدام dialect محدد.
- يجب التأكد من أن dialect المستخدم (في هذه الحالة SQLite) مدعوم بشكل صحيح في البيئة التي يتم فيها تشغيل الاختبارات.
***
### FunctionDef test_custom_default_namespace(self)
**test_custom_default_namespace**: وظيفة `test_custom_default_namespace` هي اختبار إنشاء واستخدام دالة مخصصة مع مساحة اسم افتراضية مخصصة.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.

**Code Description**:  
تقوم هذه الدالة باختبار إنشاء دالة مخصصة (`myfunc`) من خلال تعريف كلاس `myfunc` الذي يرث من `GenericFunction`. يتم تعيين الخاصية `inherit_cache` إلى `True` لضمان أن الدالة تستخدم التخزين المؤقت عند الوراثة.  

بعد ذلك، يتم التحقق من أن استدعاء الدالة `func.myfunc()` يعيد كائنًا من نوع `myfunc` باستخدام `assert isinstance(func.myfunc(), myfunc)`. هذا يضمن أن الدالة المخصصة تم إنشاؤها بشكل صحيح.  

أخيرًا، يتم استخدام `self.assert_compile(func.myfunc(), "myfunc()")` للتحقق من أن الترجمة (compilation) للدالة تعيد النص `"myfunc()"`، مما يؤكد أن الدالة تعمل كما هو متوقع عند الترجمة.

**Note**:  
- هذه الدالة تعتمد على وجود تعريف `func` و`GenericFunction` في البيئة المحيطة.  
- يتم استخدام `assert` للتحقق من الشروط، مما يعني أن الاختبار سيفشل إذا لم تكن الشروط صحيحة.  
- يجب التأكد من أن `inherit_cache = True` يتم استخدامه بشكل صحيح إذا كانت هناك حاجة لتخزين مؤقت للدوال الموروثة.
#### ClassDef myfunc
**myfunc**: وظيفة myfunc هي توفير وظيفة عامة (GenericFunction) مع إمكانية توريث الذاكرة المؤقتة (cache).

**attributes**: السمات الخاصة بهذا الكلاس.
· inherit_cache: هذه السمة تحدد ما إذا كان سيتم توريث الذاكرة المؤقتة (cache) من الوظائف الأم. القيمة الافتراضية هي `True`، مما يعني أن الذاكرة المؤقتة ستُورث.

**Code Description**: هذا الكلاس `myfunc` هو امتداد للكلاس `GenericFunction`، والذي يُستخدم عادةً لتعريف وظائف عامة يمكن استخدامها في سياقات مختلفة. السمة `inherit_cache` تُحدد ما إذا كان سيتم توريث الذاكرة المؤقتة من الوظائف الأم. عندما تكون القيمة `True`، فإن الذاكرة المؤقتة ستُورث، مما يعني أن النتائج المحسوبة مسبقًا يمكن إعادة استخدامها دون الحاجة إلى إعادة الحساب. هذا يمكن أن يحسن الأداء في الحالات التي يتم فيها استدعاء الوظيفة بشكل متكرر بنفس المدخلات.

**Note**: عند استخدام هذا الكلاس، تأكد من فهمك لكيفية عمل الذاكرة المؤقتة (cache) وكيفية تأثيرها على الأداء. إذا كانت الذاكرة المؤقتة غير مطلوبة أو إذا كانت تسبب مشاكل في التطبيق الخاص بك، يمكنك تعيين `inherit_cache` إلى `False`.
***
***
### FunctionDef test_custom_type(self)
**test_custom_type**: وظيفة `test_custom_type` هي اختبار وظيفة مخصصة (custom function) من نوع `DateTime` والتأكد من أنها تعمل بشكل صحيح.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة.

**Code Description**: 
- تقوم الوظيفة بإنشاء فئة مخصصة تسمى `myfunc` والتي ترث من `GenericFunction`. يتم تعيين النوع (type) لهذه الفئة إلى `DateTime`، مما يعني أن هذه الوظيفة ستتعامل مع قيم من نوع `DateTime`.
- يتم تعيين `inherit_cache` إلى `True`، مما يعني أن النتائج المحسوبة مسبقًا لهذه الوظيفة سيتم تخزينها في الذاكرة المؤقتة (cache) لتحسين الأداء.
- بعد ذلك، يتم التحقق من أن النوع (type) الخاص بالوظيفة `myfunc` هو بالفعل `DateTime` باستخدام `assert isinstance(func.myfunc().type, DateTime)`.
- أخيرًا، يتم التحقق من أن الترجمة (compilation) للوظيفة `myfunc` تعطي النتيجة المتوقعة باستخدام `self.assert_compile(func.myfunc(), "myfunc()")`.

**Note**: 
- هذه الوظيفة مخصصة للاختبار (testing) فقط، ويتم استخدامها للتأكد من أن الوظيفة المخصصة `myfunc` تعمل بشكل صحيح مع النوع `DateTime`.
- يجب التأكد من أن `GenericFunction` و `DateTime` تم استيرادهما بشكل صحيح قبل استخدام هذه الوظيفة.
#### ClassDef myfunc
**myfunc**: وظيفة الفئة `myfunc` هي توفير دالة عامة (GenericFunction) تعمل مع نوع بيانات `DateTime` وتدعم التخزين المؤقت الوراثي (inherit_cache).

**attributes**: السمات الخاصة بهذه الفئة.
· `type`: يتم تعيينه إلى `DateTime`، مما يشير إلى أن هذه الدالة مصممة للعمل مع نوع البيانات `DateTime`.
· `inherit_cache`: يتم تعيينه إلى `True`، مما يعني أن هذه الدالة تدعم التخزين المؤقت الوراثي، أي أنها تستخدم التخزين المؤقت من الفئة الأم إذا كان متاحًا.

**Code Description**: 
الفئة `myfunc` هي فئة فرعية من `GenericFunction`، وهي مصممة لتوفير دالة عامة تعمل مع نوع بيانات `DateTime`. يتم تحديد نوع البيانات الذي تعمل معه هذه الدالة من خلال السمة `type`، والتي يتم تعيينها إلى `DateTime`. بالإضافة إلى ذلك، تدعم هذه الفئة التخزين المؤقت الوراثي من خلال السمة `inherit_cache`، والتي يتم تعيينها إلى `True`. هذا يعني أن الدالة ستستخدم التخزين المؤقت من الفئة الأم إذا كان متاحًا، مما يمكن أن يحسن الأداء عن طريق تجنب إعادة الحسابات غير الضرورية.

**Note**: 
- عند استخدام هذه الفئة، تأكد من أن نوع البيانات الذي يتم تمريره يتوافق مع `DateTime`، حيث أن الدالة مصممة خصيصًا للعمل مع هذا النوع.
- التخزين المؤقت الوراثي يمكن أن يكون مفيدًا لتحسين الأداء، ولكن يجب التأكد من أن الفئة الأم توفر التخزين المؤقت بشكل صحيح.
***
***
### FunctionDef test_custom_legacy_type(self)
**test_custom_legacy_type**: وظيفة `test_custom_legacy_type` هي اختبار نظام مخصص لنوع قديم (legacy type) يستخدم في المشروع.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.

**Code Description**: تقوم هذه الدالة باختبار نظام مخصص لنوع قديم (legacy type) يتم استخدامه في المشروع. يتم ذلك من خلال إنشاء فئة مخصصة تسمى `myfunc` والتي ترث من `GenericFunction`. تحتوي هذه الفئة على خاصية `inherit_cache` التي يتم تعيينها إلى `True`، مما يشير إلى أن هذه الفئة ستستخدم التخزين المؤقت للنتائج. بالإضافة إلى ذلك، يتم تعيين `__return_type__` إلى `DateTime`، مما يعني أن النوع الذي ستعيده هذه الدالة هو من نوع `DateTime`.

بعد ذلك، يتم استخدام `func.myfunc()` لإنشاء كائن من الفئة `myfunc`، ويتم التحقق من أن النوع الذي يعيده هذا الكائن هو بالفعل من نوع `DateTime` باستخدام `isinstance`.

**Note**: 
- هذه الدالة مخصصة للتحقق من أن النظام القديم يعمل بشكل صحيح مع النوع المخصص `DateTime`.
- يجب التأكد من أن `GenericFunction` و `DateTime` تم استيرادهما بشكل صحيح قبل استخدام هذه الدالة.

**Output Example**: لا تحتوي هذه الدالة على قيمة إرجاع (return value) مباشرة، ولكنها تقوم بطباعة `True` إذا كان النوع الذي يعيده `func.myfunc()` هو `DateTime`.
#### ClassDef myfunc
**myfunc**: وظيفة myfunc هي توفير دالة عامة (GenericFunction) تُرجع نوع بيانات من نوع DateTime.

**attributes**: السمات الخاصة بهذا الكلاس.
· inherit_cache: هذه السمة تُحدد ما إذا كان الكلاس سيورث ذاكرة التخزين المؤقت من الكلاس الأب. القيمة هنا هي `True`، مما يعني أن الكلاس سيستخدم ذاكرة التخزين المؤقت الموروثة.
· __return_type__: هذه السمة تُحدد نوع البيانات الذي سترجعه الدالة. في هذه الحالة، القيمة هي `DateTime`، مما يعني أن الدالة سترجع قيمة من نوع DateTime.

**Code Description**: وصف الكود.
يُعرِّف هذا الكلاس دالة عامة (GenericFunction) تُسمى `myfunc`. الكلاس يرث من `GenericFunction`، مما يسمح له بالعمل كدالة قابلة للتخصيص مع إمكانية تحديد نوع الإرجاع. السمة `inherit_cache` مُعينة إلى `True`، مما يعني أن الكلاس سيستخدم ذاكرة التخزين المؤقت الموروثة من الكلاس الأب، مما قد يحسن الأداء في حالات معينة. السمة `__return_type__` تُحدد أن نوع الإرجاع للدالة سيكون `DateTime`، مما يعني أن الدالة مُصممة للتعامل مع القيم الزمنية وإرجاعها.

**Note**: ملاحظات حول استخدام الكود.
- يجب التأكد من أن الكلاس الذي يستخدم `myfunc` يعمل مع أنواع البيانات الزمنية (DateTime) بشكل صحيح.
- نظرًا لأن `inherit_cache` مُعينة إلى `True`، يجب مراعاة أن استخدام ذاكرة التخزين المؤقت قد يؤثر على الأداء في حالات معينة، خاصة إذا كانت البيانات كبيرة أو معقدة.

**Output Example**: مثال على إخراج الكود.
```python
# مثال على استخدام myfunc
result = myfunc()
print(result)  # الإخراج المتوقع: قيمة من نوع DateTime، مثل: 2023-10-05 14:30:00
```
***
***
### FunctionDef test_case_sensitive(self)
**test_case_sensitive**: وظيفة `test_case_sensitive` هي اختبار حساسية الأحرف الكبيرة والصغيرة عند استخدام دالة عامة (GenericFunction) مع نوع محدد.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذها داخل سياق كائن (self) ولا تتطلب مدخلات خارجية.

**Code Description**: تقوم هذه الدالة باختبار ما إذا كانت الدالة العامة `MYFUNC` التي تم تعريفها داخل الدالة حساسة لحالة الأحرف (case-sensitive) عند استدعائها. يتم ذلك من خلال الخطوات التالية:

1. يتم تعريف فئة `MYFUNC` التي ترث من `GenericFunction` وتحديد خاصية `type` لتكون من نوع `DateTime`. كما يتم تعيين `inherit_cache` إلى `True` للسماح بتخزين النتائج مؤقتًا.

2. يتم استخدام الدالة `func` لاستدعاء `MYFUNC` بأحرف مختلفة (مثل `MYFUNC`، `MyFunc`، `mYfUnC`، `myfunc`) والتحقق من أن النوع (`type`) الذي يتم إرجاعه هو من نوع `DateTime` في جميع الحالات.

3. يتم استخدام `assert` للتأكد من أن النوع الذي يتم إرجاعه في كل حالة هو `DateTime`، مما يؤكد أن الدالة لا تتأثر بحالة الأحرف (case-insensitive).

**Note**: 
- هذه الدالة مفيدة في اختبار سلوك الدوال العامة (GenericFunction) عند استدعائها بأحرف مختلفة، مما يضمن أن النظام لا يتأثر بحالة الأحرف.
- يجب التأكد من أن الدالة `func` متاحة في السياق الذي يتم تنفيذ الاختبار فيه، وأن `DateTime` تم تعريفه بشكل صحيح.
#### ClassDef MYFUNC
**MYFUNC**: وظيفة MYFUNC هي توفير دالة عامة (GenericFunction) تعمل مع نوع البيانات DateTime.

**السمات (Attributes)**:
· `inherit_cache = True`: يشير هذا السمة إلى أن الدالة ترث القيم المخزنة مؤقتًا (cache) من الدوال الأخرى في التسلسل الهرمي. هذا يعني أنه إذا تم حساب قيمة معينة مسبقًا، يمكن إعادة استخدامها دون الحاجة إلى إعادة الحساب.
· `type = DateTime`: يحدد هذا السمة نوع البيانات الذي تعمل عليه الدالة، وهو DateTime. هذا يعني أن الدالة مصممة للتعامل مع القيم الزمنية والتاريخية.

**وصف الكود (Code Description)**:
الفئة MYFUNC هي فئة فرعية من GenericFunction، مما يعني أنها توفر وظيفة عامة يمكن استخدامها في سياقات مختلفة. السمة `inherit_cache = True` تعني أن هذه الدالة تستفيد من التخزين المؤقت للقيم المحسوبة مسبقًا، مما يحسن الأداء عن طريق تجنب الحسابات المتكررة. السمة `type = DateTime` تشير إلى أن هذه الدالة مخصصة للتعامل مع البيانات من نوع DateTime، وهو نوع بيانات يستخدم لتمثيل التواريخ والأوقات.

**ملاحظة (Note)**:
عند استخدام هذه الدالة، تأكد من أن البيانات المدخلة تتوافق مع نوع DateTime. إذا تم إدخال نوع بيانات غير متوافق، فقد يؤدي ذلك إلى أخطاء في التشغيل. بالإضافة إلى ذلك، نظرًا لأن الدالة ترث القيم المخزنة مؤقتًا، تأكد من أن التخزين المؤقت يتم إدارته بشكل صحيح لتجنب أي تناقضات في البيانات.
***
***
### FunctionDef test_replace_function(self)
**test_replace_function**: وظيفة `test_replace_function` هي اختبار قدرة النظام على استبدال دالة مسجلة مسبقًا بدالة جديدة بنفس المعرف.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters).

**Code Description**: تقوم هذه الدالة باختبار عملية استبدال دالة مسجلة مسبقًا في النظام بدالة جديدة بنفس المعرف. يتم ذلك من خلال الخطوات التالية:

1. يتم تعريف دالة جديدة تسمى `replaceable_func` من خلال إنشاء فئة `replaceable_func` التي ترث من `GenericFunction`. يتم تعيين نوع الدالة إلى `Integer` ومعرفها إلى `"replaceable_func"`.

2. يتم التحقق من أن الدالة المسجلة مسبقًا (باستخدام المعرف `replaceable_func`) تعيد نوعًا من `Integer` عند استدعائها بأشكال مختلفة مثل `Replaceable_Func`، `RePlAcEaBlE_fUnC`، و `replaceable_func`.

3. يتم استبدال الدالة المسجلة مسبقًا بدالة جديدة بنفس المعرف `replaceable_func` ولكن بنوع `DateTime`. يتم ذلك من خلال تعريف فئة جديدة تسمى `replaceable_func_override` والتي ترث أيضًا من `GenericFunction`. يتم تعيين نوع الدالة الجديدة إلى `DateTime` مع الحفاظ على نفس المعرف `"replaceable_func"`.

4. يتم التحقق من أن الدالة الجديدة تعيد الآن نوعًا من `DateTime` عند استدعائها بنفس الأشكال السابقة (`Replaceable_Func`، `RePlAcEaBlE_fUnC`، و `replaceable_func`).

5. يتم استخدام `expect_warnings` للتعامل مع تحذير يتوقع أن يظهر عند استبدال الدالة المسجلة مسبقًا، حيث يتم إعلام المستخدم بأن الدالة `replaceable_func` مسجلة مسبقًا وسيتم استبدالها.

**Note**: 
- يجب الانتباه إلى أن استبدال دالة مسجلة مسبقًا قد يؤدي إلى تغيير في سلوك النظام، خاصة إذا كانت الدالة تستخدم في أجزاء أخرى من الكود.
- يتم استخدام `expect_warnings` للتعامل مع التحذيرات المتوقعة، مما يضمن أن الاختبار لا يفشل بسبب ظهور تحذيرات طبيعية أثناء تنفيذ الكود.
#### ClassDef replaceable_func
**replaceable_func**: وظيفة replaceable_func هي توفير دالة قابلة للاستبدال (replaceable function) ضمن سياق البرمجة الوظيفية.

**attributes**: السمات الخاصة بهذا الكلاس.
· type: يحدد نوع البيانات التي تعمل عليها الدالة، وفي هذه الحالة هو Integer (عدد صحيح).
· identifier: يُعرِّف اسم الدالة القابلة للاستبدال، وهو هنا "replaceable_func".

**Code Description**:  
يُعرِّف الكلاس replaceable_func دالة قابلة للاستبدال ضمن إطار عمل GenericFunction. هذا يعني أن الدالة يمكن استبدالها أو تعديلها حسب الحاجة في سياق البرنامج. الكلاس يحتوي على سمتين رئيسيتين:  
1. **type**: يحدد نوع البيانات التي تعمل عليها الدالة، وهو هنا Integer، مما يعني أن الدالة مصممة للتعامل مع الأعداد الصحيحة.  
2. **identifier**: يُعرِّف اسم الدالة القابلة للاستبدال، وهو هنا "replaceable_func". هذا الاسم يُستخدم للتعرف على الدالة عند استدعائها أو استبدالها.  

يُستخدم هذا الكلاس عادةً في سياقات البرمجة الوظيفية حيث تكون هناك حاجة لتوفير ديناميكية في استبدال الدوال أو تعديلها دون الحاجة لتغيير البنية الأساسية للبرنامج.

**Note**:  
- يجب التأكد من أن نوع البيانات (type) يتوافق مع السياق الذي تُستخدم فيه الدالة.  
- يُفضل استخدام الـ identifier بشكل واضح وفريد لتجنب أي تعارض مع دوال أخرى في البرنامج.  
- هذا الكلاس يعتمد على إطار عمل GenericFunction، لذا يجب التأكد من توافق البيئة البرمجية مع هذا الإطار قبل استخدامه.
***
#### ClassDef replaceable_func_override
**replaceable_func_override**: وظيفة الفئة `replaceable_func_override` هي توفير وظيفة قابلة للاستبدال (replaceable function) من خلال توسيع الفئة `GenericFunction` وتحديد نوع البيانات `DateTime` ومعرف الوظيفة.

**attributes**: السمات الخاصة بهذه الفئة.
· `type`: يحدد نوع البيانات الذي تعمل عليه الوظيفة، وهو في هذه الحالة `DateTime`.
· `identifier`: يحدد المعرف الخاص بالوظيفة القابلة للاستبدال، وهو هنا `"replaceable_func"`.

**Code Description**: 
الفئة `replaceable_func_override` هي فئة ترث من الفئة `GenericFunction`، مما يعني أنها توفر إطارًا عامًا لإنشاء وظائف قابلة للتخصيص والاستبدال. يتم تحديد نوع البيانات الذي تعمل عليه هذه الوظيفة من خلال السمة `type`، والتي تم تعيينها إلى `DateTime`. بالإضافة إلى ذلك، يتم تحديد معرف الوظيفة من خلال السمة `identifier`، والتي تم تعيينها إلى `"replaceable_func"`. هذا يعني أن هذه الفئة توفر وظيفة قابلة للاستبدال تعمل على بيانات من نوع `DateTime` ويمكن التعرف عليها من خلال المعرف `"replaceable_func"`.

**Note**: 
- عند استخدام هذه الفئة، يجب التأكد من أن نوع البيانات `DateTime` متوافق مع الوظيفة المطلوبة.
- يمكن استبدال هذه الوظيفة أو توسيعها حسب الحاجة في المشروع، وذلك بفضل وراثتها من `GenericFunction`.
***
***
### FunctionDef test_replace_function_case_insensitive(self)
**test_replace_function_case_insensitive**: وظيفة `test_replace_function_case_insensitive` هي اختبار قدرة النظام على التعامل مع استبدال الدوال العاملة (Generic Functions) بشكل غير حساس لحالة الأحرف (case-insensitive).  
**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters).  
**Code Description**:  
تقوم هذه الدالة باختبار آلية استبدال الدوال العاملة (Generic Functions) في النظام، مع التأكد من أن النظام يتعامل مع أسماء الدوال بشكل غير حساس لحالة الأحرف (case-insensitive). يتم ذلك من خلال الخطوات التالية:  

1. يتم تعريف دالة عاملة (Generic Function) جديدة باسم `replaceable_func` مع تحديد نوعها كـ `Integer`.  
2. يتم التحقق من أن الدوال `Replaceable_Func`، `RePlAcEaBlE_fUnC`، و `replaceable_func` تُرجع جميعها نوع `Integer`، مما يؤكد أن النظام يتعامل مع أسماء الدوال بشكل غير حساس لحالة الأحرف.  
3. يتم إعادة تعريف الدالة `replaceable_func` مع تغيير نوعها إلى `DateTime`، مع إظهار تحذير يشير إلى أن الدالة تم تسجيلها مسبقًا وسيتم استبدالها.  
4. يتم التحقق مرة أخرى من أن الدوال `Replaceable_Func`، `RePlAcEaBlE_fUnC`، و `replaceable_func` تُرجع الآن نوع `DateTime`، مما يؤكد نجاح عملية الاستبدال بشكل غير حساس لحالة الأحرف.  

**Note**:  
- يُظهر هذا الاختبار أهمية التعامل مع أسماء الدوال بشكل غير حساس لحالة الأحرف في الأنظمة التي تدعم استبدال الدوال العاملة.  
- يجب الانتباه إلى أن إعادة تعريف الدوال العاملة قد يؤدي إلى ظهور تحذيرات، خاصة إذا تم تسجيل الدالة مسبقًا.
#### ClassDef replaceable_func
**replaceable_func**: وظيفة replaceable_func هي توفير دالة عامة يمكن استبدالها أو تعديلها بسهولة في سياق البرمجة.

**attributes**: السمات الخاصة بهذا الكلاس.
· type: يحدد نوع البيانات التي تعمل عليها الدالة، وفي هذه الحالة هو Integer (عدد صحيح).
· identifier: يُستخدم لتحديد الدالة بشكل فريد، وفي هذه الحالة القيمة هي "replaceable_func".

**Code Description**:  
يُعتبر هذا الكلاس امتدادًا للكلاس `GenericFunction`، مما يعني أنه يوفر وظيفة عامة يمكن استخدامها في سياقات مختلفة. يتم تحديد نوع البيانات التي تعمل عليها الدالة من خلال السمة `type`، والتي تم تعيينها إلى `Integer`، مما يشير إلى أن هذه الدالة مصممة للعمل مع الأعداد الصحيحة. بالإضافة إلى ذلك، تحتوي الدالة على سمة `identifier`، والتي تُستخدم لتحديد الدالة بشكل فريد في النظام. قيمة هذه السمة هي "replaceable_func"، مما يعني أن هذه الدالة يمكن التعرف عليها واستبدالها بسهولة في أي جزء من الكود.

**Note**:  
عند استخدام هذا الكلاس، تأكد من أن نوع البيانات التي يتم تمريرها إلى الدالة يتوافق مع القيمة المحددة في السمة `type` (أي `Integer`). أيضًا، يمكن استخدام السمة `identifier` للتعرف على الدالة أو تعديلها في حالات معينة، لذا يُنصح بعدم تغيير هذه القيمة إلا إذا كان هناك سبب واضح لفعل ذلك.
***
#### ClassDef replaceable_func_override
**replaceable_func_override**: وظيفة الفئة `replaceable_func_override` هي توفير وظيفة قابلة للاستبدال (replaceable function) مع تحديد نوع البيانات المرتبطة بها.  
**attributes**: السمات الخاصة بهذه الفئة.  
· `type`: يحدد نوع البيانات المرتبطة بالوظيفة، وفي هذه الحالة هو `DateTime`.  
· `identifier`: يحدد المعرف الخاص بالوظيفة، وهو هنا `"REPLACEABLE_Func"`.  

**Code Description**:  
الفئة `replaceable_func_override` هي فئة فرعية (subclass) من الفئة `GenericFunction`. يتم استخدامها لإنشاء وظيفة قابلة للاستبدال مع تحديد نوع البيانات المرتبطة بها. في هذه الحالة، يتم تعيين نوع البيانات إلى `DateTime`، مما يشير إلى أن هذه الوظيفة مرتبطة ببيانات من نوع التاريخ والوقت. بالإضافة إلى ذلك، يتم تعيين معرف الوظيفة (identifier) إلى القيمة `"REPLACEABLE_Func"`، والذي يمكن استخدامه للتعرف على هذه الوظيفة بشكل فريد في السياق الذي يتم استخدامها فيه.  

**Note**:  
- يجب التأكد من أن نوع البيانات `DateTime` متوافق مع السياق الذي يتم استخدام الوظيفة فيه.  
- يمكن استخدام المعرف `"REPLACEABLE_Func"` للوصول إلى هذه الوظيفة أو استبدالها في حالات معينة.  
- هذه الفئة تعتمد على الفئة الأم `GenericFunction`، لذا يجب التأكد من فهم كيفية عمل الفئة الأم قبل استخدام هذه الفئة.
***
***
### FunctionDef test_custom_w_custom_name(self)
**test_custom_w_custom_name**: وظيفة `test_custom_w_custom_name` هي اختبار إنشاء دالة مخصصة مع اسم مخصص والتحقق من صحة إنشائها واستخدامها.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث إنها دالة اختبارية تعتمد على فئة داخلية محددة.

**Code Description**:  
تقوم هذه الدالة باختبار إنشاء دالة مخصصة باستخدام فئة `myfunc` التي ترث من `GenericFunction`. يتم تعيين خاصية `inherit_cache` إلى `True` مما يعني أن هذه الدالة ستستخدم التخزين المؤقت الموروث. بالإضافة إلى ذلك، يتم تعيين خاصية `name` إلى القيمة `"notmyfunc"`، مما يعني أن اسم الدالة سيكون `notmyfunc` بدلاً من اسم الفئة `myfunc`.

بعد ذلك، يتم التحقق من صحة إنشاء الدالة باستخدام `assert`. يتم التحقق من أن استدعاء `func.notmyfunc()` يعيد كائنًا من نوع `myfunc`، بينما يتم التحقق من أن استدعاء `func.myfunc()` لا يعيد كائنًا من هذا النوع. هذا الاختبار يضمن أن الدالة المخصصة تم إنشاؤها بشكل صحيح وأن الاسم المخصص يعمل كما هو متوقع.

**Note**:  
- يجب التأكد من أن الفئة `GenericFunction` متوفرة ومهيأة بشكل صحيح قبل استخدام هذا الاختبار.  
- هذا الاختبار يعتمد على تعريف فئة داخلية (`myfunc`)، لذا يجب فهم كيفية عمل الفئات والدوال المخصصة في هذا السياق.  
- خاصية `inherit_cache` تؤثر على سلوك التخزين المؤقت للدالة، لذا يجب مراعاة ذلك عند استخدامها في سياقات أخرى.
#### ClassDef myfunc
**myfunc**: وظيفة myfunc هي توفير وظيفة مخصصة (custom function) يمكن استخدامها في سياقات مختلفة ضمن المشروع.

**attributes**: السمات الخاصة بهذا الكلاس.
· inherit_cache: هذه السمة تُحدد ما إذا كان الكلاس سيورث ذاكرة التخزين المؤقت (cache) من الكلاس الأب. في هذه الحالة، القيمة `True` تعني أن الكلاس سيستخدم ذاكرة التخزين المؤقت الموروثة.
· name: هذه السمة تُحدد اسم الوظيفة. في هذه الحالة، القيمة `"notmyfunc"` تعني أن اسم الوظيفة سيكون `"notmyfunc"` بدلاً من اسم الكلاس نفسه (`myfunc`).

**Code Description**: هذا الكلاس `myfunc` هو عبارة عن وظيفة مخصصة (custom function) ترث من الكلاس `GenericFunction`. يتميز هذا الكلاس بسمتين رئيسيتين:
1. `inherit_cache`: يتم تعيين هذه السمة إلى `True`، مما يعني أن الكلاس سيستخدم ذاكرة التخزين المؤقت الموروثة من الكلاس الأب. هذا يمكن أن يحسن الأداء عن طريق تجنب إعادة الحسابات غير الضرورية.
2. `name`: يتم تعيين هذه السمة إلى `"notmyfunc"`، مما يعني أن اسم الوظيفة سيكون `"notmyfunc"` بدلاً من اسم الكلاس نفسه (`myfunc`). هذا يمكن أن يكون مفيدًا في الحالات التي تحتاج فيها إلى تسمية الوظيفة بشكل مختلف عن اسم الكلاس لأسباب تتعلق بالتوافق أو التنظيم.

**Note**: عند استخدام هذا الكلاس، يجب الانتباه إلى أن اسم الوظيفة الفعلي سيكون `"notmyfunc"` وليس `myfunc`. بالإضافة إلى ذلك، نظرًا لأن `inherit_cache` مُعيّن إلى `True`، فإن الكلاس سيستخدم ذاكرة التخزين المؤقت الموروثة، مما قد يؤثر على الأداء في حالات معينة.
***
***
### FunctionDef test_custom_w_quoted_name(self)
**test_custom_w_quoted_name**: وظيفة `test_custom_w_quoted_name` هي اختبار إنشاء دالة مخصصة مع اسم مقتبس (quoted name) والتأكد من أنها تُترجم بشكل صحيح.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) لأنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى الكائن الحالي.

**Code Description**: 
- تقوم الدالة بإنشاء دالة مخصصة (custom function) باستخدام فئة `GenericFunction`. يتم تعيين خاصية `inherit_cache` إلى `True` مما يعني أن النتائج المؤقتة (cache) لهذه الدالة ستُورث من الدوال الأخرى.
- يتم تعيين خاصية `name` باستخدام الدالة `quoted_name` مع القيمة `"NotMyFunc"` والخيار `quote=True`، مما يعني أن الاسم سيتم اقتباسه (quoted) عند استخدامه. هذا مفيد عندما يكون الاسم يحتوي على أحرف خاصة أو عندما تريد التأكد من أن الاسم يُستخدم حرفيًا كما هو.
- يتم تعيين `identifier` إلى `"myfunc"`، وهو المعرف الذي سيتم استخدامه للإشارة إلى هذه الدالة.
- أخيرًا، يتم استخدام `self.assert_compile` للتحقق من أن الترجمة (compilation) للدالة `func.myfunc()` تُنتج النص `'"NotMyFunc"()'`. هذا يعني أن الدالة تُرجمت بشكل صحيح مع الاسم المقتبس.

**Note**: 
- يُستخدم `quoted_name` عندما تريد التأكد من أن الاسم يُستخدم حرفيًا في الاستعلامات أو الأوامر، خاصةً عندما يحتوي الاسم على أحرف خاصة أو عندما تريد تجنب أي تفسير خاطئ من قبل النظام.
- يجب التأكد من أن `GenericFunction` و `func` تم استيرادهم بشكل صحيح في الكود قبل استخدام هذه الدالة.
#### ClassDef myfunc
**myfunc**: وظيفة myfunc هي توفير وظيفة مخصصة (custom function) يمكن استخدامها في سياق قاعدة البيانات أو الاستعلامات، مع تحديد اسم مخصص لها.

**attributes**: السمات الخاصة بهذا الكلاس.
· `inherit_cache`: هذه السمة تحدد ما إذا كان سيتم توريث ذاكرة التخزين المؤقت (cache) من الكلاس الأصلي أم لا. في هذه الحالة، القيمة `True` تعني أن الذاكرة المؤقتة سيتم توريثها.
· `name`: هذه السمة تحدد الاسم الذي سيتم استخدامه للدالة في قاعدة البيانات. هنا، يتم استخدام `quoted_name("NotMyFunc", quote=True)`، مما يعني أن الاسم سيكون `"NotMyFunc"` مع إضافة علامات اقتباس حوله لضمان استخدامه حرفيًا.
· `identifier`: هذه السمة تحدد المعرف (identifier) للدالة، والذي يستخدم للتعرف عليها داخل النظام. هنا، القيمة هي `"myfunc"`.

**Code Description**: هذا الكلاس `myfunc` هو امتداد للكلاس `GenericFunction`، مما يعني أنه يوفر وظيفة مخصصة يمكن استخدامها في سياق قاعدة البيانات. يتم تحديد اسم الدالة باستخدام `quoted_name`، مما يضمن أن الاسم `"NotMyFunc"` سيتم استخدامه حرفيًا مع إضافة علامات اقتباس حوله. هذا مفيد في الحالات التي تحتاج فيها إلى استخدام أسماء محددة أو محجوزة في قاعدة البيانات. بالإضافة إلى ذلك، يتم تعيين `inherit_cache` إلى `True`، مما يعني أن الذاكرة المؤقتة للدالة سيتم توريثها من الكلاس الأصلي، مما قد يحسن الأداء في بعض الحالات.

**Note**: عند استخدام هذا الكلاس، تأكد من أن الاسم المحدد في `name` لا يتعارض مع أسماء أخرى في قاعدة البيانات. أيضًا، يجب مراعاة أن استخدام `quoted_name` مع `quote=True` يعني أن الاسم سيتم استخدامه حرفيًا، مما قد يؤثر على التوافق مع بعض أنظمة قواعد البيانات إذا لم يتم دعم هذا النوع من الأسماء.
***
***
### FunctionDef test_custom_w_quoted_name_no_identifier(self)
**test_custom_w_quoted_name_no_identifier**: وظيفة `test_custom_w_quoted_name_no_identifier` هي اختبار لإنشاء دالة مخصصة باستخدام اسم مقتبس (quoted name) بدون معرف (identifier) والتحقق من صحة الترجمة (compilation) لهذه الدالة.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذها داخل سياق الكلاس الحالي (self).

**Code Description**:  
تقوم هذه الدالة بإنشاء دالة مخصصة (custom function) باستخدام الكلاس `GenericFunction`. يتم تعريف الكلاس `myfunc` داخل الدالة، حيث يتم تعيين خاصية `inherit_cache` إلى `True`، مما يشير إلى أن هذه الدالة ستستخدم التخزين المؤقت للنتائج. بالإضافة إلى ذلك، يتم تعيين خاصية `name` باستخدام الدالة `quoted_name`، حيث يتم تمرير الاسم `"NotMyFunc"` مع تعيين `quote=True`، مما يعني أن الاسم سيتم استخدامه كما هو مع علامات الاقتباس.

بعد ذلك، يتم استخدام الدالة `func.notmyfunc()` للتحقق من صحة الترجمة (compilation) للدالة المخصصة. يتم استخدام `self.assert_compile` للتحقق من أن الناتج المترجم للدالة `func.notmyfunc()` يتطابق مع النص `'"NotMyFunc"()'`. هذا الاختبار يضمن أن الدالة المخصصة يتم ترجمتها بشكل صحيح مع الاسم المقتبس.

**Note**:  
- يجب أن يكون الاسم المقتبس (quoted name) مكتوبًا بأحرف صغيرة (lowercase) للبحث الصحيح (lookup) في الدالة `func.notmyfunc()`.
- هذا الاختبار يهدف إلى التأكد من أن الدوال المخصصة التي تستخدم أسماء مقتبسة يتم ترجمتها بشكل صحيح، حتى في حالة عدم وجود معرف (identifier) مباشر.
#### ClassDef myfunc
**myfunc**: وظيفة myfunc هي توفير دالة عامة (GenericFunction) مع اسم مخصص يتم اقتباسه.

**attributes**: السمات الخاصة بهذا الكلاس.
· inherit_cache: يتم تعيين هذه السمة على `True`، مما يعني أن النتائج المحسوبة مسبقًا للدالة سيتم تخزينها في ذاكرة التخزين المؤقت (cache) لتحسين الأداء عند استدعاء الدالة مرة أخرى بنفس المدخلات.
· name: يتم تعيين هذه السمة باستخدام الدالة `quoted_name` مع القيمة `"NotMyFunc"` والخيار `quote=True`، مما يعني أن اسم الدالة سيتم اقتباسه بشكل صريح في الاستعلامات. هذا مفيد عندما يكون الاسم يحتوي على أحرف خاصة أو عندما تريد التأكد من أن الاسم يتم تفسيره حرفيًا من قبل قاعدة البيانات.

**Code Description**: هذا الكلاس `myfunc` هو امتداد للكلاس `GenericFunction`، والذي يُستخدم عادةً لإنشاء دوال قابلة لإعادة الاستخدام في أنظمة قواعد البيانات. يتم تعيين سمة `inherit_cache` على `True`، مما يسمح بتخزين النتائج المحسوبة مسبقًا للدالة في ذاكرة التخزين المؤقت لتحسين الأداء. بالإضافة إلى ذلك، يتم تعيين اسم الدالة باستخدام `quoted_name` مع القيمة `"NotMyFunc"` والخيار `quote=True`، مما يضمن أن اسم الدالة سيتم اقتباسه بشكل صريح في الاستعلامات. هذا مفيد بشكل خاص عند العمل مع أسماء دوال تحتوي على أحرف خاصة أو عندما تريد التأكد من أن الاسم يتم تفسيره حرفيًا من قبل قاعدة البيانات.

**Note**: عند استخدام هذا الكلاس، تأكد من أن الاسم المخصص للدالة (`"NotMyFunc"`) يتوافق مع قواعد تسمية الدوال في قاعدة البيانات التي تعمل معها. أيضًا، تأكد من أن استخدام `quote=True` مناسب لاحتياجاتك، حيث أنه سيؤدي إلى اقتباس الاسم بشكل صريح في الاستعلامات.
***
***
### FunctionDef test_custom_package_namespace(self)
**test_custom_package_namespace**: وظيفة `test_custom_package_namespace` هي اختبار قدرة الكود على إنشاء دوال ذات مساحات أسماء (namespaces) مخصصة بناءً على اسم الحزمة (package) المحدد.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) خارجية، حيث يتم تنفيذ كل العمليات داخلها.

**Code Description**: 
- تقوم الوظيفة بتعريف دالة داخلية تسمى `cls1` تقبل معاملًا واحدًا هو `pk_name`، والذي يمثل اسم الحزمة المخصصة.
- داخل `cls1`، يتم تعريف كلاس `myfunc` الذي يرث من `GenericFunction`. يتم تعيين خاصية `inherit_cache` إلى `True`، مما يعني أن الكلاس سيستخدم التخزين المؤقت للوراثة. كما يتم تعيين خاصية `package` إلى قيمة `pk_name` التي تم تمريرها.
- تقوم `cls1` بإرجاع الكلاس `myfunc` الذي تم تعريفه.
- بعد ذلك، يتم استدعاء `cls1` مرتين مع قيم مختلفة لـ `pk_name`، الأولى بـ `"mypackage"` والثانية بـ `"myotherpackage"`. يتم تخزين النتائج في المتغيرات `f1` و `f2` على التوالي.
- يتم استخدام `assert` للتحقق من أن الكائنات التي تم إنشاؤها بواسطة `func.mypackage.myfunc()` و `func.myotherpackage.myfunc()` هي نسخ من `f1` و `f2` على التوالي.

**Note**: 
- هذه الوظيفة تعتمد على وجود كائن `func` ووظيفة `GenericFunction` في السياق الذي يتم تنفيذها فيه. يجب التأكد من توفر هذه العناصر قبل استخدام الوظيفة.
- الوظيفة مصممة للاختبار، لذا يجب استخدامها في سياق اختباري وليس في الكود الإنتاجي.

**Output Example**: 
لا تحتوي هذه الوظيفة على قيمة إرجاع (return value) مباشرة، ولكنها تستخدم `assert` للتحقق من صحة الشروط. إذا كانت الشروط صحيحة، فإن الوظيفة تستمر دون أخطاء. إذا لم تكن الشروط صحيحة، فإنها ترفع استثناء (exception) يشير إلى فشل الاختبار.
#### FunctionDef cls1(pk_name)
**cls1**: وظيفة `cls1` هي إنشاء وإرجاع فئة دالة مخصصة (`myfunc`) التي ترث من `GenericFunction` مع تعيين حزمة (`package`) محددة.

**parameters**: معاملات هذه الوظيفة.
· `pk_name`: معامل إلزامي من نوع `str` يمثل اسم الحزمة (`package`) التي سيتم تعيينها للفئة المخصصة (`myfunc`).

**Code Description**: 
تقوم الوظيفة `cls1` بإنشاء فئة مخصصة تسمى `myfunc` والتي ترث من `GenericFunction`. تحتوي الفئة المخصصة على خاصيتين:
1. `inherit_cache`: يتم تعيينها إلى `True`، مما يشير إلى أن الفئة ستستخدم التخزين المؤقت للوراثة.
2. `package`: يتم تعيينها إلى قيمة المعامل `pk_name` الذي يتم تمريره إلى الوظيفة `cls1`. هذه الخاصية تحدد الحزمة التي تنتمي إليها الفئة المخصصة.

بعد إنشاء الفئة `myfunc`، تقوم الوظيفة بإرجاع هذه الفئة كقيمة مرجعية.

**Note**: 
- يجب أن يكون المعامل `pk_name` من نوع `str` لأنه يمثل اسم الحزمة.
- الفئة المخصصة `myfunc` ترث من `GenericFunction`، لذا يجب أن تكون `GenericFunction` متاحة في السياق الذي يتم فيه استخدام هذه الوظيفة.

**Output Example**: 
عند استدعاء الوظيفة `cls1` بالمعامل `pk_name="my_package"`، سيكون الإرجاع كالتالي:
```python
<class '__main__.myfunc'>
```
حيث تكون الفئة `myfunc` معينة الحزمة إلى `"my_package"`.
##### ClassDef myfunc
**myfunc**: وظيفة myfunc هي توفير وظيفة عامة (GenericFunction) مع إمكانية توريث الذاكرة المؤقتة (cache) وتحديد حزمة (package) معينة.

**attributes**: السمات الخاصة بهذا الكلاس.
· `inherit_cache`: هذه السمة تحدد ما إذا كان يمكن توريث الذاكرة المؤقتة (cache) من الوظائف الأم. القيمة `True` تعني أن الذاكرة المؤقتة يمكن توريثها.
· `package`: هذه السمة تحدد اسم الحزمة (package) التي تنتمي إليها هذه الوظيفة. القيمة `pk_name` تشير إلى اسم الحزمة المحدد.

**Code Description**: هذا الكلاس `myfunc` هو عبارة عن وظيفة عامة (GenericFunction) تم توسيعها لتدعم توريث الذاكرة المؤقتة (cache) من خلال تعيين `inherit_cache` إلى `True`. بالإضافة إلى ذلك، يتم تحديد الحزمة (package) التي تنتمي إليها هذه الوظيفة من خلال السمة `package`، حيث يتم تعيينها إلى `pk_name`. هذا يعني أن الوظيفة مرتبطة بحزمة معينة، مما قد يؤثر على كيفية استخدامها أو استدعائها في السياق العام للبرنامج.

**Note**: عند استخدام هذا الكلاس، تأكد من أن قيمة `pk_name` تمثل اسم الحزمة الصحيح الذي تريد ربط الوظيفة به. أيضًا، إذا كنت بحاجة إلى تعطيل توريث الذاكرة المؤقتة، قم بتعيين `inherit_cache` إلى `False`.
***
***
***
### FunctionDef test_custom_name(self)
**test_custom_name**: وظيفة `test_custom_name` هي اختبار وظيفة مخصصة تم تعريفها داخل الكلاس `MyFunction` للتأكد من أنها تُترجم بشكل صحيح إلى صيغة SQL.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) خارجية، حيث يتم تنفيذ كل العمليات داخلها.

**Code Description**: 
- تقوم الوظيفة `test_custom_name` بتعريف كلاس داخلي باسم `MyFunction` الذي يرث من `GenericFunction`. يحتوي هذا الكلاس على خاصية `name` بقيمة `"my_func"`، مما يعني أن اسم الوظيفة في SQL سيكون `my_func`. بالإضافة إلى ذلك، يتم تعيين `inherit_cache` إلى `True`، مما يشير إلى أن النتائج المؤقتة لهذه الوظيفة يمكن أن تُورث.
- داخل دالة `__init__`، يتم تعديل المعاملات الممررة بإضافة القيمة `3` إليها، ثم يتم استدعاء الدالة الأصلية `__init__` باستخدام المعاملات المعدلة.
- بعد ذلك، يتم استخدام `self.assert_compile` لاختبار ما إذا كانت الوظيفة `my_func` تُترجم بشكل صحيح إلى صيغة SQL. يتم تمرير المعاملات `1` و `2` إلى الوظيفة، ويتم التحقق من أن النتيجة المترجمة هي `"my_func(:my_func_1, :my_func_2, :my_func_3)"`.

**Note**: 
- يجب التأكد من أن الكلاس `GenericFunction` والدالة `assert_compile` تم تعريفهما بشكل صحيح في السياق العام للكود، حيث أن هذه الوظيفة تعتمد عليهما.
- يتم استخدام `inherit_cache` لتحسين الأداء عن طريق توريث النتائج المؤقتة، لذا يجب التأكد من أن هذا السلوك مطلوب في السياق الذي يتم استخدام الوظيفة فيه.
#### ClassDef MyFunction
**MyFunction**: وظيفة MyFunction هي توسيع وظيفة GenericFunction بإضافة قيمة ثابتة إلى الوسائط الممررة عند إنشاء الكائن.

**attributes**: السمات الخاصة بهذا الكلاس.
· name: اسم الوظيفة، وهو "my_func" بشكل ثابت.
· inherit_cache: قيمة منطقية (True) تشير إلى أن الكلاس يرث ذاكرة التخزين المؤقت من الكلاس الأصلي.

**Code Description**: وصف هذا الكلاس.
- الكلاس MyFunction يرث من الكلاس GenericFunction، مما يعني أنه يستفيد من الوظائف والسمات المحددة في الكلاس الأصلي.
- عند إنشاء كائن من هذا الكلاس، يتم استدعاء الدالة `__init__`، والتي تقوم بإضافة القيمة `3` إلى نهاية الوسائط الممررة (`args`) قبل تمريرها إلى الكلاس الأصلي عبر `super().__init__`.
- السمة `name` محددة مسبقًا بقيمة "my_func"، مما يعني أن اسم الوظيفة ثابت ولا يتغير.
- السمة `inherit_cache` محددة بقيمة `True`، مما يشير إلى أن الكلاس يستخدم ذاكرة التخزين المؤقت الموروثة من الكلاس الأصلي.

**Note**: ملاحظات حول استخدام الكود.
- عند استخدام هذا الكلاس، يجب التأكد من أن الوسائط الممررة متوافقة مع الكلاس الأصلي GenericFunction، حيث يتم تعديلها بإضافة القيمة `3` قبل التمرير.
- السمة `inherit_cache` تعني أن الكلاس يستفيد من ذاكرة التخزين المؤقت الموروثة، مما قد يؤثر على الأداء إذا كانت الوظيفة تستدعي عمليات مكلفة.
##### FunctionDef __init__(self)
**__init__**: وظيفة `__init__` هي تهيئة الكائن وإعداد القيم الأولية له.

**parameters**: معاملات هذه الوظيفة.
· `*args`: معامل متغير الطول (variable-length argument) يستقبل أي عدد من القيم كـ tuple.

**Code Description**: 
تقوم هذه الوظيفة بتهيئة الكائن عن طريق تعديل القيم التي يتم تمريرها إليه. أولاً، يتم إضافة القيمة `3` إلى نهاية الـ `args` التي تم تمريرها كمعاملات. بعد ذلك، يتم استدعاء الوظيفة `__init__` من الكلاس الأب (superclass) باستخدام القيم المعدلة (`args` بعد إضافة `3`). هذا يعني أن الكائن سيتم تهيئته باستخدام القيم الأصلية بالإضافة إلى القيمة `3`.

**Note**: 
- يجب أن يكون الكلاس الأب (superclass) قادرًا على استقبال المعاملات التي يتم تمريرها إليه بعد التعديل.
- هذه الوظيفة تعتمد على مفهوم الوراثة (inheritance)، لذا يجب أن يكون الكلاس الحالي (current class) مشتقًا من كلاس آخر.
***
***
***
### FunctionDef test_custom_registered_identifier(self)
**test_custom_registered_identifier**: وظيفة `test_custom_registered_identifier` هي اختبار تسجيل المعرفات المخصصة للوظائف العامة (GenericFunctions) والتأكد من أنها تُترجم بشكل صحيح إلى استعلامات SQL.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) حيث إنها جزء من فئة اختبار (test class) وتستخدم فقط للتحقق من السلوك المتوقع.

**Code Description**: تقوم هذه الوظيفة بإنشاء عدة فئات فرعية من `GenericFunction`، كل منها يمثل وظيفة عامة (generic function) مع معرف (identifier) مخصص. يتم تعريف كل فئة بالخصائص التالية:
- `type`: يحدد نوع البيانات التي تُرجعها الوظيفة، وفي هذه الحالة يكون `Integer`.
- `package`: (اختياري) يحدد الحزمة التي تنتمي إليها الوظيفة، كما في حالة `GeoBuffer` حيث تم تعيينها إلى `"geo"`.
- `name`: يحدد اسم الوظيفة الذي سيظهر في استعلام SQL.
- `identifier`: يحدد المعرف الذي سيُستخدم لاستدعاء الوظيفة في الكود.
- `inherit_cache`: يحدد ما إذا كانت الوظيفة ستورث ذاكرة التخزين المؤقت (cache) من الوظائف الأخرى.

بعد إنشاء الفئات، يتم استخدام `self.assert_compile` للتحقق من أن استدعاء الوظائف باستخدام المعرفات المخصصة يُترجم بشكل صحيح إلى الأسماء المحددة في استعلام SQL. على سبيل المثال:
- `func.geo.buf1()` يجب أن تُترجم إلى `"BufferOne()"`.
- `func.buf2()` يجب أن تُترجم إلى `"BufferTwo()"`.
- `func.buf3()` يجب أن تُترجم إلى `"BufferThree()"`.
- `func.Buf4()` (أو أي متغيرات أخرى مثل `func.BuF4()` أو `func.bUf4()`) يجب أن تُترجم إلى `"BufferFour()"`.

**Note**: 
- يجب التأكد من أن المعرفات (identifiers) تُكتب بشكل صحيح عند استدعاء الوظائف، حيث إنها غير حساسة لحالة الأحرف (case-insensitive) ولكن يجب أن تتطابق مع المعرفات المحددة في الفئات.
- هذه الوظيفة تُستخدم بشكل أساسي في اختبارات الوحدة (unit tests) للتحقق من صحة تسجيل الوظائف العامة وترجمتها إلى SQL.
#### ClassDef GeoBuffer
**GeoBuffer**: وظيفة GeoBuffer هي توفير دالة عامة (GenericFunction) خاصة بالعمليات الجغرافية، وتحديدًا لإنشاء منطقة عازلة (Buffer) حول كائن جغرافي.

**attributes**: السمات الخاصة بهذا الكلاس.
· type: يحدد نوع البيانات التي تُرجعها الدالة، وفي هذه الحالة هي Integer (عدد صحيح).
· package: يحدد الحزمة التي تنتمي إليها الدالة، وهي "geo" للإشارة إلى أنها متعلقة بالعمليات الجغرافية.
· name: يحدد اسم الدالة، وهو "BufferOne" للإشارة إلى أنها تنشئ منطقة عازلة واحدة.
· identifier: يحدد المعرف الخاص بالدالة، وهو "buf1" لتمييزها عن الدوال الأخرى.
· inherit_cache: يحدد ما إذا كانت الدالة ترث ذاكرة التخزين المؤقت (cache) من الدوال الأخرى، وفي هذه الحالة هي True، مما يعني أنها تستخدم التخزين المؤقت.

**Code Description**: هذا الكلاس يمثل دالة عامة (GenericFunction) تُستخدم في العمليات الجغرافية. يتم تحديد نوع البيانات التي تُرجعها الدالة كعدد صحيح (Integer) من خلال السمة type. تنتمي الدالة إلى حزمة "geo" كما هو محدد في السمة package، مما يشير إلى أنها مرتبطة بالعمليات الجغرافية. اسم الدالة هو "BufferOne" (المنطقة العازلة الواحدة)، ويتم تمييزها بواسطة المعرف "buf1" في السمة identifier. بالإضافة إلى ذلك، تم تعيين السمة inherit_cache إلى True، مما يعني أن هذه الدالة ستستخدم التخزين المؤقت الموروث من الدوال الأخرى لتحسين الأداء.

**Note**: عند استخدام هذا الكلاس، تأكد من أن العمليات الجغرافية التي تقوم بها متوافقة مع نوع البيانات Integer. أيضًا، يمكن الاستفادة من التخزين المؤقت لتحسين أداء الدالة في الحالات التي تتكرر فيها العمليات الجغرافية بشكل متكرر.
***
#### ClassDef GeoBuffer2
**GeoBuffer2**: وظيفة GeoBuffer2 هي توفير دالة عامة (GenericFunction) تُستخدم لتنفيذ عمليات محددة على البيانات الجغرافية، مع تحديد نوع الناتج كعدد صحيح (Integer).

**attributes**: السمات الخاصة بهذا الكلاس.
· type: يحدد نوع البيانات التي تُرجعها الدالة، وهو في هذه الحالة Integer (عدد صحيح).
· name: اسم الدالة، وهو هنا "BufferTwo".
· identifier: المعرف الخاص بالدالة، وهو هنا "buf2".
· inherit_cache: يحدد ما إذا كان يتم توريث ذاكرة التخزين المؤقت (cache) من الدوال الأم، وهو هنا True (نعم).

**Code Description**: وصف الكلاس.
يُعتبر GeoBuffer2 كلاسًا يرث من GenericFunction، مما يسمح له بتنفيذ عمليات عامة على البيانات. يتم تحديد نوع الناتج من خلال السمة type، والتي تم تعيينها إلى Integer، مما يعني أن الدالة ستُرجع دائمًا قيمًا عددية صحيحة. اسم الدالة محدد بـ "BufferTwo"، بينما المعرف الخاص بها هو "buf2"، والذي يمكن استخدامه للاستدعاء أو التعرف على الدالة في السياقات البرمجية. بالإضافة إلى ذلك، تم تعيين inherit_cache إلى True، مما يعني أن هذه الدالة ستستخدم ذاكرة التخزين المؤقت من الدوال الأم لتحسين الأداء.

**Note**: ملاحظات حول استخدام الكود.
- يجب التأكد من أن السياق الذي تُستخدم فيه هذه الدالة يدعم نوع الناتج Integer.
- يمكن استخدام المعرف "buf2" للوصول إلى هذه الدالة أو استدعائها في الأكواد الأخرى.
- يُفضل استخدام هذه الدالة في الحالات التي تتطلب عمليات جغرافية مع نتائج عددية صحيحة.
***
#### ClassDef BufferThree
**BufferThree**: وظيفة BufferThree هي توفير دالة عامة (GenericFunction) تعمل على معالجة الأعداد الصحيحة (Integer) باستخدام معرف مخصص (identifier) محدد.

**attributes**: السمات الخاصة بهذا الكلاس.
· type: يحدد نوع البيانات التي تعمل عليها الدالة، وفي هذه الحالة هو Integer (عدد صحيح).
· identifier: معرف مخصص للدالة، وهو هنا "buf3"، ويستخدم للتمييز بين الدوال الأخرى.
· inherit_cache: قيمة منطقية (Boolean) تحدد ما إذا كان سيتم توريث ذاكرة التخزين المؤقت (cache) من الدوال الأم، وهنا القيمة هي True مما يعني أن الذاكرة المؤقتة ستُورث.

**Code Description**: هذا الكلاس BufferThree هو امتداد للكلاس GenericFunction، ويُستخدم لإنشاء دالة عامة تعمل على الأعداد الصحيحة. يتم تحديد نوع البيانات التي تعمل عليها الدالة من خلال السمة type، والتي تم تعيينها إلى Integer. بالإضافة إلى ذلك، يتم استخدام معرف مخصص (identifier) وهو "buf3" لتمييز هذه الدالة عن غيرها من الدوال. السمة inherit_cache تم تعيينها إلى True، مما يعني أن هذه الدالة ستستخدم ذاكرة التخزين المؤقت التي يتم توريثها من الدوال الأم، مما قد يحسن الأداء في حالات معينة.

**Note**: عند استخدام هذا الكلاس، تأكد من أن المعرف (identifier) "buf3" فريد ولا يتعارض مع معرفات أخرى في النظام. أيضًا، يمكن الاستفادة من توريث الذاكرة المؤقتة (inherit_cache) لتحسين الأداء في التطبيقات التي تتطلب معالجة متكررة للبيانات.
***
#### ClassDef GeoBufferFour
**GeoBufferFour**: وظيفة GeoBufferFour هي توفير دالة عامة (GenericFunction) تُستخدم لتنفيذ عمليات محددة تتعلق بالبيانات الجغرافية، حيث تُرجع قيمة من نوع Integer.

**attributes**: السمات الخاصة بهذا الكلاس.
· type: يحدد نوع القيمة التي تُرجعها الدالة، وهو في هذه الحالة Integer.
· name: اسم الدالة، وهو "BufferFour".
· identifier: المعرف الخاص بالدالة، وهو "Buf4".
· inherit_cache: يُستخدم لتحديد ما إذا كان سيتم توريث ذاكرة التخزين المؤقت للدالة، وهو هنا مضبوط على True.

**Code Description**: هذا الكلاس يمثل دالة عامة (GenericFunction) تُستخدم في معالجة البيانات الجغرافية. الدالة تُرجع قيمة من نوع Integer، ويتم تحديد اسمها بواسطة السمة name والتي تحمل القيمة "BufferFour". بالإضافة إلى ذلك، يتم استخدام المعرف identifier لتسهيل التعرف على الدالة في السياقات البرمجية، وهو هنا "Buf4". السمة inherit_cache تُشير إلى أن الدالة ستستخدم ذاكرة التخزين المؤقت الموروثة، مما قد يحسن الأداء في حالات معينة.

**Note**: عند استخدام هذا الكلاس، تأكد من أن السياق البرمجي يدعم الدوال العامة (GenericFunction) وأن نوع البيانات المُدخلة يتوافق مع العمليات التي تقوم بها الدالة. أيضًا، يُفضل التحقق من أن استخدام ذاكرة التخزين المؤقت (cache) مناسب للسياق الذي تعمل فيه لتجنب أي مشاكل في الأداء.
***
***
### FunctionDef test_custom_args(self)
**test_custom_args**: وظيفة `test_custom_args` تهدف إلى اختبار عملية الترجمة (compile) لدالة مخصصة مع وسائط محددة.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) خارجية، حيث يتم تنفيذ كل العمليات داخلها.

**Code Description**:  
تقوم هذه الدالة بإنشاء فئة مخصصة تُسمى `myfunc` والتي ترث من `GenericFunction`. يتم تعيين الخاصية `inherit_cache` إلى `True`، مما يشير إلى أن هذه الفئة ستستخدم التخزين المؤقت للنتائج عند الوراثة. بعد ذلك، يتم استدعاء الدالة `assert_compile` والتي تتحقق من أن عملية الترجمة للدالة `myfunc` مع الوسائط `1, 2, 3` تُنتج النص المتوقع `"myfunc(:myfunc_1, :myfunc_2, :myfunc_3)"`.  

بشكل أكثر تفصيلًا:
1. يتم تعريف فئة `myfunc` داخليًا داخل الدالة `test_custom_args`.
2. يتم تعيين `inherit_cache` إلى `True` لتمكين التخزين المؤقت للنتائج.
3. يتم استدعاء `assert_compile` مع `myfunc(1, 2, 3)` كمدخل، ويتم التحقق من أن الناتج المترجم يتطابق مع النص المحدد.

**Note**:  
- هذه الدالة مخصصة للاختبار ولا تُستخدم في الإنتاج الفعلي.  
- يجب أن تكون الدالة `assert_compile` معرّفة بشكل صحيح في السياق الذي تعمل فيه هذه الدالة.  
- يُفضل فهم كيفية عمل `GenericFunction` و`inherit_cache` قبل تعديل أو توسيع هذه الدالة.
#### ClassDef myfunc
**myfunc**: وظيفة myfunc هي توفير وظيفة عامة (GenericFunction) مع إمكانية توريث الذاكرة المؤقتة (cache).

**attributes**: السمات الخاصة بهذا الكلاس.
· inherit_cache: هذه السمة تحدد ما إذا كان سيتم توريث الذاكرة المؤقتة (cache) من الوظائف الأم. القيمة الافتراضية هي `True`، مما يعني أن الذاكرة المؤقتة سيتم توريثها.

**Code Description**: وصف الكود.
- الكلاس `myfunc` هو عبارة عن وظيفة عامة (GenericFunction) والتي ترث من كلاس أساسي يُسمى `GenericFunction`. هذا الكلاس مصمم لتوفير وظيفة يمكن استخدامها في سياقات مختلفة مع إمكانية توريث الذاكرة المؤقتة.
- السمة `inherit_cache` تم تعيينها إلى `True`، مما يعني أن أي ذاكرة مؤقتة مرتبطة بالوظيفة الأم سيتم توريثها تلقائيًا. هذا يمكن أن يكون مفيدًا في تحسين الأداء عن طريق تجنب إعادة الحسابات غير الضرورية.

**Note**: ملاحظات حول استخدام الكود.
- عند استخدام هذا الكلاس، تأكد من فهمك لكيفية عمل الذاكرة المؤقتة (cache) وكيفية تأثير `inherit_cache` على سلوك الوظيفة.
- إذا كنت بحاجة إلى تعطيل توريث الذاكرة المؤقتة، يمكنك تغيير قيمة `inherit_cache` إلى `False`.
***
***
### FunctionDef test_namespacing_conflicts(self)
**test_namespacing_conflicts**: وظيفة `test_namespacing_conflicts` هي التحقق من عدم وجود تعارضات في تسمية الأسماء (namespacing) عند استخدام الدالة `text` من خلال التأكد من أن الناتج المترجم يتوافق مع التوقعات.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة يتم تمريرها إليها بشكل مباشر.

**Code Description**: تقوم هذه الدالة باختبار عملية الترجمة (compile) لدالة `text` عند تمرير النص `"foo"` إليها. يتم استخدام الدالة `assert_compile` للتحقق من أن الناتج المترجم من الدالة `text("foo")` يساوي القيمة المتوقعة `"text(:text_1)"`. هذا الاختبار يهدف إلى التأكد من أن نظام تسمية الأسماء (namespacing) يعمل بشكل صحيح ولا يسبب أي تعارضات عند استخدام الدالة `text`.

**Note**: يُفترض أن تكون الدالة `assert_compile` جزءًا من إطار اختبار (testing framework) يستخدم في هذا المشروع، وهي مسؤولة عن مقارنة الناتج الفعلي مع الناتج المتوقع. يجب التأكد من أن الدالة `text` تعمل بشكل صحيح وأنها تُرجع القيمة المتوقعة قبل تنفيذ هذا الاختبار.
***
### FunctionDef test_generic_count(self)
**test_generic_count**: وظيفة `test_generic_count` هي اختبار وظيفة `count` العامة للتأكد من أنها تعمل بشكل صحيح مع أنواع مختلفة من المدخلات.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة لأنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى مثيل الفئة الحالي.

**Code Description**: تقوم هذه الوظيفة باختبار وظيفة `count` العامة من خلال التأكد من عدة أمور:
1. التأكد من أن نوع القيمة المُرجعة من `func.count()` هو من نوع `sqltypes.Integer` باستخدام `assert isinstance`.
2. اختبار ترجمة (compile) استعلام `func.count()` بدون أي معاملات للتأكد من أنه يُترجم إلى `"count(*)"` باستخدام `self.assert_compile`.
3. اختبار ترجمة استعلام `func.count(1)` مع معامل رقمي للتأكد من أنه يُترجم إلى `"count(:count_1)"`.
4. اختبار ترجمة استعلام `func.count(c)` حيث `c` هو عمود (column) مُعرّف مسبقًا باستخدام `column("abc")`، للتأكد من أنه يُترجم إلى `"count(abc)"`.

**Note**: 
- هذه الوظيفة جزء من اختبارات وحدة (unit tests) تهدف إلى التأكد من أن وظيفة `count` تعمل بشكل صحيح في مختلف السيناريوهات.
- يتم استخدام `self.assert_compile` للتحقق من أن الاستعلامات تُترجم بشكل صحيح إلى صيغة SQL المطلوبة.
- يجب أن تكون على دراية بكيفية عمل `func.count` و `column` لفهم الاختبارات بشكل كامل.
***
### FunctionDef test_ansi_functions_with_args(self)
**test_ansi_functions_with_args**: وظيفة `test_ansi_functions_with_args` هي اختبار وظيفة `current_timestamp` مع تمرير وسيط (argument) والتحقق من صحة الترجمة (compilation) للناتج.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة يتم تمريرها إليها مباشرةً، حيث إنها تعتمد على الكائن الحالي (`self`) الذي يستدعيها.

**Code Description**: تقوم هذه الوظيفة باختبار سلوك وظيفة `current_timestamp` عند تمرير وسيط إليها. يتم ذلك من خلال الخطوات التالية:
1. يتم استدعاء وظيفة `current_timestamp` مع تمرير الوسيط `"somearg"`، ويتم تخزين الناتج في المتغير `ct`.
2. يتم استخدام طريقة `assert_compile` للتحقق من أن الناتج المخزن في `ct` يتطابق مع القيمة المتوقعة `"CURRENT_TIMESTAMP(:current_timestamp_1)"`.
3. الهدف من هذا الاختبار هو التأكد من أن وظيفة `current_timestamp` تعمل بشكل صحيح عند تمرير وسيط إليها، وأن الترجمة (compilation) للناتج تتم بشكل صحيح.

**Note**: 
- يجب التأكد من أن وظيفة `current_timestamp` تم تعريفها بشكل صحيح وأنها تقبل وسيطًا واحدًا على الأقل.
- يتم استخدام `assert_compile` للتحقق من صحة الترجمة، لذا يجب أن تكون هذه الطريقة متاحة ومحددة بشكل صحيح في الكائن الحالي (`self`).
***
### FunctionDef test_char_length_fixed_args(self)
**test_char_length_fixed_args**: وظيفة `test_char_length_fixed_args` هي اختبار وظيفة `char_length` للتأكد من أنها ترفع استثناءات من النوع `TypeError` عند استدعائها بمعاملات غير صحيحة.

**parameters**: لا تحتوي هذه الوظيفة على معاملات محددة حيث يتم استدعاؤها مباشرة داخل الكلاس الذي تنتمي إليه.

**Code Description**: تقوم هذه الوظيفة باختبار وظيفة `char_length` للتأكد من أنها تتصرف بشكل صحيح عند استدعائها بمعاملات غير صحيحة. يتم ذلك باستخدام الدالة `assert_raises` من مكتبة الاختبارات، والتي تتحقق من أن استثناء `TypeError` يتم رفعه في الحالتين التاليتين:

1. عند استدعاء `char_length` بمعاملين نصيين ("a" و "b")، حيث يتوقع أن الوظيفة `char_length` لا تقبل أكثر من معامل واحد.
2. عند استدعاء `char_length` بدون أي معاملات، حيث يتوقع أن الوظيفة تتطلب معاملًا واحدًا على الأقل.

**Note**: يجب التأكد من أن الوظيفة `char_length` تم تنفيذها بشكل صحيح بحيث ترفع استثناء `TypeError` في الحالات المذكورة أعلاه. إذا لم يتم رفع الاستثناء، فإن الاختبار سيفشل، مما يشير إلى وجود خطأ في تنفيذ الوظيفة `char_length`.
***
### FunctionDef test_return_type_detection(self)
**test_return_type_detection**: وظيفة `test_return_type_detection` هي التحقق من أن الدوال المختلفة تُرجع أنواع البيانات المتوقعة بناءً على المدخلات المقدمة لها.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة يتم تمريرها إليها مباشرةً، حيث إنها تعتمد على قيم ثابتة يتم تعريفها داخل الوظيفة نفسها.

**Code Description**: 
تقوم هذه الوظيفة باختبار أنواع البيانات التي تُرجعها عدة دوال مثل `coalesce`، `max`، `min`، و`sum`. يتم ذلك من خلال تمرير مجموعة من القيم المختلفة لهذه الدوال والتحقق من أن نوع البيانات المُعاد يتوافق مع النوع المتوقع. 

يتم تنفيذ الاختبارات باستخدام حلقة `for` متداخلة:
1. الحلقة الخارجية تمرر على الدوال المحددة (`func.coalesce`، `func.max`، `func.min`، `func.sum`).
2. الحلقة الداخلية تمرر على مجموعة من الأزواج، حيث يحتوي كل زوج على:
   - قيم مدخلات (arguments) يتم تمريرها إلى الدالة.
   - نوع البيانات المتوقع (type_) الذي يجب أن تُرجع الدالة.

يتم استخدام `assert` للتحقق من أن نوع البيانات المُعاد من الدالة (`fn(*args).type`) يتوافق مع النوع المتوقع (`type_`). في حالة عدم التوافق، يتم إظهار رسالة خطأ توضح الدالة المستخدمة ونوع البيانات الفعلي والمتوقع.

بعد ذلك، يتم التحقق بشكل منفصل من أن الدالة `func.concat` تُرجع نوع بيانات من فئة `sqltypes.String` عند تمرير النصوص كمدخلات.

**Note**: 
- هذه الوظيفة مخصصة للاختبارات (testing) ولا تُستخدم في الإنتاج.
- يتم استخدام أنواع بيانات محددة من مكتبة `sqltypes` مثل `Date`، `Integer`، `Numeric`، `String`، و`DateTime` للتحقق من النتائج.
- يجب أن تكون القيم المدخلة متوافقة مع أنواع البيانات المتوقعة للدوال المستخدمة.

**Output Example**: 
لا تُرجع هذه الوظيفة أي قيمة (return value) مباشرة، ولكنها تُظهر رسائل خطأ في حالة فشل أي من اختبارات `assert`. على سبيل المثال، إذا فشل اختبار لنوع البيانات، قد تظهر رسالة مثل:
```
<function coalesce at 0x...> / <class 'sqltypes.Integer'> != <class 'sqltypes.Date'>
```
مما يشير إلى أن نوع البيانات المُعاد لا يتوافق مع النوع المتوقع.
***
### FunctionDef test_assorted(self)
**test_assorted**: وظيفة `test_assorted` هي اختبار مجموعة متنوعة من الحالات المتعلقة بإنشاء واستخدام الدوال (functions) في SQL باستخدام مكتبة SQLAlchemy.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) حيث إنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى الكائن الحالي.

**Code Description**: تقوم هذه الوظيفة باختبار عدة سيناريوهات مختلفة تتعلق بإنشاء واستخدام الدوال في SQLAlchemy. فيما يلي تفصيل لكل جزء من الكود:

1. **إنشاء الجداول**: يتم إنشاء جدولين (`mytable` و`myothertable`) يحتوي كل منهما على عمود واحد من نوع `Integer`.

2. **اختبار تعبير يحتوي على دالة**: يتم استخدام الدالة `func.lala` مع معاملات مختلفة، بما في ذلك قيمة ثابتة (`literal("five")`) وعمود من الجدول (`table1.c.myid`). يتم التحقق من أن التعبير الناتج يتطابق مع النص المتوقع.

3. **اختبار استعلام SELECT مع دالة**: يتم اختبار استعلام `SELECT` يستخدم الدالة `func.count` لحساب عدد الصفوف في عمود معين من الجدول. يتم التحقق من أن النص الناتج يتطابق مع النص المتوقع.

4. **اختبار اسم دالة "منقط"**: يتم اختبار استخدام دالة ذات اسم "منقط" (مثل `foo.bar.lala`) ويتم التحقق من أن النص الناتج يتطابق مع النص المتوقع.

5. **اختبار معامل الربط (bind parameter) مع اسم دالة "منقط"**: يتم التحقق من أن اسم معامل الربط في الدالة "منقط" يتم تقصيره بشكل صحيح.

6. **اختبار دالة "منقط" من المحرك نفسه**: يتم اختبار استخدام دالة "منقط" مباشرة من المحرك (`func.lala.hoho`) ويتم التحقق من النص الناتج.

7. **اختبار استخدام `None` في الدالة**: يتم التحقق من أن استخدام `None` في الدالة يتم تحويله إلى `NULL` في النص الناتج.

8. **اختبار التخزين المؤقت (caching)**: يتم إنشاء كائن دالة (`f1`) واختبار إنشاء مفتاح التخزين المؤقت له.

9. **اختبار التخليل (pickling)**: يتم اختبار إمكانية تخليل (pickle) كائن الدالة وإعادة تحميله، مع التحقق من أن النص الناتج يتطابق مع النص المتوقع.

10. **اختبار رفع استثناء `AttributeError`**: يتم التحقق من أن محاولة الوصول إلى السمة `__bases__` للدالة ترفع استثناء `AttributeError`، مما يؤكد أن الدالة ليست فئة (class).

**Note**: 
- هذه الوظيفة مخصصة للاختبارات ولا يجب استخدامها في الإنتاج.
- يتم استخدام `self.assert_compile` للتحقق من أن النص الناتج من التعبيرات يتطابق مع النص المتوقع.
- يتم استخدام `pickle` لاختبار إمكانية تخليل كائنات الدوال وإعادة تحميلها.
***
### FunctionDef test_pickle_over(self)
**test_pickle_over**: وظيفة `test_pickle_over` هي اختبار قدرة الكائن `func.row_number().over()` على التخزين والاسترجاع باستخدام وحدة `pickle` في لغة Python.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذ الاختبار بشكل مباشر داخل الدالة.

**Code Description**: تقوم هذه الدالة باختبار عملية التخزين والاسترجاع (pickling and unpickling) للكائن `func.row_number().over()` باستخدام وحدة `pickle` في Python. يتم إنشاء الكائن `f1` باستخدام الدالة `func.row_number().over()`، والتي تُرجع تعبير SQL يمثل دالة ترقيم الصفوف (`row_number()`) مع نافذة (`OVER`) بدون أي شروط محددة. بعد ذلك، يتم تخزين الكائن `f1` باستخدام `pickle.dumps()`، ثم يتم استرجاعه مرة أخرى باستخدام `pickle.loads()`. يتم بعد ذلك استخدام الدالة `self.assert_compile` لمقارنة النتيجة المسترجعة مع النص المتوقع `"row_number() OVER ()"`، للتأكد من أن عملية التخزين والاسترجاع لم تؤثر على سلوك الكائن أو بنيته.

**Note**: 
- هذه الدالة جزء من مجموعة اختبارات تهدف إلى التحقق من صحة عمليات التخزين والاسترجاع للكائنات في SQLAlchemy، خاصة تلك التي تحتوي على دوال ونوافذ.
- تم وضع تعليق `TODO` يشير إلى أن حزمة `test/sql` تفتقر إلى مجموعة اختبارات شاملة لعمليات التخزين والاسترجاع، مما يشير إلى أن هذه الدالة قد تكون جزءًا من جهود مستقبلية لتعزيز هذه الاختبارات.
***
### FunctionDef test_pickle_within_group(self)
**test_pickle_within_group**: وظيفة `test_pickle_within_group` هي اختبار قدرة دالة `percentile_cont` مع استخدام `within_group` على العمل بشكل صحيح بعد عملية التخزين والاسترجاع باستخدام `pickle`.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على اختبارات داخلية محددة مسبقًا.

**Code Description**: تقوم هذه الدالة باختبار عملية التخزين والاسترجاع (pickling and unpickling) لدالة `percentile_cont` عند استخدامها مع `within_group`. يتم ذلك من خلال الخطوات التالية:

1. يتم إنشاء كائن `f1` باستخدام الدالة `percentile_cont` مع قيمة ثابتة (`literal(1)`) ويتم تطبيق `within_group` عليه دون تحديد أي أعمدة للترتيب.
2. يتم استخدام `pickle.dumps` لتخزين الكائن `f1` في شكل بايتات، ثم يتم استرجاعه باستخدام `pickle.loads`.
3. يتم التحقق من أن الناتج بعد الاسترجاع يتطابق مع التعبير SQL المتوقع باستخدام `self.assert_compile`. التعبير المتوقع هو `"percentile_cont(:param_1) WITHIN GROUP (ORDER BY )"`.

بعد ذلك، يتم تكرار العملية مع تحديد أعمدة للترتيب داخل `within_group`:
1. يتم إنشاء كائن `f1` جديد باستخدام `percentile_cont` مع `literal(1)`، ويتم تطبيق `within_group` مع تحديد عمودين للترتيب (`column("q")` و `column("p").desc()`).
2. يتم تخزين الكائن واسترجاعه مرة أخرى باستخدام `pickle`.
3. يتم التحقق من أن الناتج يتطابق مع التعبير SQL المتوقع، وهو `"percentile_cont(:param_1) WITHIN GROUP (ORDER BY q, p DESC)"`.

**Note**: هذه الدالة جزء من اختبارات التأكد من صحة عمل الدوال التي تعتمد على `pickle` في مشاريع SQLAlchemy. يجب التأكد من أن جميع الدوال التي تحتوي على `__reduce__` يتم اختبارها بشكل شامل لضمان عملها بشكل صحيح بعد التخزين والاسترجاع.
***
### FunctionDef test_functions_with_cols(self)
**test_functions_with_cols**: وظيفة `test_functions_with_cols` هي اختبار استخدام الدوال (functions) مع الأعمدة (columns) في استعلامات SQL باستخدام مكتبة SQLAlchemy.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) لأنها جزء من فئة (class) وتستخدم `self` للإشارة إلى الكائن الحالي.

**Code Description**: 
تقوم هذه الوظيفة باختبار كيفية استخدام الدوال المدمجة في SQLAlchemy مع الأعمدة في استعلامات SQL. يتم ذلك من خلال إنشاء جدول افتراضي باسم `users` يحتوي على الأعمدة `id`، `name`، و`fullname`. بعد ذلك، يتم إنشاء استعلام فرعي (subquery) باستخدام الدالة `func.calculate` التي تأخذ معاملين (`x` و`y`) كقيم مرتبطة (bind parameters).

1. **الجزء الأول من الاختبار**: يتم إنشاء استعلام رئيسي (main query) يقوم باختيار جميع الأعمدة من جدول `users` مع تطبيق شرط `WHERE` حيث يكون `id` أكبر من القيمة الموجودة في العمود `z` من الاستعلام الفرعي. يتم استخدام `assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع.

2. **الجزء الثاني من الاختبار**: يتم إنشاء استعلام آخر يستخدم الدالة `between` للتحقق من أن `id` يقع بين قيمتين محددتين من عمود `z` في نسختين مختلفتين من الاستعلام الفرعي. يتم استخدام `alias` لإنشاء نسختين من الاستعلام الفرعي مع قيم مختلفة للمعاملات `x` و`y`. يتم أيضًا استخدام `unique_params` لتعيين قيم مختلفة للمعاملات في كل نسخة. أخيرًا، يتم استخدام `assert_compile` مرة أخرى للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع، مع التحقق من القيم المرتبطة (checkparams).

**Note**: 
- تأكد من فهم كيفية عمل الدوال المدمجة (functions) في SQLAlchemy وكيفية استخدامها مع الاستعلامات الفرعية (subqueries).
- عند استخدام `alias` و`unique_params`، تأكد من تعيين القيم الصحيحة للمعاملات لتجنب الأخطاء في النتائج.
- يمكن استخدام `assert_compile` للتحقق من أن الاستعلامات المترجمة تتطابق مع التوقعات، مما يساعد في اختبار صحة الكود.
***
### FunctionDef test_non_functions(self)
**test_non_functions**: وظيفة `test_non_functions` هي اختبار وظائف غير دالة (non-functions) مثل `CAST` و `EXTRACT` في SQL باستخدام مكتبة SQLAlchemy.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على `self` كمعامل ضمني للوصول إلى وظائف الفئة التي تنتمي إليها.

**Code Description**: تقوم هذه الوظيفة باختبار عمليتين رئيسيتين:
1. **عملية CAST**: يتم استخدام `func.cast` لتحويل النص `"foo"` إلى نوع بيانات `Integer` (عدد صحيح). يتم بعد ذلك استخدام `self.assert_compile` للتحقق من أن التعبير الناتج يطابق النص `"CAST(:param_1 AS INTEGER)"`. هذا يعني أن الوظيفة تتحقق من أن عملية التحويل تتم بشكل صحيح وتولد الاستعلام SQL المطلوب.
   
2. **عملية EXTRACT**: يتم استخدام `func.extract` لاستخراج السنة من تاريخ محدد (`datetime.date(2010, 12, 5)`). يتم التحقق من أن التعبير الناتج يطابق النص `"EXTRACT(year FROM :param_1)"`. هذا يضمن أن عملية استخراج السنة من التاريخ تتم بشكل صحيح وتولد الاستعلام SQL المناسب.

**Note**: 
- هذه الوظيفة تعتمد على مكتبة SQLAlchemy لإنشاء وتجميع استعلامات SQL. لذلك، يجب التأكد من أن المكتبة مثبتة ومهيئة بشكل صحيح قبل استخدام هذه الوظيفة.
- يتم استخدام `self.assert_compile` للتحقق من صحة التعبيرات الناتجة، مما يعني أن هذه الوظيفة جزء من فئة اختبار (test class) تستخدم إطار عمل اختبار مثل `unittest` أو `pytest`.
***
### FunctionDef test_select_method_one(self)
**test_select_method_one**: وظيفة `test_select_method_one` تهدف إلى اختبار عملية الترجمة (compile) لاستعلام SQL يتم إنشاؤه باستخدام دالة `rows` من مكتبة `func`.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.

**Code Description**:  
تقوم هذه الدالة بإنشاء تعبير (expression) باستخدام الدالة `rows` من مكتبة `func`، حيث يتم تمرير النص `"foo"` كمعامل لها. بعد ذلك، يتم استدعاء الدالة `select()` على هذا التعبير لإنشاء استعلام SQL. يتم بعد ذلك استخدام الدالة `assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع `"SELECT rows(:rows_2) AS rows_1"`.  

- `expr = func.rows("foo")`: يتم إنشاء تعبير باستخدام الدالة `rows` مع تمرير النص `"foo"` كمعامل.
- `self.assert_compile(expr.select(), "SELECT rows(:rows_2) AS rows_1")`: يتم التحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع.

**Note**:  
- هذه الدالة جزء من اختبارات وحدة (unit tests) تهدف إلى التأكد من أن عملية الترجمة (compile) للاستعلامات تعمل بشكل صحيح.
- يجب أن يكون النص المتوقع في `assert_compile` مطابقًا تمامًا للاستعلام المترجم حتى ينجح الاختبار.
***
### FunctionDef test_alias_method_one(self)
**test_alias_method_one**: وظيفة `test_alias_method_one` هي اختبار طريقة `alias` على كائن `expr` الذي تم إنشاؤه باستخدام الدالة `rows`.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على الكائن `self` الذي يتم تمريره تلقائيًا في سياق اختبار وحدة (unit test).

**Code Description**: 
- تقوم الدالة بإنشاء كائن `expr` باستخدام الدالة `rows("foo")`، حيث يتم تمرير النص `"foo"` كمعامل لها. هذه الدالة تُرجع كائنًا يمثل تعبيرًا (expression) معينًا.
- بعد ذلك، يتم استدعاء طريقة `alias()` على الكائن `expr`، والتي تُستخدم لإنشاء اسم مستعار (alias) للتعبير. الاسم المستعار هو تمثيل بديل للتعبير الأصلي.
- أخيرًا، يتم استخدام الدالة `self.assert_compile()` للتحقق من أن التعبير الناتج بعد تطبيق `alias()` يطابق النص `"rows(:rows_1)"`. هذه الدالة تُستخدم عادةً في اختبارات SQLAlchemy أو مكتبات مشابهة للتحقق من أن التعبير يتم تجميعه (compile) بشكل صحيح إلى النص المطلوب.

**Note**: 
- هذه الدالة جزء من اختبار وحدة (unit test) وتُستخدم للتحقق من صحة سلوك طريقة `alias()` في سياق معين.
- يجب أن يكون النص `"rows(:rows_1)"` مطابقًا تمامًا للناتج المتوقع من عملية التجميع (compilation) للتعبير بعد تطبيق `alias()`.
***
### FunctionDef test_select_method_two(self)
**test_select_method_two**: وظيفة `test_select_method_two` هي اختبار عملية اختيار البيانات باستخدام طريقة محددة في SQL مع التحقق من صحة الترجمة النهائية للاستعلام.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة يتم تمريرها إليها بشكل مباشر.

**Code Description**: تقوم هذه الدالة باختبار عملية إنشاء استعلام SQL باستخدام دالة `rows` من خلال مكتبة `func`. يتم إنشاء تعبير (expression) باستخدام `func.rows("foo")`، والذي يُستخدم لإنشاء استعلام فرعي (subquery). بعد ذلك، يتم استخدام الاستعلام الفرعي كجزء من استعلام رئيسي يتم إنشاؤه بواسطة `select("*").select_from(...)`. 

يتم التحقق من صحة الترجمة النهائية للاستعلام باستخدام `self.assert_compile`، حيث يتم مقارنة الاستعلام الناتج مع النص المتوقع:  
`"SELECT * FROM (SELECT rows(:rows_2) AS rows_1) AS anon_1"`.  
هذا الاختبار يضمن أن الترجمة النهائية للاستعلام تتطابق مع التوقعات المحددة.

**Note**:  
- يتم استخدام `func.rows("foo")` لإنشاء تعبير SQL خاص، ويجب التأكد من أن هذه الدالة مدعومة في البيئة التي يتم تنفيذ الكود فيها.  
- يتم استخدام `subquery()` لتحويل الاستعلام الفرعي إلى كيان يمكن استخدامه في استعلام رئيسي.  
- يجب أن يكون النص المتوقع في `self.assert_compile` مطابقًا تمامًا للاستعلام الناتج لضمان نجاح الاختبار.
***
### FunctionDef test_select_method_three(self)
**test_select_method_three**: وظيفة `test_select_method_three` هي اختبار عملية التجميع (compile) لاستعلام SQL يتم إنشاؤه باستخدام دالة `select` مع تعبير `rows`.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة يتم تمريرها إليها بشكل مباشر. بدلاً من ذلك، تعتمد على الكائن الحالي (`self`) الذي يتم تنفيذ الوظيفة ضمنه.

**Code Description**: 
1. يتم إنشاء تعبير (`expr`) باستخدام الدالة `rows("foo")`، حيث يتم تمرير السلسلة النصية `"foo"` كمعامل. هذه الدالة تُرجع تعبيرًا يمثل صفوفًا (rows) مرتبطة بالقيمة `"foo"`.
2. يتم استخدام الدالة `select` لإنشاء استعلام SQL، حيث يتم تحديد العمود `"foo"` باستخدام الدالة `column("foo")`.
3. يتم استخدام الدالة `select_from` لتحديد المصدر (source) للاستعلام، والذي في هذه الحالة هو التعبير `expr` الذي تم إنشاؤه مسبقًا.
4. يتم استخدام الدالة `assert_compile` للتحقق من أن الاستعلام الذي تم إنشاؤه يتطابق مع النص المتوقع `"SELECT foo FROM rows(:rows_1)"`. هذه الدالة تقوم بمقارنة الاستعلام المترجم مع النص المتوقع للتأكد من صحته.

**Note**: 
- هذه الوظيفة تُستخدم بشكل أساسي في اختبارات الوحدة (unit tests) للتحقق من صحة إنشاء استعلامات SQL باستخدام مكتبة معينة.
- من المهم التأكد من أن النص المتوقع في `assert_compile` يتطابق تمامًا مع الناتج الفعلي للاستعلام، حيث أن أي اختلاف بسيط قد يؤدي إلى فشل الاختبار.
***
### FunctionDef test_alias_method_two(self)
**test_alias_method_two**: وظيفة `test_alias_method_two` هي اختبار استخدام طريقة `alias` على كائن `rows` والتحقق من صحة الترجمة (compilation) للاستعلام الناتج.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى الكائن الحالي.

**Code Description**: 
1. تقوم الدالة بإنشاء تعبير (expression) باستخدام الدالة `rows("foo")`، حيث يتم تمرير السلسلة النصية `"foo"` كمعامل. هذا التعبير يمثل عمودًا أو مجموعة من الصفوف في قاعدة البيانات.
2. يتم استخدام طريقة `alias` على التعبير الناتج، حيث يتم تعيين اسم مستعار (`alias`) لهذا التعبير وهو `"bar"`.
3. يتم إنشاء استعلام (query) باستخدام الدالة `select("*")`، حيث يتم تحديد جميع الأعمدة (`*`) من الجدول أو التعبير المعين.
4. يتم استخدام الدالة `select_from` لتحديد المصدر (source) للاستعلام، وهو التعبير الذي تم تعيين اسم مستعار له (`expr.alias("bar")`).
5. يتم استخدام الدالة `assert_compile` للتحقق من أن الترجمة (compilation) للاستعلام الناتج تطابق النص المتوقع، وهو `"SELECT * FROM rows(:rows_1) AS bar"`. هنا، `:rows_1` هو معامل يتم تمريره تلقائيًا.

**Note**: 
- هذه الدالة جزء من اختبارات الوحدة (unit tests) وتستخدم للتحقق من أن الترجمة (compilation) للاستعلامات تتم بشكل صحيح عند استخدام الأسماء المستعارة (aliases).
- يجب أن يكون النص المتوقع في `assert_compile` مطابقًا تمامًا للناتج الفعلي للترجمة، بما في ذلك الأسماء المستعارة والمعاملات.
***
### FunctionDef test_alias_method_columns(self)
**test_alias_method_columns**: وظيفة `test_alias_method_columns` هي اختبار سلوك طريقة `alias` عند استخدامها مع دالة `rows` في إنشاء استعلام SQL.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.

**Code Description**: 
تقوم هذه الدالة باختبار كيفية تصدير قائمة الأعمدة عند استخدام طريقة `alias` مع دالة `rows`. يتم إنشاء تعبير (expression) باستخدام الدالة `rows` مع تمرير القيمة `"foo"` كمعامل، ثم يتم تعيين اسم مستعار (alias) لهذا التعبير باستخدام `alias("bar")`. بعد ذلك، يتم استخدام هذا التعبير في استعلام `select` لاختبار كيفية ترجمة هذا التعبير إلى استعلام SQL.

يتم استخدام الدالة `self.assert_compile` للتحقق من أن الترجمة الناتجة عن التعبير تتطابق مع الاستعلام المتوقع، وهو `"SELECT bar.rows_1 FROM rows(:rows_2) AS bar"`. هذا الاختبار يهدف إلى التأكد من أن التعبير لا يسبب أي أخطاء عند تصدير قائمة الأعمدة، حتى لو لم يكن هذا السلوك مفيدًا بشكل كبير في الواقع العملي.

**Note**: 
- هذا الاختبار يهدف بشكل أساسي إلى التأكد من أن التعبير لا يسبب أي أخطاء عند تصدير قائمة الأعمدة، حتى لو لم يكن هذا السلوك مفيدًا بشكل كبير في الواقع العملي.
- تم إضافة هذا الاختبار بعد إصلاح المشكلة رقم #2974، حيث كان هناك سلوك غير متوقع في تصدير قائمة الأعمدة.
***
### FunctionDef test_alias_method_columns_two(self)
**test_alias_method_columns_two**: وظيفة `test_alias_method_columns_two` هي التحقق من أن التعبير الذي يتم إنشاؤه باستخدام الدالة `alias` يحتوي على العدد الصحيح من الأعمدة.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters).

**Code Description**:  
تقوم هذه الدالة بإنشاء تعبير (`expr`) باستخدام الدالة `rows` مع تمرير القيمة `"foo"` كمعامل لها، ثم يتم استخدام الدالة `alias` لإعطاء هذا التعبير اسمًا جديدًا وهو `"bar"`. بعد ذلك، يتم التحقق من أن عدد الأعمدة (`c`) في التعبير `expr` يساوي القيمة المتوقعة باستخدام `assert`.  

بشكل أكثر تفصيلًا:
1. `func.rows("foo")`: يتم إنشاء تعبير باستخدام الدالة `rows` مع تمرير القيمة `"foo"`.
2. `.alias("bar")`: يتم إعطاء هذا التعبير اسمًا جديدًا (`alias`) وهو `"bar"`.
3. `len(expr.c)`: يتم حساب عدد الأعمدة في التعبير `expr`.
4. `assert`: يتم التحقق من أن عدد الأعمدة يساوي القيمة المتوقعة.

**Note**:  
- هذه الدالة تستخدم للتحقق من صحة إنشاء التعبيرات واستخدام الدالة `alias` بشكل صحيح.
- يجب التأكد من أن التعبير الذي يتم إنشاؤه يحتوي على العدد الصحيح من الأعمدة قبل استخدامه في أي عمليات لاحقة.
***
### FunctionDef test_funcfilter_empty(self)
**test_funcfilter_empty**: وظيفة `test_funcfilter_empty` هي التحقق من أن التعبير الناتج عن استخدام دالة `filter` بدون أي شروط (فارغة) يتم تجميعه بشكل صحيح.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.

**Code Description**: تقوم هذه الدالة باختبار سلوك دالة `filter` عند استخدامها بدون أي شروط (أي بدون تحديد أي فلتر). يتم ذلك من خلال استدعاء الدالة `func.count(1).filter()` والتي تقوم بإنشاء تعبير SQL يحتوي على دالة `count` مع فلتر فارغ. بعد ذلك، يتم استخدام الدالة `assert_compile` للتحقق من أن التعبير الناتج يتم تجميعه بشكل صحيح إلى النص `"count(:count_1)"`. 

- `func.count(1)`: تقوم بإنشاء تعبير SQL يحتوي على دالة `count` مع القيمة `1`.
- `.filter()`: يتم استخدام `filter` بدون أي شروط، مما يعني أن الفلتر فارغ.
- `self.assert_compile`: تقوم هذه الدالة بالتحقق من أن التعبير الناتج يتم تجميعه بشكل صحيح إلى النص المطلوب.

**Note**: يجب التأكد من أن استخدام `filter` بدون شروط لا يؤدي إلى أخطاء في التجميع، وأن التعبير الناتج يتوافق مع التوقعات.
***
### FunctionDef test_funcfilter_criterion(self)
**test_funcfilter_criterion**: وظيفة `test_funcfilter_criterion` هي اختبار وظيفة التصفية (`filter`) المستخدمة مع دالة التجميع (`count`) في SQL.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على الدوال والمتغيرات المحددة مسبقًا داخل الكلاس الذي تنتمي إليه.

**Code Description**: تقوم هذه الوظيفة باختبار استخدام دالة التصفية (`filter`) مع دالة التجميع (`count`) في SQL. يتم استخدام الدالة `func.count(1)` لحساب عدد الصفوف، ويتم تطبيق شرط التصفية باستخدام `filter(table1.c.name != None)`، حيث يتم تصفية الصفوف التي تحتوي على قيمة غير فارغة (`IS NOT NULL`) في العمود `name` من الجدول `table1`. 

يتم استخدام الدالة `self.assert_compile` لمقارنة الناتج النهائي للاستعلام المترجم مع النص المتوقع. في هذه الحالة، النص المتوقع هو:  
`"count(:count_1) FILTER (WHERE mytable.name IS NOT NULL)"`.  
هذا النص يمثل الاستعلام الذي يتم إنشاؤه باستخدام الدوال المذكورة أعلاه.

**Note**:  
- يتم استخدام `# noqa` لتجاهل تحذيرات الأدوات التي تتحقق من جودة الكود (مثل flake8) في هذا السطر، حيث إنها غير ضرورية في هذا السياق.  
- يجب التأكد من أن الجدول `table1` والعمود `name` موجودان ومحددان بشكل صحيح في قاعدة البيانات قبل استخدام هذا الاختبار.  
- هذه الوظيفة جزء من اختبارات التحقق من صحة الترجمة (compilation) للاستعلامات SQL، لذا يجب أن تكون النتائج متوافقة مع بناء الجملة الصحيح لـ SQL.
***
### FunctionDef test_funcfilter_compound_criterion(self)
**test_funcfilter_compound_criterion**: وظيفة `test_funcfilter_compound_criterion` هي التحقق من صحة ترجمة استعلام SQL الذي يستخدم دالة تجميع مع فلتر مركب.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على `self` كمعامل ضمني للوصول إلى الدوال المساعدة مثل `assert_compile`.

**Code Description**: تقوم هذه الوظيفة باختبار عملية ترجمة استعلام SQL الذي يجمع بين دالة التجميع `count` وفلتر مركب. يتم استخدام الدالة `func.count(1)` لحساب عدد الصفوف، ويتم تطبيق فلتر مركب باستخدام الشرطين التاليين:
1. `table1.c.name == None`: للتحقق من أن قيمة العمود `name` في الجدول `table1` تساوي `NULL`.
2. `table1.c.myid > 0`: للتحقق من أن قيمة العمود `myid` في الجدول `table1` أكبر من الصفر.

يتم استخدام الدالة `assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع:
```sql
"count(:count_1) FILTER (WHERE mytable.name IS NULL AND mytable.myid > :myid_1)"
```
حيث يتم استخدام `:count_1` و `:myid_1` كمعاملات مرتبطة (bound parameters) في الاستعلام.

**Note**: 
- يتم استخدام `# noqa` لتجاهل تحذيرات الأدوات التحليلية (linters) بخصوص استخدام `== None` بدلاً من `is None`.
- يجب التأكد من أن الجدول `table1` والأعمدة `name` و `myid` موجودة ومحددة بشكل صحيح في السياق الذي يتم تنفيذ هذا الاختبار فيه.
***
### FunctionDef test_funcfilter_arrayagg_subscript(self)
**test_funcfilter_array_subscript**: وظيفة `test_funcfilter_array_subscript` هي اختبار عملية تجميع مصفوفة مع تطبيق فلتر واستخراج عنصر محدد من المصفوفة باستخدام لغة SQL في بيئة PostgreSQL.

**parameters**: لا تحتوي هذه الدالة على معاملات محددة يتم تمريرها إليها بشكل مباشر. بدلاً من ذلك، يتم تعريف المتغيرات داخليًا لتنفيذ الاختبار.

**Code Description**: 
تقوم هذه الدالة باختبار عملية تجميع مصفوفة (`array_agg`) مع تطبيق فلتر (`filter`) على عمود معين (`num`) واستخراج عنصر محدد من المصفوفة باستخدام الفهرس (`[1]`). يتم ذلك باستخدام دالة `func.array_agg` التي تقوم بتجميع القيم في عمود معين (`num`) في مصفوفة. بعد ذلك، يتم تطبيق فلتر (`filter`) على المصفوفة بحيث يتم تضمين القيم التي تحقق الشرط (`num % 2 == 0`)، أي القيم الزوجية فقط. أخيرًا، يتم استخراج العنصر الثاني من المصفوفة باستخدام الفهرس `[1]`.

يتم استخدام الدالة `assert_compile` للتحقق من أن الكود المترجم يتطابق مع الناتج المتوقع. الناتج المتوقع هو عبارة SQL التي تقوم بتجميع القيم في العمود `q` مع تطبيق فلتر لاختيار القيم الزوجية فقط، ثم استخراج العنصر الثاني من المصفوفة. يتم استخدام لغة SQL الخاصة بـ PostgreSQL (`dialect="postgresql"`) لضمان أن الكود المترجم يتوافق مع بناء جملة PostgreSQL.

**Note**: 
- يجب التأكد من أن الكود المترجم يتوافق مع بناء جملة PostgreSQL، حيث يتم تحديد `dialect="postgresql"` في الدالة `assert_compile`.
- يتم استخدام الفهرس `[1]` لاستخراج العنصر الثاني من المصفوفة، حيث أن الفهارس في SQL تبدأ من 1 وليس من 0.
***
### FunctionDef test_funcfilter_label(self)
**test_funcfilter_label**: وظيفة `test_funcfilter_label` هي اختبار استخدام دالة `filter` مع التسمية (`label`) في استعلام SQL باستخدام مكتبة SQLAlchemy.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى مثيل الفئة الحالي.

**Code Description**: تقوم هذه الدالة باختبار استعلام SQL يتم إنشاؤه باستخدام دالة `func.count(1)` التي تُستخدم لحساب عدد الصفوف. يتم تطبيق شرط `filter` على الاستعلام بحيث يتم حساب الصفوف فقط إذا كان العمود `description` في الجدول `table1` غير فارغ (`NOT NULL`). بعد ذلك، يتم تسمية النتيجة باستخدام `label("foo")`، مما يعطي العمود الناتج اسمًا معينًا (`foo`).

يتم استخدام الدالة `self.assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع النص المتوقع للاستعلام. النص المتوقع للاستعلام هو:
```sql
SELECT count(:count_1) FILTER (WHERE mytable.description IS NOT NULL) AS foo FROM mytable
```
حيث يتم استخدام `:count_1` كمعامل (placeholder) للقيمة `1` في الاستعلام.

**Note**: 
- يتم استخدام `# noqa` لتجاهل تحذيرات الأدوات التي تفحص جودة الكود (linting tools) بخصوص استخدام `!= None`، حيث يُفضل عادةً استخدام `is not None` في Python.
- يجب التأكد من أن الجدول `table1` والعمود `description` موجودان في قاعدة البيانات وأنهما متوافقان مع الاستعلام الذي يتم اختباره.
- هذه الدالة جزء من اختبارات وحدة (unit tests) تهدف إلى التحقق من صحة إنشاء استعلامات SQL باستخدام SQLAlchemy.
***
### FunctionDef test_funcfilter_fromobj_fromfunc(self)
**test_funcfilter_fromobj_fromfunc**: وظيفة هذه الدالة هي اختبار إنشاء `from_obj` من خلال استخدام `func` مع تطبيق `filter` على عمود في جدول.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على `self` كمعامل ضمني للوصول إلى الدوال والخصائص الخاصة بالكلاس الذي تنتمي إليه.

**Code Description**: تقوم هذه الدالة باختبار عملية إنشاء استعلام SQL باستخدام الدالة `func.max` مع تطبيق فلتر (`filter`) على عمود معين. يتم استخدام الدالة `assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع النتيجة المتوقعة. 

في التفاصيل:
- يتم استخدام `func.max(table1.c.name)` لإنشاء استعلام يقوم بحساب القيمة القصوى للعمود `name` في الجدول `table1`.
- يتم تطبيق فلتر (`filter`) على الاستعلام باستخدام الشرط `literal_column("description") != None`، مما يعني أن الفلتر سيتم تطبيقه فقط على الصفوف التي تحتوي على قيمة غير فارغة (`NULL`) في العمود `description`.
- يتم استخدام `assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع النص المتوقع للاستعلام، وهو:
  ```sql
  SELECT max(mytable.name) FILTER (WHERE description IS NOT NULL) AS anon_1 FROM mytable
  ```
  حيث يتم التأكد من أن الاستعلام الذي تم إنشاؤه يتطابق مع النص المتوقع.

**Note**: 
- يُستخدم `literal_column("description")` للإشارة إلى عمود `description` بشكل مباشر في الاستعلام، مما يعني أن العمود يجب أن يكون موجودًا في الجدول.
- يجب التأكد من أن الجدول `table1` والعمود `description` موجودان في قاعدة البيانات قبل تنفيذ هذا الاختبار.
***
### FunctionDef test_funcfilter_fromobj_fromcriterion(self)
**test_funcfilter_fromobj_fromcriterion**: وظيفة `test_funcfilter_fromobj_fromcriterion` هي اختبار وظيفة التصفية (`filter`) المطبقة على دالة تجميع (`count`) باستخدام معيار (`criterion`) محدد من كائن (`object`).

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على `self` كمعامل ضمني للوصول إلى الدوال والأدوات المساعدة داخل الفئة التي تنتمي إليها.

**Code Description**: تقوم هذه الوظيفة باختبار عملية تجميع البيانات باستخدام دالة `count` مع تطبيق شرط تصفية (`filter`) على عمود محدد في الجدول. يتم استخدام الدالة `assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع النتيجة المتوقعة. 

في الكود، يتم إنشاء استعلام (`select`) يستخدم دالة `count` مع تطبيق شرط تصفية (`filter`) على العمود `name` في الجدول `table1`، حيث يتم التحقق من أن قيمة العمود `name` تساوي القيمة النصية `"name"`. النتيجة المتوقعة للاستعلام هي عبارة SQL محددة تحتوي على `FILTER` لتطبيق الشرط على عملية التجميع.

**Note**: 
- يجب التأكد من أن الجدول `table1` والعمود `name` موجودان ومحددان بشكل صحيح في قاعدة البيانات.
- يتم استخدام `assert_compile` للتحقق من صحة بناء الاستعلام، لذا يجب أن تكون النتيجة المتوقعة مطابقة تمامًا للاستعلام الذي يتم إنشاؤه.
- هذه الوظيفة جزء من اختبارات وحدة (unit tests) تهدف إلى التحقق من صحة بناء الاستعلامات باستخدام دالة `filter` مع دالة التجميع `count`.
***
### FunctionDef test_funcfilter_chaining(self)
**test_funcfilter_chaining**: وظيفة `test_funcfilter_chaining` هي اختبار إمكانية ربط (chaining) عوامل التصفية (filters) مع الدوال (functions) في استعلام SQL باستخدام مكتبة SQLAlchemy.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على الكائن `self` الذي يمثل حالة الاختبار الحالية.

**Code Description**: تقوم هذه الدالة باختبار إمكانية ربط عوامل التصفية (filters) مع الدوال (functions) في استعلام SQL. يتم ذلك من خلال إنشاء استعلام باستخدام الدالة `select` من مكتبة SQLAlchemy، حيث يتم استخدام الدالة `func.count(1)` لحساب عدد الصفوف. يتم بعد ذلك تطبيق عاملين تصفية (filters) على هذه الدالة باستخدام الشروط التالية:
- الشرط الأول: `table1.c.name == "name"`، حيث يتم تصفية الصفوف بناءً على عمود `name` في الجدول `table1`.
- الشرط الثاني: `table1.c.description == "description"`، حيث يتم تصفية الصفوف بناءً على عمود `description` في الجدول `table1`.

يتم بعد ذلك استخدام الدالة `assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع:
```sql
SELECT count(:count_1) FILTER (WHERE mytable.name = :name_1 AND mytable.description = :description_1) AS anon_1 FROM mytable
```
هذا النص يمثل الاستعلام الذي يتم إنشاؤه بعد تطبيق عوامل التصفية على الدالة `count`.

**Note**: 
- هذه الدالة تعتمد على وجود جدول يسمى `table1` يحتوي على الأعمدة `name` و `description`.
- يتم استخدام الدالة `assert_compile` للتحقق من صحة الترجمة النهائية للاستعلام، مما يضمن أن عوامل التصفية المطبقة تعمل بشكل صحيح.
- هذه الدالة مفيدة بشكل خاص عند اختبار الاستعلامات المعقدة التي تتضمن ربط عوامل التصفية مع الدوال في SQLAlchemy.
***
### FunctionDef test_funcfilter_windowing_orderby(self)
**test_funcfilter_windowing_orderby**: وظيفة `test_funcfilter_windowing_orderby` هي اختبار استخدام وظيفة التصفية (FILTER) مع وظيفة النوافذ (Windowing) وترتيب النتائج (ORDER BY) في استعلام SQL.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة يتم تمريرها إليها بشكل مباشر. بدلاً من ذلك، تعتمد على الكائن `self` الذي يشير إلى الفئة الحالية التي تحتوي على هذه الوظيفة.

**Code Description**: تقوم هذه الوظيفة باختبار عملية تجميع بين عدة ميزات في لغة SQL، وهي:
1. **وظيفة التصفية (FILTER)**: يتم استخدامها لتصفية النتائج بناءً على شرط معين. في هذا المثال، يتم تصفية النتائج بحيث يتم أخذ الصفوف التي تحتوي على قيمة في العمود `name` أكبر من القيمة `"foo"`.
2. **وظيفة النوافذ (Windowing)**: يتم استخدام وظيفة `rank()` التي تعتبر جزءًا من وظائف النوافذ في SQL. هذه الوظيفة تقوم بحساب الترتيب النسبي للصفوف بناءً على الشرط المحدد.
3. **ترتيب النتائج (ORDER BY)**: يتم ترتيب النتائج بناءً على العمود `name` في الجدول `table1`.

يتم استخدام الدالة `assert_compile` للتحقق من أن الاستعلام الذي تم إنشاؤه يتطابق مع الاستعلام المتوقع. في هذا المثال، يتم التحقق من أن الاستعلام الذي يتم إنشاؤه باستخدام `select` و `func.rank()` مع التصفية والترتيب يتطابق مع النص التالي:
```sql
SELECT rank() FILTER (WHERE mytable.name > :name_1) OVER (ORDER BY mytable.name) AS anon_1 FROM mytable
```
حيث يتم استخدام الجدول `mytable` والعمود `name` للتصفية والترتيب.

**Note**: 
- يجب التأكد من أن الجدول `table1` والعمود `name` موجودان ومحددان بشكل صحيح في قاعدة البيانات.
- هذه الوظيفة تعتمد على مكتبة SQLAlchemy لإنشاء الاستعلامات والتحقق منها، لذا يجب التأكد من أن المكتبة مثبتة ومهيئة بشكل صحيح.
***
### FunctionDef test_funcfilter_windowing_orderby_partitionby(self)
**test_funcfilter_windowing_orderby_partitionby**: وظيفة `test_funcfilter_windowing_orderby_partitionby` هي اختبار عملية تجميع استعلام SQL باستخدام وظيفة التصفية (`FILTER`) والوظائف النافذة (`OVER`) مع تحديد الترتيب (`ORDER BY`) والتقسيم (`PARTITION BY`).

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على البيانات المحددة مسبقًا داخل الكود.

**Code Description**: تقوم هذه الوظيفة باختبار عملية إنشاء استعلام SQL باستخدام مكتبة SQLAlchemy. يتم إنشاء الاستعلام باستخدام الدالة `select`، حيث يتم تطبيق الدالة `rank()` مع تصفية (`FILTER`) للبيانات بناءً على شرط محدد (`table1.c.name > "foo"`). يتم أيضًا تطبيق وظيفة نافذة (`OVER`) لتحديد ترتيب البيانات (`ORDER BY`) بناءً على العمود `name` وتقسيم البيانات (`PARTITION BY`) بناءً على العمود `description`.

يتم استخدام الدالة `assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع النص المتوقع للاستعلام. النص المتوقع للاستعلام هو:
```
"SELECT rank() FILTER (WHERE mytable.name > :name_1) OVER (PARTITION BY mytable.description ORDER BY mytable.name) AS anon_1 FROM mytable"
```
حيث يتم التأكد من أن الاستعلام الذي تم إنشاؤه يتطابق مع هذا النص.

**Note**: 
- يتم استخدام هذه الوظيفة بشكل أساسي لأغراض الاختبار للتأكد من أن بناء الاستعلام يعمل بشكل صحيح مع وظائف التصفية والنوافذ.
- يجب أن تكون البيانات المحددة في الكود (مثل `table1` والأعمدة `name` و`description`) موجودة ومحددة بشكل صحيح حتى يعمل الاختبار بشكل سليم.
***
### FunctionDef test_funcfilter_windowing_range(self)
**test_funcfilter_windowing_range**: وظيفة `test_funcfilter_windowing_range` هي اختبار وظيفة التصفية (`filter`) والترتيب (`rank`) باستخدام نافذة محددة (`windowing`) مع نطاق (`range`) في استعلام SQL.

**parameters**: لا تحتوي هذه الوظيفة على معاملات محددة يتم تمريرها إليها بشكل مباشر، حيث إنها تعتمد على كائن `self` الذي يستخدم للوصول إلى الدوال المساعدة مثل `assert_compile`.

**Code Description**: تقوم هذه الوظيفة باختبار استعلام SQL يتم إنشاؤه باستخدام مكتبة SQLAlchemy. يتم استخدام الدالة `select` لإنشاء استعلام يقوم بحساب الترتيب (`rank`) للصفوف التي تحقق شرطًا معينًا (`filter`)، حيث يتم تطبيق الشرط `table1.c.name > "foo"`. يتم تحديد نطاق النافذة (`range_=(1, 5)`) بحيث يتم حساب الترتيب بناءً على نطاق يبدأ من 1 ويصل إلى 5. بالإضافة إلى ذلك، يتم تقسيم النتائج إلى أقسام (`partition_by`) بناءً على العمود `description`.

يتم استخدام الدالة `assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع الاستعلام المتوقع. الناتج المتوقع هو استعلام SQL يحتوي على `FILTER` و`OVER` مع تحديد النطاق (`RANGE BETWEEN`) والأقسام (`PARTITION BY`). يتم أيضًا التحقق من المعلمات (`checkparams`) التي تم تمريرها إلى الاستعلام، مثل `name_1` و`param_1` و`param_2`.

**Note**: يجب التأكد من أن الجدول `mytable` يحتوي على الأعمدة `name` و`description` حتى يعمل الاستعلام بشكل صحيح. كما يجب فهم كيفية عمل وظائف التصفية (`filter`) والنوافذ (`windowing`) في SQLAlchemy لضمان استخدامها بشكل صحيح.
***
### FunctionDef test_funcfilter_windowing_range_positional(self)
**test_funcfilter_windowing_range_positional**: وظيفة `test_funcfilter_windowing_range_positional` هي اختبار وظيفة ترشيح (`filter`) مع نافذة (`window`) باستخدام النطاق (`range`) والموضع (`positional`) في استعلام SQL.

**parameters**: لا تحتوي هذه الوظيفة على معاملات محددة يتم تمريرها إليها بشكل مباشر، حيث إنها تعتمد على البيانات والمتغيرات المحددة داخل الكود نفسه.

**Code Description**: تقوم هذه الوظيفة باختبار عملية تجميع استعلام SQL باستخدام وظيفة `rank()` مع تطبيق مرشح (`filter`) ونافذة (`window`) محددة. يتم استخدام `func.rank()` لحساب الترتيب، ويتم تطبيق مرشح (`filter`) بحيث يتم تضمين الصفوف التي تحقق الشرط `table1.c.name > "foo"`. يتم تحديد نطاق النافذة (`range_=(1, 5)`) بحيث يتم حساب الترتيب بناءً على نطاق يبدأ من 1 وينتهي عند 5. بالإضافة إلى ذلك، يتم تقسيم النتائج إلى أقسام (`partition_by=["description"]`) بناءً على عمود `description`.

يتم استخدام الدالة `self.assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع. النص المتوقع للاستعلام هو:
```sql
SELECT rank() FILTER (WHERE mytable.name > ?) 
OVER (PARTITION BY mytable.description RANGE BETWEEN ? 
FOLLOWING AND ? FOLLOWING) 
AS anon_1 FROM mytable
```
حيث يتم التحقق من أن المعاملات الموضعية (`checkpositional`) هي `("foo", 1, 5)`، ويتم استخدام `dialect="default_qmark"` لتحديد طريقة عرض المعاملات في الاستعلام.

**Note**: يجب التأكد من أن الجدول `table1` والأعمدة المذكورة (`name` و `description`) موجودة ومحددة بشكل صحيح في قاعدة البيانات. كما يجب التأكد من أن النطاق المحدد (`range_=(1, 5)`) يتوافق مع المتطلبات المنطقية للاستعلام.
***
### FunctionDef test_funcfilter_windowing_rows(self)
**test_funcfilter_windowing_rows**: وظيفة `test_funcfilter_windowing_rows` هي التحقق من صحة عملية التجميع (compile) لاستعلام SQL الذي يستخدم وظيفة التصفية (filter) ونافذة الصفوف (windowing rows) في قاعدة البيانات.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة يتم تمريرها إليها بشكل مباشر. بدلاً من ذلك، تعتمد على الدالة `self.assert_compile` للتحقق من صحة الاستعلام.

**Code Description**: تقوم هذه الدالة باختبار عملية إنشاء استعلام SQL باستخدام الوظيفة `func.rank()` مع تطبيق فلتر (`filter`) ونافذة صفوف (`windowing rows`). يتم إنشاء الاستعلام باستخدام الجدول `table1` والعمود `name`، حيث يتم تطبيق شرط `name > "foo"` داخل الفلتر. بالإضافة إلى ذلك، يتم تحديد نافذة الصفوف باستخدام `rows=(1, 5)`، مما يعني أن النافذة ستشمل الصفوف من الصف التالي (1) إلى الصف الخامس التالي (5). كما يتم تقسيم النتائج حسب العمود `description` باستخدام `partition_by=["description"]`.

يتم بعد ذلك استخدام الدالة `self.assert_compile` للتحقق من أن الاستعلام الذي تم إنشاؤه يتطابق مع النص المتوقع للاستعلام SQL. النص المتوقع للاستعلام هو:
```
SELECT rank() FILTER (WHERE mytable.name > :name_1) 
OVER (PARTITION BY mytable.description ROWS BETWEEN :param_1 
FOLLOWING AND :param_2 FOLLOWING) 
AS anon_1 FROM mytable
```
حيث يتم التحقق من أن الاستعلام الذي تم إنشاؤه يتطابق مع هذا النص بالضبط.

**Note**: يجب التأكد من أن الجدول `table1` والعمود `name` والعمود `description` موجودة في قاعدة البيانات وأنها متوافقة مع الاستعلام الذي يتم اختباره. كما يجب أن تكون الوظيفة `func.rank()` مدعومة في نظام إدارة قواعد البيانات المستخدم.
***
### FunctionDef test_funcfilter_more_criteria(self)
**test_funcfilter_more_criteria**: وظيفة `test_funcfilter_more_criteria` هي اختبار وظيفة التصفية (filter) باستخدام معايير متعددة على دالة الترتيب (rank) في SQL.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة يتم تمريرها إليها مباشرةً، حيث إنها تعتمد على الكائن `self` الذي يمثل حالة الاختبار الحالية.

**Code Description**: 
- تقوم الوظيفة بإنشاء كائن `ff` باستخدام دالة `func.rank()` والتي تمثل دالة الترتيب في SQL، ثم يتم تطبيق عامل التصفية (filter) على العمود `name` من الجدول `table1` بحيث يتم اختيار القيم التي تكون أكبر من القيمة النصية `"foo"`.
- بعد ذلك، يتم إنشاء كائن `ff2` عن طريق تطبيق عامل تصفية إضافي على الكائن `ff`، حيث يتم تصفية القيم بناءً على العمود `myid` بحيث تكون القيمة مساوية لـ `1`.
- يتم استخدام الدالة `self.assert_compile` لاختبار ما إذا كان الاستعلام الذي تم إنشاؤه يتطابق مع الاستعلام المتوقع. الاستعلام المتوقع يقوم باختيار دالة الترتيب مع التصفية المطبقة على العمودين `name` و `myid`، ويتم التحقق من أن النص الناتج للاستعلام يتطابق مع النص المحدد.
- النص المتوقع للاستعلام هو:
  ```sql
  SELECT rank() FILTER (WHERE mytable.name > :name_1) AS anon_1, 
         rank() FILTER (WHERE mytable.name > :name_1 AND mytable.myid = :myid_1) AS anon_2 
  FROM mytable
  ```
  حيث يتم تمرير القيم `:name_1` و `:myid_1` كمعاملات للاستعلام.

**Note**: 
- يجب التأكد من أن الجدول `table1` والأعمدة `name` و `myid` موجودة ومحددة بشكل صحيح في قاعدة البيانات.
- يتم استخدام الدالة `assert_compile` للتحقق من صحة بناء الاستعلام، مما يعني أن الاختبار يتحقق من أن الكود يولد الاستعلام الصحيح وليس من تنفيذه الفعلي على قاعدة البيانات.
***
### FunctionDef test_funcfilter_within_group(self)
**test_funcfilter_within_group**: وظيفة `test_funcfilter_within_group` هي اختبار استخدام الدالة `func.rank()` مع الفلتر `filter` وترتيب البيانات باستخدام `within_group` في استعلام SQL.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على `self` كجزء من فئة الاختبار (test class).

**Code Description**: تقوم هذه الدالة باختبار عملية تجميع واستخدام الدوال في استعلام SQL باستخدام مكتبة SQLAlchemy. يتم إنشاء استعلام SQL باستخدام الدالة `select`، حيث يتم تطبيق الدالة `func.rank()` والتي تُستخدم لحساب الترتيب. يتم تطبيق فلتر (`filter`) على النتائج بحيث يتم تضمين الصفوف التي تحتوي على قيمة في العمود `name` أكبر من القيمة النصية `"foo"`. بعد ذلك، يتم استخدام `within_group` لترتيب النتائج بناءً على العمود `name` من الجدول `table1`.

يتم بعد ذلك مقارنة الاستعلام الذي تم إنشاؤه مع النص المتوقع للاستعلام باستخدام الدالة `assert_compile`. النص المتوقع للاستعلام هو:
```sql
SELECT rank() FILTER (WHERE mytable.name > :name_1) WITHIN GROUP (ORDER BY mytable.name) AS anon_1 FROM mytable
```
حيث يتم التحقق من أن الاستعلام الذي تم إنشاؤه يتطابق مع هذا النص.

**Note**: 
- يتم استخدام `func.rank()` لحساب الترتيب، ويمكن استخدامها مع `filter` و `within_group` لتحقيق نتائج محددة.
- يجب التأكد من أن الجدول `table1` يحتوي على العمود `name` حتى يعمل الاستعلام بشكل صحيح.
- هذه الدالة جزء من فئة اختبار (test class) وتستخدم للتحقق من صحة بناء استعلامات SQL باستخدام SQLAlchemy.
***
### FunctionDef test_within_group(self)
**test_within_group**: وظيفة `test_within_group` هي اختبار استخدام دالة `percentile_cont` مع عبارة `WITHIN GROUP` في استعلام SQL.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذها مباشرة على الكائن الحالي (`self`).

**Code Description**:  
تقوم هذه الدالة بإنشاء استعلام SQL باستخدام مكتبة SQLAlchemy. يتم استخدام الدالة `select` لإنشاء استعلام يختار عمود `myid` من الجدول `table1`، بالإضافة إلى حساب النسبة المئوية (percentile) باستخدام الدالة `percentile_cont` مع القيمة `0.5` كمعامل. يتم تطبيق الدالة `percentile_cont` على العمود `name` من الجدول `table1` باستخدام عبارة `WITHIN GROUP` التي تعمل على ترتيب القيم في العمود `name` قبل حساب النسبة المئوية.

بعد ذلك، يتم استخدام الدالة `assert_compile` للتحقق من أن الاستعلام الذي تم إنشاؤه يتطابق مع النص المتوقع للاستعلام SQL. النص المتوقع للاستعلام هو:  
```sql
SELECT mytable.myid, percentile_cont(:percentile_cont_1) WITHIN GROUP (ORDER BY mytable.name) AS anon_1 FROM mytable
```  
حيث يتم تمرير القيمة `0.5` كمعامل للدالة `percentile_cont`.

**Note**:  
- يتم استخدام هذه الدالة بشكل أساسي في اختبارات SQLAlchemy للتحقق من صحة بناء الاستعلامات التي تحتوي على دالات تجميعية مع عبارة `WITHIN GROUP`.
- يجب التأكد من أن الجدول `table1` والأعمدة `myid` و `name` موجودة ومحددة بشكل صحيح في قاعدة البيانات قبل تنفيذ هذا الاختبار.
***
### FunctionDef test_within_group_multi(self)
**test_within_group_multi**: وظيفة `test_within_group_multi` تهدف إلى اختبار استعلام SQL الذي يستخدم الدالة `percentile_cont` مع خاصية `WITHIN GROUP` لفرز البيانات بناءً على عمودين.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث إنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى الكائن الحالي.

**Code Description**:  
تقوم هذه الدالة بإنشاء استعلام SQL باستخدام مكتبة SQLAlchemy. يتم تحديد عمود `myid` من الجدول `table1`، بالإضافة إلى حساب النسبة المئوية باستخدام الدالة `percentile_cont(0.5)` مع خاصية `WITHIN GROUP`. يتم ترتيب النتائج بناءً على عمودين هما `name` و `description` من الجدول `table1`.  

بعد ذلك، يتم استخدام الدالة `self.assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع النص المتوقع للاستعلام. النص المتوقع للاستعلام هو:  
```sql
SELECT mytable.myid, percentile_cont(:percentile_cont_1) 
WITHIN GROUP (ORDER BY mytable.name, mytable.description) 
AS anon_1 
FROM mytable
```
حيث يتم تمرير القيمة `0.5` كمعامل للدالة `percentile_cont`.  

الهدف من هذا الاختبار هو التأكد من أن الاستعلام الذي يتم إنشاؤه يتطابق مع النص المتوقع للاستعلام، مما يضمن صحة بناء الجملة (syntax) والمنطق المستخدم.

**Note**:  
- يُستخدم هذا النوع من الاختبارات عادةً في مشاريع قواعد البيانات للتحقق من صحة استعلامات SQL المعقدة.  
- يجب التأكد من أن الجدول `table1` والأعمدة `myid`، `name`، و `description` موجودة ومُعرَّفة بشكل صحيح في قاعدة البيانات.  
- القيمة `0.5` المُمررة إلى `percentile_cont` تعني حساب الوسيط (median) للبيانات.
***
### FunctionDef test_within_group_desc(self)
**test_within_group_desc**: وظيفة `test_within_group_desc` هي اختبار عملية تجميع البيانات باستخدام دالة `percentile_cont` مع ترتيب تنازلي داخل مجموعة محددة.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على الكائن الحالي (`self`) فقط.

**Code Description**: تقوم هذه الدالة بإنشاء استعلام SQL باستخدام مكتبة SQLAlchemy. يتم تحديد عمودين في الاستعلام: الأول هو `myid` من الجدول `table1`، والثاني هو نتيجة تطبيق دالة `percentile_cont` مع قيمة `0.5` كمعامل، وذلك مع ترتيب القيم في العمود `name` تنازليًا باستخدام `within_group(table1.c.name.desc())`. 

بعد ذلك، يتم استخدام الدالة `assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع للاستعلام SQL. النص المتوقع يتضمن تحديد العمود `myid`، واستخدام دالة `percentile_cont` مع القيمة `0.5`، وترتيب القيم في العمود `name` تنازليًا داخل المجموعة. كما يتم التحقق من أن المعاملات الممررة إلى الاستعلام صحيحة، حيث يتم تمرير القيمة `0.5` كمعامل للدالة `percentile_cont`.

**Note**: 
- تأكد من أن الجدول `table1` يحتوي على الأعمدة `myid` و`name` حتى يعمل الاستعلام بشكل صحيح.
- الدالة `percentile_cont` تستخدم لحساب النسبة المئوية التراكمية (percentile) للقيم داخل مجموعة محددة، مع إمكانية ترتيبها تصاعديًا أو تنازليًا.
- يتم استخدام `within_group` لتحديد ترتيب القيم داخل المجموعة قبل تطبيق الدالة الإحصائية.
***
### FunctionDef test_within_group_w_over(self)
**test_within_group_w_over**: وظيفة `test_within_group_w_over` هي اختبار عملية تجميع البيانات باستخدام دالة `percentile_cont` مع ترتيب داخلي (`WITHIN GROUP`) وتقسيم (`OVER`) في استعلام SQL.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على البيانات المحددة مسبقًا في الكائن `table1`.

**Code Description**: تقوم هذه الوظيفة بإنشاء استعلام SQL باستخدام مكتبة SQLAlchemy. يتم تحديد الأعمدة `myid` و `name` و `description` من الجدول `table1`. يتم استخدام الدالة `percentile_cont` مع قيمة `0.5` لحساب النسبة المئوية التراكمية (percentile) للقيم في العمود `name` مع ترتيب تنازلي (`DESC`). يتم تطبيق التقسيم (`PARTITION BY`) على العمود `description`، مما يعني أن العملية ستتم بشكل منفصل لكل مجموعة من القيم المتشابهة في هذا العمود.

يتم بعد ذلك استخدام الدالة `assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع النص المتوقع للاستعلام. النص المتوقع يتضمن:
- تحديد العمود `myid`.
- استخدام دالة `percentile_cont` مع القيمة `0.5`.
- ترتيب القيم داخل المجموعة (`WITHIN GROUP`) بناءً على العمود `name` بترتيب تنازلي.
- تقسيم النتائج (`OVER`) بناءً على العمود `description`.

يتم أيضًا التحقق من أن القيمة `0.5` يتم تمريرها بشكل صحيح كمعامل للدالة `percentile_cont`.

**Note**: 
- تأكد من أن الجدول `table1` يحتوي على الأعمدة `myid`، `name`، و `description` قبل استخدام هذه الوظيفة.
- هذه الوظيفة مخصصة للاختبار، لذا يجب استخدامها في سياق اختبار وحدات (unit testing) وليس في الكود الرئيسي للتطبيق.
***
### FunctionDef test_within_group_filter(self)
**test_within_group_filter**: وظيفة `test_within_group_filter` هي اختبار استخدام دالة `percentile_cont` مع `WITHIN GROUP` و `FILTER` في استعلام SQL.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) لأنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى الكائن الحالي.

**Code Description**: تقوم هذه الدالة بإنشاء استعلام SQL باستخدام مكتبة SQLAlchemy. يتم استخدام الدالة `select` لإنشاء استعلام يختار العمود `myid` من الجدول `table1`، بالإضافة إلى حساب النسبة المئوية (percentile) باستخدام الدالة `percentile_cont` مع القيمة `0.5`. يتم تطبيق شرط `WITHIN GROUP` لترتيب النتائج بناءً على العمود `name` في الجدول `table1`. كما يتم تطبيق شرط `FILTER` لتصفية النتائج بحيث يتم تضمين الصفوف التي يكون فيها العمود `myid` أكبر من `42`.

بعد ذلك، يتم استخدام الدالة `self.assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع النص المتوقع للاستعلام SQL. يتم التحقق من أن الاستعلام المترجم يتطابق مع النص التالي:
```sql
SELECT mytable.myid, percentile_cont(:percentile_cont_1) 
WITHIN GROUP (ORDER BY mytable.name) 
FILTER (WHERE mytable.myid > :myid_1) 
AS anon_1 
FROM mytable
```
حيث يتم تمرير القيم `0.5` و `42` كمعاملات للاستعلام.

**Note**: 
- هذه الدالة مخصصة للاختبار وتتحقق من أن بناء الاستعلام باستخدام `WITHIN GROUP` و `FILTER` يعمل بشكل صحيح.
- يتم استخدام `self.assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع، مما يضمن أن الكود يعمل كما هو متوقع في بيئة SQLAlchemy.
***
### FunctionDef test_incorrect_none_type(self)
**test_incorrect_none_type**: وظيفة `test_incorrect_none_type` هي اختبار حالة عدم صحة النوع `None` عند استخدامه مع كائن `FunctionElement` في SQLAlchemy.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.

**Code Description**:  
تقوم هذه الدالة باختبار حالة عدم صحة النوع `None` عند استخدامه مع كائن `FunctionElement` في SQLAlchemy. يتم ذلك من خلال الخطوات التالية:

1. يتم استيراد الفئة `FunctionElement` من وحدة `sqlalchemy.sql.expression`.
2. يتم تعريف فئة جديدة تسمى `MissingType` والتي ترث من `FunctionElement`. تحتوي هذه الفئة على خاصية `name` بقيمة `"mt"`، وخاصية `type` بقيمة `None`.
3. يتم استخدام الدالة `assert_raises_message` للتحقق من أن استخدام `MissingType` مع عمود (`column`) سيؤدي إلى رفع استثناء من نوع `TypeError`. الرسالة المتوقعة للاستثناء هي:  
   `"Object None associated with '.type' attribute is not a TypeEngine class or object"`.
4. يتم تنفيذ عملية مقارنة بين عمود (`column`) تم إنشاؤه باستخدام `MissingType` والقيمة `5`. يتم تغليف هذه العملية داخل دالة `lambda` لتمريرها إلى `assert_raises_message`.

**Note**:  
- هذه الدالة تهدف إلى اختبار سلوك SQLAlchemy عند استخدام نوع غير صالح (`None`) مع كائن `FunctionElement`.  
- يجب أن تكون الرسالة المرفوعة مع الاستثناء مطابقة تمامًا للرسالة المتوقعة لضمان نجاح الاختبار.  
- هذه الدالة مفيدة في التأكد من أن SQLAlchemy يرفض بشكل صحيح الأنواع غير الصالحة في سياق `FunctionElement`.
#### ClassDef MissingType
**MissingType**: وظيفة MissingType هي تمثيل عنصر وظيفي (FunctionElement) يحتوي على اسم ونوع غير محدد (None).

**attributes**: السمات الخاصة بهذا الكلاس.
· name: اسم العنصر، وهو "mt" في هذه الحالة.
· type: نوع العنصر، وهو غير محدد (None) في هذه الحالة.

**Code Description**:  
يُعتبر MissingType كلاسًا يرث من FunctionElement، مما يعني أنه يمثل عنصرًا وظيفيًا يمكن استخدامه في سياقات مختلفة. يحتوي هذا الكلاس على سمتين رئيسيتين:  
1. **name**: وهو اسم العنصر، ويتم تعيينه إلى القيمة "mt". هذا الاسم يمكن استخدامه لتحديد العنصر في السياقات التي يتم استخدامه فيها.  
2. **type**: وهو نوع العنصر، ويتم تعيينه إلى None، مما يعني أن النوع غير محدد أو غير معروف في هذه الحالة.  

هذا الكلاس يمكن أن يكون مفيدًا في الحالات التي تحتاج إلى تمثيل عنصر وظيفي بدون تحديد نوع محدد، أو عندما يكون النوع غير معروف أو غير مهم في السياق الحالي.

**Note**:  
- عند استخدام هذا الكلاس، يجب الانتباه إلى أن النوع غير محدد (None)، مما قد يتطلب معالجة خاصة في السياقات التي تعتمد على معرفة نوع العنصر.  
- يمكن استخدام هذا الكلاس كعنصر أساسي في هياكل بيانات أو أنظمة تحتاج إلى تمثيل عناصر ذات أنواع غير محددة.
***
***
### FunctionDef test_as_comparison(self)
**test_as_comparison**: وظيفة `test_as_comparison` هي اختبار وظيفة `as_comparison` المستخدمة لتحويل دالة إلى تعبير مقارنة والتحقق من نوعها وتأكيد صحة الترجمة البرمجية (compilation) للتعابير الناتجة.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على `self` كمعامل ضمني يشير إلى نسخة الكائن الحالي.

**Code Description**: 
1. تقوم الدالة بإنشاء تعبير `fn` باستخدام الدالة `func.substring` التي تأخذ معاملين: الأول هو النص المطلوب البحث عنه (`"foo"`) والثاني هو النص الذي يتم البحث فيه (`"foobar"`). يتم تحويل هذا التعبير إلى تعبير مقارنة باستخدام الدالة `as_comparison(1, 2)`، حيث يتم تحديد مواضع المعاملات في التعبير النهائي.
   
2. يتم التحقق من أن نوع التعبير الناتج (`fn.type._type_affinity`) هو من النوع `Boolean`، مما يؤكد أن التعبير يعتبر تعبيرًا منطقيًا (مقارنة).

3. يتم استخدام الدالة `self.assert_compile` للتحقق من صحة الترجمة البرمجية للأجزاء المختلفة للتعبير:
   - يتم التحقق من الجزء الأيسر (`fn.left`) للتأكد من أنه يترجم إلى `:substring_1` مع التحقق من أن المعامل `substring_1` يساوي `"foo"`.
   - يتم التحقق من الجزء الأيمن (`fn.right`) للتأكد من أنه يترجم أيضًا إلى `:substring_1` مع التحقق من أن المعامل `substring_1` يساوي `"foobar"`.
   - أخيرًا، يتم التحقق من التعبير الكامل (`fn`) للتأكد من أنه يترجم إلى `"substring(:substring_1, :substring_2)"` مع التحقق من أن المعاملات `substring_1` و `substring_2` تساوي `"foo"` و `"foobar"` على التوالي.

**Note**: 
- هذه الدالة مخصصة للاختبارات (testing) وتستخدم للتحقق من صحة الترجمة البرمجية للتعابير الناتجة عن استخدام `as_comparison`.
- يجب التأكد من أن الدالة `func.substring` والدالة `as_comparison` تعملان بشكل صحيح قبل استخدام هذه الدالة.
***
### FunctionDef test_as_comparison_annotate(self)
**test_as_comparison_annotate**: وظيفة `test_as_comparison_annotate` تهدف إلى اختبار عملية إضافة التعليقات التوضيحية (annotations) إلى كائن دالة تم إنشاؤها باستخدام `as_comparison`، والتأكد من أن التعليقات التوضيحية يتم تطبيقها بشكل صحيح على الأجزاء المحددة من الكائن.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة يتم تمريرها إليها مباشرةً، حيث إنها تعتمد على كائن `self` الذي يتم تمريره تلقائيًا في سياق اختبار وحدة (unit test).

**Code Description**: 
1. يتم إنشاء كائن دالة `fn` باستخدام `func.foobar` مع تمرير مجموعة من القيم النصية ("x", "y", "q", "p", "r")، ثم يتم تحويل هذه الدالة إلى كائن مقارنة (comparison object) باستخدام `as_comparison(2, 5)`. هذه العملية تحدد مواضع معينة في الدالة لتكون جزءًا من المقارنة.

2. يتم استيراد وظيفة `_deep_annotate` من وحدة `sqlalchemy.sql.annotation`. هذه الوظيفة تُستخدم لإضافة تعليقات توضيحية (annotations) إلى الكائن بشكل متعمق (deep annotation).

3. يتم تطبيق التعليقات التوضيحية على الكائن `fn` باستخدام `_deep_annotate`، حيث يتم تمرير الكائن `fn` وقاموس يحتوي على التعليقات التوضيحية المطلوبة (`{"token": "yes"}`). النتيجة هي كائن جديد `fn_annotated` يحتوي على التعليقات التوضيحية المضافة.

4. يتم استخدام الدالة `eq_` للتحقق من أن الجزء الأيسر (`left`) من الكائن `fn` لا يحتوي على أي تعليقات توضيحية (`_annotations` فارغ). ثم يتم التحقق من أن الجزء الأيسر من الكائن `fn_annotated` يحتوي على التعليقات التوضيحية المضافة (`{"token": "yes"}`).

**Note**: 
- هذه الدالة مخصصة للاستخدام في اختبارات الوحدة (unit tests) للتأكد من أن عملية إضافة التعليقات التوضيحية تعمل بشكل صحيح.
- يجب التأكد من أن الوظيفة `_deep_annotate` متاحة في السياق الذي يتم فيه تشغيل الاختبار، حيث إنها جزء من مكتبة `SQLAlchemy`.
- التعليقات التوضيحية تُستخدم عادةً لإضافة بيانات وصفية إضافية إلى الكائنات، والتي يمكن استخدامها لاحقًا في عمليات أخرى مثل الترجمة أو التخصيص.
***
### FunctionDef test_as_comparison_many_argument(self)
**test_as_comparison_many_argument**: وظيفة `test_as_comparison_many_argument` هي اختبار وظيفة `as_comparison` مع العديد من الوسائط لضمان عملها بشكل صحيح في سياق المقارنات المعقدة.  
**parameters**: لا تحتوي هذه الوظيفة على أي وسائط مباشرة، حيث يتم تنفيذها كجزء من فئة الاختبار.  

**Code Description**:  
تقوم هذه الوظيفة باختبار سلوك وظيفة `as_comparison` عند استخدامها مع العديد من الوسائط. يتم ذلك من خلال الخطوات التالية:  

1. يتم إنشاء دالة `fn` باستخدام `func.some_comparison` مع ستة وسائط ("x", "y", "z", "p", "q", "r")، ثم يتم تطبيق `as_comparison` مع وسيطين (2, 5). يتم التحقق من أن نوع الناتج (`fn.type._type_affinity`) هو `Boolean`.  

2. يتم التحقق من ترجمة (`compile`) الجزء الأيسر (`fn.left`) والجزء الأيمن (`fn.right`) من الدالة باستخدام `self.assert_compile`. يتم التأكد من أن القيم المترجمة تتطابق مع القيم المتوقعة (`:some_comparison_1`) ومعلمات التحقق (`checkparams`).  

3. يتم إنشاء نسخة من الدالة `fn` باستخدام `visitors.cloned_traverse` وتعديل الجزء الأيمن (`fn_2.right`) ليكون `literal_column("ABC")`.  

4. يتم التحقق من ترجمة الدالة الأصلية (`fn`) والدالة المعدلة (`fn_2`) باستخدام `self.assert_compile`، مع التأكد من أن الناتج يتطابق مع التوقعات ومعلمات التحقق.  

**Note**:  
- هذه الوظيفة تعتمد على مكتبة `sqlalchemy` لتنفيذ عمليات الترجمة والتحقق.  
- يتم استخدام `visitors.cloned_traverse` لإنشاء نسخة من الدالة دون تغيير الدالة الأصلية.  
- يجب التأكد من أن القيم والمعلمات المستخدمة في الاختبار تتوافق مع التوقعات المحددة في الكود.
***
## ClassDef ReturnTypeTest
**ReturnTypeTest**: وظيفة الفئة ReturnTypeTest هي اختبار أنواع القيم المرتجعة للدوال المستخدمة في SQL مع التأكد من أن أنواع البيانات المرتجعة تتوافق مع التوقعات.

**attributes**: لا تحتوي هذه الفئة على أي attributes محددة، حيث أنها تركز على اختبار الدوال وليس تخزين البيانات.

**Code Description**: 
تعتبر فئة ReturnTypeTest جزءًا من اختبارات قاعدة البيانات، حيث تقوم بفحص أنواع القيم المرتجعة من الدوال المستخدمة في SQL مثل `array_agg`، `mode`، `percentile_cont`، `cume_dist`، و `percent_rank`. يتم ذلك من خلال التأكد من أن نوع البيانات المرتجع يتوافق مع النوع المتوقع باستخدام الدوال المساعدة مثل `is_` و `eq_`.

1. **test_array_agg**: تختبر هذه الدالة نوع القيمة المرتجعة من الدالة `array_agg` عند استخدامها مع عمود من نوع `Integer`. يتم التأكد من أن النوع المرتجع هو `ARRAY` وأن نوع العناصر داخل المصفوفة هو `Integer`.

2. **test_array_agg_array_datatype**: تختبر هذه الدالة `array_agg` عند استخدامها مع عمود من نوع `ARRAY(Integer)`. يتم التأكد من أن النوع المرتجع هو `ARRAY` وأن عدد الأبعاد يتوافق مع العمود الأصلي.

3. **test_array_agg_array_literal_implicit_type**: تختبر هذه الدالة `array_agg` عند استخدامها مع مصفوفة تحتوي على أعمدة من نوع `Integer`. يتم التأكد من أن النوع المرتجع هو `PG_ARRAY` وأن نوع العناصر داخل المصفوفة هو `Integer`.

4. **test_array_agg_array_literal_explicit_type**: تختبر هذه الدالة `array_agg` مع تحديد نوع المصفوفة بشكل صري. يتم التأكد من أن النوع المرتجع هو `ARRAY` وأن نوع العناصر داخل المصفوفة هو `Integer`.

5. **test_mode**: تختبر هذه الدالة نوع القيمة المرتجعة من الدالة `mode` عند استخدامها مع عمود من نوع `Integer`. يتم التأكد من أن النوع المرتجع هو `Integer`.

6. **test_percentile_cont**: تختبر هذه الدالة نوع القيمة المرتجعة من الدالة `percentile_cont` عند استخدامها مع عمود من نوع `Integer`. يتم التأكد من أن النوع المرتجع هو `Integer`.

7. **test_percentile_cont_array**: تختبر هذه الدالة `percentile_cont` عند استخدامها مع قيم متعددة. يتم التأكد من أن النوع المرتجع هو `ARRAY` وأن نوع العناصر داخل المصفوفة هو `Integer`.

8. **test_percentile_cont_array_desc**: تختبر هذه الدالة `percentile_cont` مع ترتيب تنازلي للعمود. يتم التأكد من أن النوع المرتجع هو `ARRAY` وأن نوع العناصر داخل المصفوفة هو `Integer`.

9. **test_cume_dist**: تختبر هذه الدالة نوع القيمة المرتجعة من الدالة `cume_dist`. يتم التأكد من أن النوع المرتجع هو `Numeric`.

10. **test_percent_rank**: تختبر هذه الدالة نوع القيمة المرتجعة من الدالة `percent_rank`. يتم التأكد من أن النوع المرتجع هو `Numeric`.

**Note**: 
- يجب التأكد من أن أنواع البيانات المستخدمة في الاختبارات تتوافق مع أنواع البيانات المتوقعة في قاعدة البيانات.
- يتم استخدام الدوال المساعدة مثل `is_` و `eq_` للتحقق من صحة النتائج.
- يتم استخدام `self.assert_compile` للتحقق من صحة بناء جملة SQL الناتجة.
### FunctionDef test_array_agg(self)
**test_array_agg**: وظيفة `test_array_agg` هي اختبار وظيفة `array_agg` للتأكد من أنها تعيد نوع بيانات صحيح من نوع `ARRAY` مع عناصر من نوع `Integer`.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة يتم تمريرها إليها بشكل مباشر.

**Code Description**: 
- تقوم الوظيفة بإنشاء تعبير (expression) باستخدام الدالة `func.array_agg` والتي تأخذ عمودًا (column) من نوع `Integer` كمدخل. العمود المحدد هنا هو `data` من نوع `Integer`.
- يتم بعد ذلك التحقق من أن نوع البيانات الناتج من التعبير (`expr.type._type_affinity`) هو من نوع `ARRAY`، مما يعني أن النتيجة هي مصفوفة (array).
- يتم أيضًا التحقق من أن نوع العناصر داخل المصفوفة (`expr.type.item_type._type_affinity`) هو من نوع `Integer`، مما يؤكد أن جميع العناصر داخل المصفوفة هي أعداد صحيحة.
- أخيرًا، يتم التحقق من أن عدد أبعاد المصفوفة (`expr.type.dimensions`) هو 1، مما يعني أن المصفوفة أحادية البعد.

**Note**: 
- هذه الوظيفة تستخدم بشكل أساسي لأغراض الاختبار (testing) للتأكد من أن الدالة `array_agg` تعمل بشكل صحيح وتعيد النتائج المتوقعة.
- يجب أن يكون العمود الممرر إلى `array_agg` من نوع `Integer` لضمان صحة النتائج.
***
### FunctionDef test_array_agg_array_datatype(self)
**test_array_agg_array_datatype**: وظيفة `test_array_agg_array_datatype` هي التحقق من أن دالة التجميع `array_agg` تعمل بشكل صحيح مع نوع بيانات مصفوفة (ARRAY) وتتحقق من أن نوع البيانات الناتج يتوافق مع التوقعات.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة يتم تمريرها إليها مباشرةً، حيث إنها تعتمد على المتغيرات التي يتم تعريفها داخلها.

**Code Description**: 
1. يتم تعريف عمود (column) باسم `"data"` من نوع `ARRAY` يحتوي على عناصر من نوع `Integer`. يتم تخزين هذا العمود في المتغير `col`.
2. يتم استخدام دالة التجميع `array_agg` على العمود `col`، ويتم تخزين النتيجة في المتغير `expr`.
3. يتم التحقق من أن نوع البيانات الناتج (`expr.type._type_affinity`) هو `ARRAY` باستخدام الدالة `is_`.
4. يتم التحقق من أن نوع العناصر داخل المصفوفة (`expr.type.item_type._type_affinity`) هو `Integer` باستخدام الدالة `is_`.
5. يتم التحقق من أن أبعاد المصفوفة (`expr.type.dimensions`) تتطابق مع أبعاد العمود الأصلي (`col.type.dimensions`) باستخدام الدالة `eq_`.

**Note**: 
- هذه الوظيفة تُستخدم بشكل أساسي في اختبارات الوحدة (unit tests) للتحقق من أن دالة التجميع `array_agg` تعمل بشكل صحيح مع أنواع البيانات المعقدة مثل المصفوفات.
- يجب التأكد من أن أنواع البيانات المستخدمة في العمود (`col`) متوافقة مع التوقعات قبل تنفيذ الاختبار.
***
### FunctionDef test_array_agg_array_literal_implicit_type(self)
**test_array_agg_array_literal_implicit_type**: وظيفة `test_array_agg_array_literal_implicit_type` هي اختبار وظيفة `array_agg` مع تعبير مصفوفة يحتوي على أعمدة من نوع `Integer`، والتحقق من أن النوع الناتج هو `PG_ARRAY` وأنه يتم تجميع البيانات بشكل صحيح.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة.

**Code Description**: 
- تقوم الوظيفة بإنشاء تعبير مصفوفة (`expr`) باستخدام الدالة `array` التي تحتوي على عمودين (`column`) من نوع `Integer`، وهما `data` و `d2`.
- يتم التحقق من أن نوع التعبير (`expr.type`) هو `PG_ARRAY` باستخدام `isinstance`.
- بعد ذلك، يتم تطبيق الدالة `array_agg` على التعبير `expr` للحصول على تعبير تجميع (`agg_expr`).
- يتم التحقق من أن نوع التعبير الناتج (`agg_expr.type`) هو أيضًا `PG_ARRAY`، وأن نوع العنصر الداخلي (`item_type`) لهذا التعبير هو `Integer`.
- أخيرًا، يتم استخدام `self.assert_compile` للتحقق من أن التعبير `agg_expr` يتم تجميعه بشكل صحيح إلى النص `"array_agg(ARRAY[data, d2])"` عند استخدام لغة SQL الخاصة بـ PostgreSQL.

**Note**: 
- هذه الوظيفة مخصصة للاختبار وتتحقق من أن الدالة `array_agg` تعمل بشكل صحيح مع تعبيرات المصفوفات التي تحتوي على أعمدة من نوع `Integer`.
- يتم استخدام `dialect="postgresql"` للتأكد من أن التجميع يتم وفقًا لقواعد PostgreSQL.
***
### FunctionDef test_array_agg_array_literal_explicit_type(self)
**test_array_agg_array_literal_explicit_type**: وظيفة `test_array_agg_array_literal_explicit_type` هي اختبار استخدام دالة `array_agg` مع تحديد نوع صريح للمصفوفة في SQLAlchemy.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على المتغيرات والكائنات التي يتم تعريفها داخلها.

**Code Description**: 
- يتم استيراد الدالة `array` من وحدة `sqlalchemy.dialects.postgresql` لإنشاء مصفوفة من الأعمدة (columns) في قاعدة البيانات.
- يتم تعريف تعبير (expression) باستخدام الدالة `array`، حيث يتم تمرير عمودين (`data` و `d2`) من النوع `Integer` كعناصر للمصفوفة.
- يتم استخدام الدالة `func.array_agg` لإنشاء تعبير تجميع (aggregation expression) للمصفوفة المحددة، مع تحديد نوع صريح للمصفوفة باستخدام `ARRAY(Integer)`.
- يتم التحقق من أن نوع التعبير الناتج (`agg_expr.type._type_affinity`) هو `ARRAY`، وأن نوع العناصر داخل المصفوفة (`agg_expr.type.item_type._type_affinity`) هو `Integer`.
- أخيرًا، يتم استخدام الدالة `self.assert_compile` للتحقق من أن التعبير المترجم إلى SQL يتطابق مع النص المتوقع `"array_agg(ARRAY[data, d2])"` عند استخدام لهجة (dialect) PostgreSQL.

**Note**: 
- هذه الوظيفة مخصصة للاختبار وتتحقق من صحة الترجمة إلى SQL عند استخدام `array_agg` مع تحديد نوع صريح للمصفوفة.
- يجب التأكد من أن أنواع الأعمدة المحددة (`Integer` في هذه الحالة) متوافقة مع التوقعات عند استخدام هذه الوظيفة في سياق قاعدة بيانات حقيقية.
***
### FunctionDef test_mode(self)
**test_mode**: وظيفة `test_mode` هي اختبار وظيفة `mode` من خلال التحقق من نوع البيانات الناتج عن التعبير الذي يتم إنشاؤه باستخدام هذه الوظيفة.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) حيث يتم تنفيذها مباشرة على الكائن الحالي (`self`).

**Code Description**: 
تقوم هذه الوظيفة بإنشاء تعبير (`expr`) باستخدام الدالة `mode` مع قيمة `0.5` كمعامل. يتم تطبيق الدالة `within_group` على هذا التعبير، حيث يتم تحديد عمود (`column`) باسم "data" من النوع `Integer`، ويتم ترتيبه تنازليًا باستخدام `desc()`. بعد ذلك، يتم التحقق من نوع البيانات الناتج عن هذا التعبير (`expr.type._type_affinity`) والتأكد من أنه من النوع `Integer` باستخدام الدالة `is_`.

**Note**: 
- هذه الوظيفة تستخدم بشكل أساسي في اختبارات الوحدة (unit tests) للتحقق من صحة نوع البيانات الناتج عن التعبيرات التي يتم إنشاؤها باستخدام الدالة `mode`.
- يجب التأكد من أن العمود "data" موجود وأنه من النوع `Integer` قبل تنفيذ هذه الوظيفة.
***
### FunctionDef test_percentile_cont(self)
**test_percentile_cont**: وظيفة `test_percentile_cont` هي اختبار وظيفة `percentile_cont` للتأكد من أن نوع البيانات الناتج يتوافق مع النوع المتوقع.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة يتم تمريرها إليها مباشرةً.

**Code Description**: تقوم هذه الدالة باختبار وظيفة `percentile_cont` التي تُستخدم لحساب النسبة المئوية المستمرة (continuous percentile) لقيم عمود معين. يتم ذلك عن طريق إنشاء تعبير (expression) باستخدام `func.percentile_cont(0.5)`، حيث يتم تحديد النسبة المئوية المطلوبة وهي 0.5 (أي الوسيط). ثم يتم استخدام `within_group` لتحديد العمود الذي سيتم تطبيق الحساب عليه، وهو العمود المسمى `data` من النوع `Integer`.

بعد ذلك، يتم التحقق من أن نوع البيانات الناتج من التعبير (`expr.type._type_affinity`) يتوافق مع النوع `Integer` باستخدام الدالة `is_`. هذه الخطوة تؤكد أن النوع الناتج من عملية حساب النسبة المئوية المستمرة هو النوع الصحيح المتوقع.

**Note**: 
- هذه الدالة مخصصة للاختبار ولا تُستخدم في الإنتاج.
- يجب التأكد من أن العمود `data` يحتوي على قيم من النوع `Integer` حتى تعمل الدالة بشكل صحيح.
- الدالة `is_` تُستخدم للتحقق من تطابق الكائنات، وهي جزء من مكتبة الاختبارات المستخدمة في هذا السياق.
***
### FunctionDef test_percentile_cont_array(self)
**test_percentile_cont_array**: وظيفة `test_percentile_cont_array` هي اختبار وظيفة `percentile_cont` للتأكد من أنها تُرجع نوع بيانات من نوع `ARRAY` وأن نوع العناصر داخل المصفوفة هو `Integer`.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة يتم تمريرها إليها مباشرةً، حيث إنها تعتمد على كائن `self` الذي يشير إلى الكائن الحالي في سياق الاختبار.

**Code Description**: 
تقوم هذه الوظيفة بإنشاء تعبير (expression) باستخدام الدالة `percentile_cont` من مكتبة `func`. يتم تحديد النسب المئوية `0.5` و `0.7` كمعاملات للدالة، ويتم تطبيقها على عمود (column) يسمى `data` من نوع `Integer` باستخدام الدالة `within_group`. 

بعد ذلك، يتم التحقق من نوع البيانات الذي يُرجع التعبير باستخدام `expr.type._type_affinity`، حيث يتم التأكد من أن النوع هو `ARRAY`. بالإضافة إلى ذلك، يتم التحقق من نوع العناصر داخل المصفوفة باستخدام `expr.type.item_type._type_affinity`، حيث يتم التأكد من أن نوع العناصر هو `Integer`.

**Note**: 
- هذه الوظيفة مخصصة للاختبار، لذا يجب استخدامها في سياق اختبار الوحدات (unit testing) للتأكد من أن الدالة `percentile_cont` تعمل بشكل صحيح وتُرجع النتائج المتوقعة.
- يجب التأكد من أن العمود `data` يحتوي على بيانات من النوع `Integer` حتى تعمل الوظيفة بشكل صحيح.
***
### FunctionDef test_percentile_cont_array_desc(self)
**test_percentile_cont_array_desc**: وظيفة `test_percentile_cont_array_desc` هي اختبار وظيفة `percentile_cont` مع تحديد ترتيب تنازلي للبيانات والتحقق من نوع الناتج.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على بيانات محددة مسبقًا داخل الكود.

**Code Description**: 
- تقوم الوظيفة بإنشاء تعبير (expression) باستخدام الدالة `percentile_cont` من مكتبة `func`. يتم تمرير القيمتين `0.5` و `0.7` كمعاملات للدالة، مما يعني حساب النسب المئوية (percentiles) لهذه القيم.
- يتم تحديد ترتيب البيانات تنازليًا باستخدام `within_group(column("data", Integer).desc())`، حيث يتم تحديد العمود `data` من النوع `Integer` وترتيبه تنازليًا.
- بعد ذلك، يتم التحقق من نوع الناتج باستخدام `is_`. يتم التأكد من أن نوع الناتج (`expr.type._type_affinity`) هو `ARRAY`، وأن نوع العناصر داخل المصفوفة (`expr.type.item_type._type_affinity`) هو `Integer`.

**Note**: 
- هذه الوظيفة مخصصة للاختبار (testing) وتتحقق من أن الدالة `percentile_cont` تعمل بشكل صحيح مع ترتيب تنازلي للبيانات وأن الناتج يكون من النوع المتوقع.
- يجب التأكد من أن البيانات المدخلة (`data`) متوافقة مع النوع `Integer` حتى تعمل الوظيفة بشكل صحيح.
***
### FunctionDef test_cume_dist(self)
**test_cume_dist**: وظيفة `test_cume_dist` هي اختبار وظيفة `cume_dist` في SQLAlchemy للتأكد من أن نوع الناتج يكون من النوع العددي (Numeric).

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة يتم تمريرها إليها مباشرةً.

**Code Description**: 
تقوم هذه الدالة بإنشاء تعبير (expression) باستخدام الدالة `cume_dist` من مكتبة SQLAlchemy. يتم تمرير القيمة `0.5` كمعامل للدالة `cume_dist`، والتي تُستخدم لحساب التوزيع التراكمي (cumulative distribution) للقيم في عمود معين. يتم تحديد العمود المستهدف باستخدام الدالة `column` مع تحديد اسم العمود كـ `"data"` ونوعه كـ `Integer`. يتم ترتيب القيم في العمود تنازليًا باستخدام `.desc()`.

بعد ذلك، يتم استخدام الدالة `within_group` لتحديد أن التعبير يجب أن يتم حسابه ضمن مجموعة معينة من الصفوف. أخيرًا، يتم التحقق من أن نوع الناتج (`expr.type._type_affinity`) يكون من النوع العددي (`Numeric`) باستخدام الدالة `is_` من مكتبة SQLAlchemy.

**Note**: 
- هذه الدالة تُستخدم بشكل أساسي في اختبارات الوحدة (unit tests) للتأكد من أن الدالة `cume_dist` تعمل بشكل صحيح وتُرجع النوع المتوقع من البيانات.
- يجب التأكد من أن العمود المحدد (`"data"`) موجود في الجدول وأنه من النوع `Integer` حتى تعمل الدالة بشكل صحيح.
***
### FunctionDef test_percent_rank(self)
**test_percent_rank**: وظيفة `test_percent_rank` هي اختبار دالة `percent_rank` للتأكد من أن نوع الناتج يكون من النوع العددي (Numeric).

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة يتم تمريرها إليها مباشرةً.

**Code Description**:  
تقوم هذه الدالة بإنشاء تعبير (expression) باستخدام الدالة `percent_rank` من مكتبة `func`. يتم تحديد القيمة `0.5` كقيمة يتم حساب الترتيب النسبي لها ضمن مجموعة البيانات. يتم استخدام الدالة `within_group` لتحديد أن الحساب يتم ضمن مجموعة البيانات المحددة بواسطة العمود `data` من النوع `Integer`.  

بعد ذلك، يتم التحقق من أن نوع الناتج (`expr.type._type_affinity`) يكون من النوع العددي (`Numeric`) باستخدام الدالة `is_`، والتي تقوم بمقارنة النوع الفعلي للناتج مع النوع المتوقع.  

**Note**:  
- هذه الدالة مخصصة للاختبار (testing) وتهدف إلى التأكد من أن دالة `percent_rank` تعيد ناتجًا من النوع العددي بشكل صحيح.  
- يجب أن يكون العمود `data` من النوع `Integer` حتى يعمل التعبير بشكل صحيح.  
- يتم استخدام `is_` للتحقق من تطابق النوع، وهي أداة مفيدة في اختبارات SQLAlchemy للتأكد من أنواع البيانات.
***
## ClassDef ExecuteTest
**ExecuteTest**: وظيفة الفئة ExecuteTest هي اختبار تنفيذ الاستعلامات والوظائف في قاعدة البيانات باستخدام SQLAlchemy.

**attributes**: السمات الخاصة بهذه الفئة.
· __backend__: سمة منطقية تشير إلى أن الفئة تعتمد على قاعدة بيانات فعلية (backend) لتنفيذ الاختبارات.

**Code Description**: 
فئة ExecuteTest هي فئة اختبارية تهدف إلى التحقق من صحة تنفيذ الاستعلامات والوظائف في SQLAlchemy. تحتوي الفئة على عدة طرق اختبارية تختبر سلوكيات مختلفة مثل تنفيذ الاستعلامات، إدارة خيارات التنفيذ، تحديث البيانات، واستخراج القيم من التواريخ. 

1. **test_conn_execute**: تختبر هذه الطريقة تنفيذ الاستعلامات باستخدام connection.execute و connection.scalar. يتم التحقق من أن النتائج متساوية عند استخدام طرق مختلفة لتنفيذ نفس الاستعلام.

2. **test_exec_options**: تختبر هذه الطريقة إدارة خيارات التنفيذ (execution_options) للوظائف والاستعلامات. يتم التحقق من أن الخيارات المحددة يتم تطبيقها بشكل صحيح.

3. **test_update**: تختبر هذه الطريقة إرسال الوظائف والتعابير SQL إلى عبارات VALUES و SET في عمليات INSERT و UPDATE. يتم التحقق من أن القيم الافتراضية للأعمدة يتم تجاوزها بشكل صحيح.

4. **test_aggregate_strings_execute**: تختبر هذه الطريقة تجميع السلاسل النصية باستخدام الوظيفة aggregate_strings. يتم التحقق من أن النتيجة تتطابق مع التوقعات سواء كانت القيم نصية عادية أو نصوص Unicode.

5. **test_as_from**: تختبر هذه الطريقة استخدام الوظائف كجدول في الاستعلامات. يتم التحقق من أن النتائج متساوية عند استخدام الوظيفة مباشرة أو كجزء من عبارة SELECT.

6. **test_extract_bind**: تختبر هذه الطريقة استخراج أجزاء من التاريخ (مثل السنة، الشهر، اليوم) باستخدام الوظيفة extract. يتم التحقق من أن القيم المستخرجة صحيحة.

7. **test_extract_expression**: تختبر هذه الطريقة استخراج أجزاء من التاريخ من الأعمدة في الجدول. يتم التحقق من أن القيم المستخرجة صحيحة.

**Note**: 
- يجب أن تكون قاعدة البيانات متاحة لتنفيذ هذه الاختبارات لأن السمة __backend__ مضبوطة على True.
- بعض الاختبارات تعتمد على قاعدة بيانات محددة مثل PostgreSQL، لذا قد لا تعمل على جميع قواعد البيانات.

**Output Example**: 
عند تنفيذ الاختبارات، قد تكون النتائج كما يلي:
- test_conn_execute: يتم التحقق من أن x == y == z == q هو True.
- test_exec_options: يتم التحقق من أن _execution_options يحتوي على القيم المحددة مثل {"foo": "bar"}.
- test_update: يتم التحقق من أن القيم المحدثة في الجدول تتطابق مع التوقعات.
- test_aggregate_strings_execute: يتم التحقق من أن النتيجة النهائية لتجميع السلاسل النصية تتطابق مع القيمة المتوقعة.
### FunctionDef teardown_test(self)
**teardown_test**: وظيفة teardown_test هي تنفيذ عمليات التنظيف أو الإنهاء بعد انتهاء الاختبار.  
**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters).  
**Code Description**:  
تُستخدم وظيفة `teardown_test` عادةً في سياق اختبارات البرمجيات (software testing) لتنفيذ أي عمليات تنظيف أو إغلاق ضرورية بعد انتهاء تنفيذ الاختبار. في الكود الحالي، الوظيفة فارغة (`pass`)، مما يعني أنها لا تقوم بأي عمل محدد. يمكن تعديل هذه الوظيفة في المستقبل لإضافة أي خطوات إضافية مطلوبة لتنظيف الموارد أو إعادة الحالة إلى وضعها الأولي بعد الاختبار.  

**Note**:  
- يجب ملاحظة أن هذه الوظيفة لا تقوم حاليًا بأي عمل، لذا قد تحتاج إلى تعديلها لتناسب احتياجات الاختبارات المحددة.  
- يُنصح باستخدام هذه الوظيفة لإغلاق الاتصالات، تحرير الذاكرة، أو إعادة تعيين أي إعدادات تم تغييرها أثناء الاختبار.
***
### FunctionDef test_conn_execute(self, connection)
**test_conn_execute**: وظيفة `test_conn_execute` هي اختبار تنفيذ استعلامات SQL باستخدام اتصال قاعدة بيانات معين والتحقق من صحة النتائج.

**parameters**: معاملات هذه الوظيفة.
· `connection`: اتصال قاعدة البيانات الذي سيتم استخدامه لتنفيذ الاستعلامات.

**Code Description**: 
تقوم هذه الوظيفة باختبار تنفيذ استعلامات SQL باستخدام اتصال قاعدة بيانات معين. يتم ذلك من خلال الخطوات التالية:

1. يتم استيراد الفئة `FunctionElement` من مكتبة `sqlalchemy.sql.expression` ودالة `compiles` من مكتبة `sqlalchemy.ext.compiler`.

2. يتم تعريف فئة جديدة تسمى `myfunc` والتي ترث من `FunctionElement`. تحتوي هذه الفئة على خاصية `inherit_cache` التي يتم تعيينها إلى `True` ونوع البيانات `type` الذي يتم تعيينه إلى `Date()`.

3. يتم تعريف دالة `compile_` باستخدام الديكوراتور `@compiles` والتي تقوم بتحويل `myfunc` إلى استعلام SQL يعيد التاريخ الحالي باستخدام الدالة `func.current_date()`.

4. يتم تنفيذ عدة استعلامات باستخدام الاتصال المقدم (`connection`):
   - `x`: يتم تنفيذ استعلام `func.current_date()` واستخراج القيمة العددية باستخدام `.scalar()`.
   - `y`: يتم تنفيذ استعلام `func.current_date().select()` واستخراج القيمة العددية باستخدام `.scalar()`.
   - `z`: يتم استخراج القيمة العددية مباشرة من `func.current_date()` باستخدام `connection.scalar()`.
   - `q`: يتم استخراج القيمة العددية من `myfunc()` باستخدام `connection.scalar()`.

5. يتم التحقق من أن جميع القيم (`x`, `y`, `z`, `q`) متساوية باستخدام `assert`.

**Note**: 
- يجب أن يكون الاتصال المقدم (`connection`) نشطًا وقادرًا على تنفيذ الاستعلامات.
- يتم استخدام `func.current_date()` للحصول على التاريخ الحالي من قاعدة البيانات.

**Output Example**: 
لا يتم إرجاع أي قيمة من هذه الوظيفة، ولكن يتم استخدام `assert` للتحقق من أن جميع القيم (`x`, `y`, `z`, `q`) متساوية. إذا كانت جميع القيم متساوية، فإن الاختبار يمر بنجاح.
#### ClassDef myfunc
**myfunc**: وظيفة myfunc هي توفير عنصر دالة (FunctionElement) يعيد نوعًا محددًا من البيانات، وهو النوع Date.

**attributes**: السمات الخاصة بهذا الكلاس.
· inherit_cache: هذه السمة تُحدد ما إذا كان الكلاس سيستخدم التخزين المؤقت للوراثة. القيمة `True` تعني أن الكلاس سيستخدم التخزين المؤقت للوراثة، مما يحسن الأداء عن طريق تجنب إعادة إنشاء العناصر المتشابهة.
· type: هذه السمة تُحدد نوع البيانات التي ستعيدها الدالة. في هذه الحالة، النوع هو `Date`، مما يعني أن الدالة ستعيد بيانات من نوع التاريخ.

**Code Description**: وصف الكود.
يُعرِّف هذا الكود كلاسًا باسم `myfunc` الذي يرث من `FunctionElement`. الكلاس `FunctionElement` هو جزء من مكتبة SQLAlchemy ويُستخدم لإنشاء عناصر دالة يمكن استخدامها في استعلامات SQL. السمة `inherit_cache` مُعينة إلى `True`، مما يعني أن الكلاس سيستخدم التخزين المؤقت للوراثة لتحسين الأداء. السمة `type` مُعينة إلى `Date()`، مما يشير إلى أن الدالة ستعيد بيانات من نوع التاريخ. هذا الكلاس مفيد في الحالات التي تحتاج فيها إلى إنشاء دالة مخصصة تعيد تاريخًا في استعلامات قاعدة البيانات.

**Note**: ملاحظات حول استخدام الكود.
- تأكد من أن الكلاس `myfunc` يُستخدم في سياق مناسب حيث تكون هناك حاجة إلى دالة تعيد تاريخًا.
- إذا كنت تستخدم SQLAlchemy، فستحتاج إلى استيراد `FunctionElement` و `Date` من المكتبة المناسبة قبل استخدام هذا الكلاس.
- التخزين المؤقت للوراثة (`inherit_cache = True`) يمكن أن يحسن الأداء، ولكن تأكد من فهم كيفية عمله لتجنب أي سلوك غير متوقع في التطبيقات المعقدة.
***
#### FunctionDef compile_(elem, compiler)
**compile_**: وظيفة compile_ هي تجميع عنصر معين باستخدام مُصرِّف (compiler) معين.

**parameters**: معاملات هذه الوظيفة.
· elem: العنصر الذي يتم تمريره ليتم تجميعه.
· compiler: المُصرِّف الذي سيتم استخدامه لمعالجة العنصر.
· **kw: معاملات إضافية اختيارية يمكن تمريرها إلى الوظيفة.

**Code Description**: تقوم هذه الوظيفة بمعالجة العنصر `elem` باستخدام المُصرِّف `compiler`. يتم ذلك عن طريق استدعاء دالة `process` الخاصة بالمُصرِّف وتمرير نتيجة استدعاء دالة `current_date()` من الوحدة `func` إليها. بمعنى آخر، تقوم الوظيفة بإرجاع نتيجة معالجة التاريخ الحالي باستخدام المُصرِّف المحدد.

**Note**: يجب التأكد من أن المُصرِّف `compiler` يحتوي على دالة `process` قادرة على معالجة القيمة التي تُرجعها `func.current_date()`. كما يجب أن تكون الوحدة `func` متاحة ومهيأة بشكل صحيح في السياق الذي يتم فيه استدعاء هذه الوظيفة.

**Output Example**: نتيجة تنفيذ هذه الوظيفة قد تكون على سبيل المثال:
```python
"2023-10-05"
```
حيث يتم إرجاع التاريخ الحالي بعد معالجته بواسطة المُصرِّف.
***
***
### FunctionDef test_exec_options(self, connection)
**test_exec_options**: وظيفة `test_exec_options` هي اختبار خيارات التنفيذ (execution options) للدوال والاستعلامات في قاعدة البيانات.

**parameters**: معاملات هذه الوظيفة.
· `connection`: معامل يمثل اتصالًا بقاعدة البيانات، ويُستخدم لتنفيذ الاستعلامات والتحقق من خيارات التنفيذ.

**Code Description**: 
تقوم هذه الوظيفة باختبار كيفية تعيين واستخدام خيارات التنفيذ (execution options) للدوال والاستعلامات. يتم ذلك من خلال الخطوات التالية:

1. يتم إنشاء دالة `foo` باستخدام `func.foo()`، ويتم التحقق من أن خيارات التنفيذ الافتراضية فارغة (`{}`).

2. يتم تعيين خيار تنفيذ جديد للدالة باستخدام `execution_options(foo="bar")`، ويتم التحقق من أن خيارات التنفيذ أصبحت تحتوي على القيمة `{"foo": "bar"}`.

3. يتم إنشاء استعلام `select` من الدالة المعدلة، ويتم التحقق من أن خيارات التنفيذ نفسها (`{"foo": "bar"}`) تم تطبيقها على الاستعلام.

4. يتم تنفيذ دالة `now()` مع خيارات التنفيذ المحددة (`execution_options(foo="bar")`) باستخدام الاتصال `connection`. بعد ذلك، يتم التحقق من أن خيارات التنفيذ (`{"foo": "bar"}`) موجودة في سياق التنفيذ (`ret.context.execution_options`).

5. أخيرًا، يتم إغلاق نتيجة التنفيذ (`ret.close()`) لتحرير الموارد.

**Note**: 
- تأكد من أن الاتصال `connection` الممرر إلى الوظيفة صالح وقادر على تنفيذ الاستعلامات.
- خيارات التنفيذ تُستخدم لتخصيص سلوك التنفيذ للدوال والاستعلامات، لذا يجب التأكد من أنها تُعيّن بشكل صحيح وتُطبق كما هو متوقع.
- إغلاق نتيجة التنفيذ (`ret.close()`) مهم لإدارة الموارد بشكل صحيح وتجنب تسرب الذاكرة.
***
### FunctionDef test_update(self, connection)
**test_update**: وظيفة `test_update` هي اختبار إرسال الدوال والتعابير SQL إلى عبارات `VALUES` و `SET` في عمليات `INSERT` و `UPDATE`، بالإضافة إلى التأكد من أن القيم الافتراضية على مستوى الأعمدة يتم تجاوزها.

**parameters**: معاملات هذه الوظيفة.
· `connection`: اتصال قاعدة البيانات المستخدم لتنفيذ العمليات.

**Code Description**: 
تقوم هذه الوظيفة بإنشاء جدولين (`t1` و `t2`) باستخدام `Table` من مكتبة SQLAlchemy. يحتوي الجدول `t1` على عمودين: `id` (مفتاح أساسي) و `value` (عدد صحيح). بينما يحتوي الجدول `t2` على ثلاثة أعمدة: `id` (مفتاح أساسي)، `value` (عدد صحيح مع قيمة افتراضية 7)، و `stuff` (نصي مع تحديث تلقائي عند التعديل).

بعد إنشاء الجداول، يتم إدخال بيانات في الجدول `t1` باستخدام `INSERT` مع دالة `func.length` لحساب طول النص وإدخال النتيجة في العمود `value`. يتم التحقق من صحة النتائج باستخدام `eq_` للتأكد من أن القيم المدخلة والمحدثة صحيحة.

في الجدول `t2`، يتم إدخال بيانات مع قيم افتراضية وقيم محسوبة باستخدام `func.length`. يتم أيضًا اختبار التحديث التلقائي للعمود `stuff` عند استخدام `UPDATE`. يتم التحقق من النتائج باستخدام `eq_` للتأكد من أن القيم المحدثة صحيحة.

أخيرًا، يتم حذف البيانات من الجدول `t2` وإدخال بيانات جديدة مع التحقق من القيم المحدثة مرة أخرى.

**Note**: 
- يتم استخدام `func.length` لحساب طول النص وإدخال النتيجة في الأعمدة.
- يتم استخدام `eq_` للتحقق من صحة النتائج المتوقعة.
- يتم اختبار التحديث التلقائي للعمود `stuff` عند استخدام `UPDATE`.
***
### FunctionDef test_aggregate_strings_execute(self, connection, metadata, unicode_value, unicode_separator)
**test_aggregate_strings_execute**: وظيفة `test_aggregate_strings_execute` هي اختبار وظيفة تجميع النصوص (`aggregate_strings`) في قاعدة البيانات باستخدام اتصال قاعدة بيانات معين، والتحقق من أن النتيجة المتوقعة تتطابق مع الناتج الفعلي.

**parameters**: معاملات هذه الوظيفة.
· `connection`: اتصال قاعدة البيانات المستخدم لتنفيذ الاستعلامات وإنشاء الجداول.
· `metadata`: كائن `metadata` الذي يحتوي على تعريفات الجداول والأعمدة.
· `unicode_value`: معامل منطقي يحدد ما إذا كان سيتم استخدام عمود النصوص العادية (`value`) أو عمود النصوص اليونيكود (`unicode_value`).
· `unicode_separator`: معامل منطقي يحدد ما إذا كان سيتم استخدام فاصل يونيكود (`🐍試`) أو فاصل عادي (`and`).

**Code Description**: وصف تفصيلي للوظيفة.
1. يتم إنشاء جدول يسمى `values` باستخدام الكائن `metadata`. يحتوي هذا الجدول على عمودين: `value` من نوع `String` و`unicode_value` من نوع `Unicode`.
2. يتم إنشاء الجدول في قاعدة البيانات باستخدام `metadata.create_all(connection)`.
3. يتم إدخال بيانات في الجدول باستخدام `connection.execute`. البيانات المدخلة تشمل قيم نصية عادية وقيم يونيكود، بالإضافة إلى قيم `NULL` التي يتم تجاهلها.
4. يتم تحديد الفاصل (`separator`) بناءً على قيمة `unicode_separator`. إذا كانت `True`، يتم استخدام فاصل يونيكود (`🐍試`)، وإلا يتم استخدام الفاصل العادي (`and`).
5. يتم تحديد العمود الذي سيتم تجميع نصوصه بناءً على قيمة `unicode_value`. إذا كانت `True`، يتم استخدام عمود `unicode_value`، وإلا يتم استخدام عمود `value`.
6. إذا كان الفاصل من نوع يونيكود والعمود المستخدم هو `value`، يتم تحويل العمود إلى نوع `Unicode` باستخدام `cast` لضمان التوافق.
7. يتم تنفيذ استعلام `SELECT` باستخدام وظيفة `aggregate_strings` لتجميع النصوص في العمود المحدد مع الفاصل المحدد.
8. يتم التحقق من أن الناتج الفعلي (`value`) يتطابق مع الناتج المتوقع (`expected`) باستخدام `eq_`.

**Note**: ملاحظات حول استخدام الكود.
- يجب أن يكون اتصال قاعدة البيانات (`connection`) نشطًا وقادرًا على تنفيذ الاستعلامات وإنشاء الجداول.
- يجب أن تكون البيانات المدخلة في الجدول متوافقة مع نوع العمود (نص عادي أو يونيكود).
- عند استخدام فاصل يونيكود مع عمود نص عادي، يجب تحويل العمود إلى يونيكود باستخدام `cast` لتجنب أخطاء قاعدة البيانات.
***
### FunctionDef test_as_from(self, connection)
**test_as_from**: وظيفة `test_as_from` تهدف إلى اختبار استرجاع القيمة الحالية للتاريخ باستخدام دوال SQLAlchemy المختلفة ومقارنة النتائج للتأكد من تطابقها.

**parameters**:  
· `connection`: معلمة تمثل اتصال قاعدة البيانات الذي يتم من خلاله تنفيذ الاستعلامات.

**Code Description**:  
تقوم هذه الوظيفة بتنفيذ عدة استعلامات باستخدام اتصال قاعدة البيانات المقدم (`connection`) لاسترجاع القيمة الحالية للتاريخ. يتم ذلك باستخدام الدالة `func.current_date()` من مكتبة SQLAlchemy، والتي تُرجع التاريخ الحالي.  

1. يتم تنفيذ الاستعلام الأول باستخدام `connection.execute(func.current_date()).scalar()` لاسترجاع القيمة الحالية للتاريخ كقيمة مفردة (`scalar`).  
2. يتم تنفيذ الاستعلام الثاني باستخدام `connection.execute(func.current_date().select()).scalar()`، حيث يتم إنشاء استعلام `SELECT` من الدالة `func.current_date()` ثم تنفيذه لاسترجاع القيمة.  
3. يتم تنفيذ الاستعلام الثالث باستخدام `connection.scalar(func.current_date())`، وهي طريقة مختصرة لاسترجاع القيمة مباشرةً.  
4. يتم تنفيذ الاستعلام الرابع باستخدام `connection.scalar(select("*").select_from(func.current_date()))`، حيث يتم إنشاء استعلام `SELECT` من جدول افتراضي تم إنشاؤه بواسطة `func.current_date()`.  

أخيرًا، يتم التحقق من أن جميع القيم المسترجعة (`x`, `y`, `z`, `w`) متطابقة باستخدام `assert x == y == z == w`.

**Note**:  
- هذه الوظيفة مصممة للعمل مع قواعد البيانات التي تدعم الدالة `current_date`. ومع ذلك، يلاحظ وجود تعليق في الكود يشير إلى أن هذه الوظيفة قد لا تعمل بشكل صحيح مع قاعدة بيانات Oracle، مما يتطلب مزيدًا من التحقق.  
- يجب التأكد من أن اتصال قاعدة البيانات (`connection`) المقدم يعمل بشكل صحيح قبل تنفيذ هذه الوظيفة.
***
### FunctionDef test_extract_bind(self, connection)
**test_extract_bind**: وظيفة `test_extract_bind` هي إجراء اختبارات أساسية لاستخراج القيم من التواريخ باستخدام الدالة `extract`.

**parameters**: معاملات هذه الوظيفة.
· `connection`: معامل يمثل اتصالًا بقاعدة البيانات أو نظامًا مشابهًا يُستخدم لتنفيذ الاستعلامات.

**Code Description**: 
تقوم هذه الوظيفة باختبار الدالة `extract` التي تُستخدم لاستخراج أجزاء محددة من التاريخ مثل السنة (`year`)، الشهر (`month`)، واليوم (`day`). يتم ذلك من خلال إنشاء تاريخين: الأول من نوع `datetime.date` والثاني من نوع `datetime.datetime`. 

1. يتم تعريف تاريخ أولي باستخدام `datetime.date(2010, 5, 1)` والذي يمثل الأول من مايو 2010.
2. يتم تعريف دالة مساعدة داخلية تسمى `execute` تقوم بتنفيذ استعلام باستخدام الدالة `extract` لاستخراج جزء محدد من التاريخ (مثل السنة، الشهر، أو اليوم) وإرجاع النتيجة كقيمة عددية.
3. يتم استخدام الدالة `execute` لاختبار استخراج السنة (`year`)، الشهر (`month`)، واليوم (`day`) من التاريخ الأولي، ويتم التحقق من أن النتائج تتطابق مع القيم المتوقعة (2010 للسنة، 5 للشهر، و1 لليوم).
4. يتم بعد ذلك تعريف تاريخ ثاني باستخدام `datetime.datetime(2010, 5, 1, 12, 11, 10)` والذي يمثل الأول من مايو 2010 مع وقت محدد (12:11:10).
5. يتم تكرار نفس الاختبارات على التاريخ الثاني للتأكد من أن الدالة `extract` تعمل بشكل صحيح مع التواريخ التي تحتوي على وقت.

**Note**: 
- يجب أن يكون المعامل `connection` قادرًا على تنفيذ استعلامات SQL باستخدام الدالة `select` و `extract`.
- يتم استخدام `assert` للتحقق من صحة النتائج، مما يعني أن الاختبار سيفشل إذا لم تكن النتائج كما هو متوقع.

**Output Example**: 
لا تُرجع هذه الوظيفة أي قيمة مباشرة، ولكنها تُستخدم للتحقق من صحة النتائج باستخدام `assert`. إذا كانت جميع الاختبارات ناجحة، فلن يتم إرجاع أي شيء، ولكن إذا فشل أي اختبار، سيتم إرجاع خطأ يشير إلى الفشل.
#### FunctionDef execute(field)
**execute**: وظيفة execute هي تنفيذ استعلام SQL لاستخراج قيمة محددة من حقل معين في قاعدة البيانات.

**parameters**: معاملات هذه الوظيفة.
· field: الحقل الذي يتم استخراج القيمة منه. يجب أن يكون هذا الحقل مرتبطًا بنوع بيانات التاريخ (date).

**Code Description**: 
تقوم هذه الوظيفة بتنفيذ استعلام SQL باستخدام كائن `connection` المحدد مسبقًا. يتم استخدام الدالة `select` لإنشاء استعلام SQL يقوم باستخراج قيمة محددة من الحقل `field` باستخدام الدالة `extract`. الدالة `extract` تستخدم لاستخراج جزء محدد من التاريخ (مثل السنة، الشهر، اليوم) من الحقل `field`. بعد ذلك، يتم تنفيذ الاستعلام باستخدام `connection.execute`، ويتم استرداد القيمة الناتجة كقيمة مفردة (scalar) باستخدام `.scalar()`.

**Note**: 
- يجب أن يكون الحقل `field` مرتبطًا بنوع بيانات التاريخ (date) حتى تعمل الدالة بشكل صحيح.
- يجب أن يكون كائن `connection` متاحًا ومهيأً بشكل صحيح قبل استدعاء هذه الوظيفة.

**Output Example**: 
إذا كان الحقل `field` يحتوي على التاريخ `2023-10-05` وتم استخراج الشهر (month)، فإن القيمة المرجعة ستكون `10`.
***
***
### FunctionDef test_extract_expression(self, connection)
**test_extract_expression**: وظيفة `test_extract_expression` هي اختبار استخراج قيم السنة والشهر من عمودين من نوع `DateTime` و `Date` في قاعدة البيانات باستخدام دالة `extract`.

**parameters**: معاملات هذه الوظيفة.
· `self`: يشير إلى نسخة الكائن الحالي الذي يتم تنفيذ الوظيفة من خلاله.
· `connection`: يمثل اتصال قاعدة البيانات الذي يتم من خلاله تنفيذ الاستعلامات.

**Code Description**: وصف تفصيلي للوظيفة.
1. يتم إنشاء جدول افتراضي باسم `test` يحتوي على عمودين: الأول من نوع `DateTime` باسم `dt`، والثاني من نوع `Date` باسم `d`. يتم إنشاء هذا الجدول في قاعدة البيانات باستخدام `meta.create_all(connection)`.
2. يتم إدراج صف واحد في الجدول يحتوي على قيمة تاريخ ووقت (`datetime.datetime(2010, 5, 1, 12, 11, 10)`) للعمود `dt`، وقيمة تاريخ (`datetime.date(2010, 5, 1)`) للعمود `d`.
3. يتم تنفيذ استعلام باستخدام دالة `extract` لاستخراج السنة من العمود `dt` والشهر من العمود `d`. يتم استخدام `select` لإنشاء الاستعلام.
4. يتم استرداد النتيجة الأولى من الاستعلام باستخدام `rs.first()`، ويتم التحقق من أن السنة المستخرجة تساوي `2010` وأن الشهر المستخرج يساوي `5`.
5. أخيرًا، يتم إغلاق مجموعة النتائج (`rs.close()`) لتحرير الموارد.

**Note**: ملاحظات حول استخدام الكود.
- يجب أن يكون اتصال قاعدة البيانات (`connection`) نشطًا وصالحًا لتنفيذ العمليات بنجاح.
- يتم استخدام دالة `extract` لاستخراج أجزاء محددة من القيم الزمنية (مثل السنة أو الشهر) من الأعمدة في قاعدة البيانات.
- يجب التأكد من أن الجدول والأعمدة المحددة موجودة في قاعدة البيانات قبل تنفيذ الاستعلامات.
***
## ClassDef RegisterTest
**RegisterTest**: وظيفة `RegisterTest` هي اختبار تسجيل الدوال (functions) في النظام والتأكد من أن الدوال المسجلة تعمل بشكل صحيح.

**attributes**: السمات الخاصة بهذا الكلاس.
· `__dialect__`: يُستخدم لتحديد اللهجة الافتراضية (default dialect) للاستعلامات. في هذا الكلاس، تم تعيينه إلى `"default"`.

**Code Description**: وصف تفصيلي لهذا الكلاس.
- `setup_test`: يتم تنفيذ هذه الوظيفة قبل كل اختبار. تقوم بنسخ عميقة (deepcopy) للسجل العام للدوال (`functions._registry`) وحفظه في المتغير `self._registry`. هذا يضمن أن الاختبارات لا تؤثر على السجل العام للدوال أثناء التشغيل.
  
- `teardown_test`: يتم تنفيذ هذه الوظيفة بعد كل اختبار. تقوم باستعادة السجل العام للدوال (`functions._registry`) إلى حالته الأصلية باستخدام النسخة التي تم حفظها في `setup_test`. هذا يضمن أن الاختبارات لا تترك أي تأثير دائم على النظام.

- `test_GenericFunction_is_registered`: هذا الاختبار يتأكد من أن الدالة العامة (`GenericFunction`) ليست مسجلة بشكل افتراضي في السجل (`_registry`). يتم التحقق من ذلك عن طريق التأكد من أن `"GenericFunction"` غير موجودة في `functions._registry["_default"]`.

- `test_register_function`: هذا الاختبار يتحقق من عملية تسجيل الدوال بشكل صحيح. يتم إنشاء دالة مسجلة (`registered_func`) ودالة غير مسجلة (`not_registered_func`) وفئاتها الفرعية. يتم التأكد من أن الدالة المسجلة (`registered_func`) موجودة في السجل (`_registry`) بينما الدالة غير المسجلة (`not_registered_func`) غير موجودة. بالإضافة إلى ذلك، يتم التحقق من أن نوع الدالة الفرعية (`registered_func_child` و `not_registered_func_child`) هو `Integer` باستخدام `isinstance`.

**Note**: ملاحظات حول استخدام الكود.
- يجب التأكد من أن أي تغييرات يتم إجراؤها على `functions._registry` أثناء الاختبارات يتم استعادتها بعد الانتهاء من الاختبار لتجنب أي تأثيرات جانبية على الاختبارات الأخرى.
- يتم استخدام `deepcopy` لضمان أن النسخة المحفوظة من السجل (`_registry`) لا تتأثر بالتغييرات التي تحدث أثناء الاختبار.
### FunctionDef setup_test(self)
**setup_test**: وظيفة `setup_test` هي نسخ محتوى السجل (`registry`) من الكائن `functions` وحفظه في المتغير `_registry` الخاص بالكائن الحالي.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters).

**Code Description**: تقوم هذه الدالة بنسخ محتوى السجل (`registry`) الموجود في الكائن `functions` باستخدام الدالة `deepcopy` من مكتبة `copy`، ثم يتم حفظ النسخة الجديدة في المتغير `_registry` الخاص بالكائن الحالي. الهدف من هذه العملية هو إنشاء نسخة مستقلة من السجل بحيث يمكن استخدامها في الاختبارات دون التأثير على السجل الأصلي.

**Note**: 
- تأكد من أن الكائن `functions` يحتوي على السجل (`registry`) قبل استدعاء هذه الدالة.
- استخدام `deepcopy` يضمن أن النسخة الجديدة من السجل تكون مستقلة تمامًا عن النسخة الأصلية، مما يمنع أي تغييرات لاحقة على النسخة الجديدة من التأثير على النسخة الأصلية.
***
### FunctionDef teardown_test(self)
**teardown_test**: وظيفة `teardown_test` هي استعادة الحالة الأصلية للسجل (`registry`) بعد انتهاء الاختبار.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذها باستخدام الكائن الحالي (`self`) فقط.

**Code Description**: تقوم هذه الدالة باستعادة الحالة الأصلية للسجل (`_registry`) الذي تم تخزينه مسبقًا في الكائن الحالي (`self`). يتم ذلك عن طريق تعيين قيمة `_registry` المخزنة في الكائن (`self._registry`) إلى المتغير العام `_registry` الموجود في وحدة `functions`. هذا الإجراء يضمن أن يتم إعادة تعيين السجل إلى حالته الأصلية بعد انتهاء الاختبار، مما يمنع أي تأثيرات جانبية قد تؤثر على الاختبارات الأخرى.

**Note**: يُستخدم هذا النوع من الدوال عادةً في سياق اختبارات الوحدة (unit tests) لضمان أن كل اختبار يعمل في بيئة نظيفة ولا يتأثر بالاختبارات السابقة. يجب التأكد من أن `self._registry` يحتوي على الحالة الأصلية للسجل قبل تنفيذ الاختبار.
***
### FunctionDef test_GenericFunction_is_registered(self)
**test_GenericFunction_is_registered**: وظيفة `test_GenericFunction_is_registered` هي التحقق من أن `GenericFunction` غير مسجلة في السجل الافتراضي للوظائف (`_registry`).

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة.

**Code Description**: تقوم هذه الوظيفة بفحص ما إذا كانت `GenericFunction` مسجلة في السجل الافتراضي للوظائف (`_registry`) الموجود في الكائن `functions`. يتم ذلك من خلال استخدام عبارة `assert` للتحقق من أن `GenericFunction` غير موجودة في القائمة المسجلة تحت المفتاح `_default`. إذا كانت `GenericFunction` مسجلة بالفعل، فإن الاختبار سيفشل، مما يشير إلى وجود خطأ في التسجيل.

**Note**: 
- هذه الوظيفة جزء من اختبارات الوحدة (unit tests) وتستخدم للتحقق من صحة سلوك التسجيل في النظام.
- يجب التأكد من أن `functions._registry["_default"]` يحتوي على القائمة الصحيحة للوظائف المسجلة قبل تنفيذ هذا الاختبار.
***
### FunctionDef test_register_function(self)
**test_register_function**: وظيفة `test_register_function` هي اختبار عملية تسجيل الدوال العامة (Generic Functions) في النظام.  
**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذ الاختبارات داخليًا دون الحاجة إلى مدخلات خارجية.  

**Code Description**:  
تقوم هذه الدالة باختبار آلية تسجيل الدوال العامة (Generic Functions) في النظام. يتم ذلك من خلال إنشاء عدة فئات (classes) تمثل دوال مسجلة وغير مسجلة، ثم التحقق من صحة التسجيل واستخدام هذه الدوال.  

1. يتم إنشاء فئة `registered_func` التي ترث من `GenericFunction` وتحتوي على خاصية `_register = True`، مما يعني أن هذه الدالة سيتم تسجيلها تلقائيًا في النظام.  
2. يتم إنشاء فئة فرعية `registered_func_child` التي ترث من `registered_func` وتحدد نوعًا معينًا (`type = sqltypes.Integer`).  
3. يتم التحقق من أن اسم الدالة `registered_func` موجود في السجل (`_registry`) الخاص بالدوال المسجلة في النظام.  
4. يتم التحقق من أن نوع الدالة `registered_func_child` هو من النوع `Integer`.  

بعد ذلك، يتم إنشاء فئة `not_registered_func` التي تحتوي على خاصية `_register = False`، مما يعني أن هذه الدالة لن يتم تسجيلها في النظام. يتم إنشاء فئة فرعية `not_registered_func_child` التي ترث من `not_registered_func` وتحدد نوعًا معينًا (`type = sqltypes.Integer`).  
يتم التحقق من أن اسم الدالة `not_registered_func` غير موجود في السجل (`_registry`) الخاص بالدوال المسجلة.  
أخيرًا، يتم التحقق من أن نوع الدالة `not_registered_func_child` هو من النوع `Integer`.  

**Note**:  
- هذه الدالة مخصصة للاختبار فقط ولا يتم استخدامها في الإنتاج.  
- يجب التأكد من أن الدوال المسجلة تحتوي على خاصية `_register = True` ليتم تسجيلها تلقائيًا في النظام.  
- الدوال غير المسجلة (مع `_register = False`) لن تظهر في السجل (`_registry`) ولكن يمكن استخدامها بشكل طبيعي.
#### ClassDef registered_func
**registered_func**: وظيفة `registered_func` هي توفير فئة أساسية للوظائف المسجلة التي يمكن توسيعها لإنشاء وظائف مخصصة.

**attributes**: السمات الخاصة بهذه الفئة.
· `_register`: سمة منطقية (boolean) تُشير إلى أن هذه الفئة مسجلة وقابلة للاستخدام في التسجيل.

**Code Description**: 
فئة `registered_func` هي فئة فرعية من `GenericFunction`، وتُستخدم كفئة أساسية للوظائف المسجلة. تحتوي هذه الفئة على سمة `_register` التي يتم تعيينها إلى `True`، مما يشير إلى أن هذه الفئة مسجلة وقابلة للاستخدام في التسجيل. يتم تنفيذ مُهيئ الفئة (`__init__`) باستدعاء مُهيئ الفئة الأم (`GenericFunction`) لضمان تهيئة الكائن بشكل صحيح.

في المشروع، يتم توسيع هذه الفئة بواسطة فئة أخرى تُسمى `registered_func_child`، والتي تضيف سمة `type` من نوع `sqltypes.Integer`. هذا يدل على أن `registered_func` تُستخدم كفئة أساسية لتوفير الهيكل العام للوظائف المسجلة، بينما تقوم الفئات الفرعية بتخصيص السلوك أو إضافة سمات إضافية حسب الحاجة.

**Note**: 
- عند استخدام هذه الفئة، تأكد من أن الفئات الفرعية تقوم بتهيئة الكائن بشكل صحيح عن طريق استدعاء مُهيئ الفئة الأم (`GenericFunction`).
- يمكن استخدام هذه الفئة كقاعدة لإنشاء وظائف مخصصة مع إمكانية التسجيل في النظام.
##### FunctionDef __init__(self)
**__init__**: وظيفة `__init__` هي تهيئة الكائن عند إنشائه.

**parameters**: معاملات هذه الوظيفة.
· `*args`: معاملات غير محددة يتم تمريرها كمجموعة من القيم.
· `**kwargs`: معاملات غير محددة يتم تمريرها كقاموس من القيم المفتاحية.

**Code Description**: 
تقوم وظيفة `__init__` بتهيئة الكائن عند إنشائه عن طريق استدعاء وظيفة `__init__` من الفئة الأم `GenericFunction`. يتم تمرير جميع المعاملات (`*args` و `**kwargs`) التي تم استقبالها إلى وظيفة `__init__` الخاصة بالفئة الأم. هذا يضمن أن الكائن يتم تهيئته بشكل صحيح وفقًا للسلوك المحدد في الفئة الأم.

**Note**: 
- يجب التأكد من أن الفئة الأم `GenericFunction` تحتوي على وظيفة `__init__` يمكنها التعامل مع المعاملات الممررة.
- يمكن استخدام `*args` و `**kwargs` لتمرير أي عدد من المعاملات إلى الوظيفة، مما يوفر مرونة في استخدام الكائن.
***
***
#### ClassDef registered_func_child
**registered_func_child**: وظيفة `registered_func_child` هي توسيع الفئة الأساسية `registered_func` لإضافة سمة `type` من نوع `sqltypes.Integer`.

**attributes**: السمات الخاصة بهذه الفئة.
· `type`: سمة تُحدد نوع البيانات الذي تُعيده الوظيفة، وهي من نوع `sqltypes.Integer`.

**Code Description**: 
فئة `registered_func_child` هي فئة فرعية من `registered_func`، وتُستخدم لتوسيع الوظائف المسجلة بإضافة سمة `type` من نوع `sqltypes.Integer`. هذه السمة تُشير إلى أن الوظيفة المُسجلة ستعيد قيمًا من نوع `Integer` عند تنفيذها. 

تم تصميم هذه الفئة لتعمل كفئة فرعية لـ `registered_func`، مما يعني أنها ترث جميع السمات والسلوكيات من الفئة الأم. بالإضافة إلى ذلك، تضيف هذه الفئة سمة `type` لتحديد نوع البيانات الذي تُعيده الوظيفة، مما يجعلها أكثر تحديدًا في الاستخدام.

**Note**: 
- عند استخدام هذه الفئة، تأكد من أنك تفهم أن سمة `type` محددة مسبقًا كـ `sqltypes.Integer`، وبالتالي فإن الوظيفة ستُعيد دائمًا قيمًا من هذا النوع.
- يمكن استخدام هذه الفئة كقاعدة لإنشاء وظائف مخصصة تعيد قيمًا من نوع `Integer` مع إمكانية التسجيل في النظام.
***
#### ClassDef not_registered_func
**not_registered_func**: وظيفة not_registered_func هي توفير فئة أساسية لا يتم تسجيلها تلقائيًا في النظام.  
**attributes**: السمات الخاصة بهذه الفئة.  
· `_register`: سمة منطقية (boolean) تُحدد ما إذا كانت الفئة مسجلة في النظام أم لا. في هذه الحالة، القيمة هي `False`، مما يعني أن الفئة لن يتم تسجيلها تلقائيًا.  

**Code Description**:  
تمثل هذه الفئة `not_registered_func` فئة أساسية (`base class`) ترث من `GenericFunction`. الغرض الرئيسي منها هو توفير هيكل لفئة لا يتم تسجيلها تلقائيًا في النظام. يتم تحقيق ذلك من خلال تعيين السمة `_register` إلى `False`.  

في البناء (`__init__`)، يتم استدعاء البناء الأساسي للفئة الأم (`GenericFunction`) باستخدام `*args` و `**kwargs`، مما يسمح بتمرير أي عدد من الوسائط إلى الفئة الأساسية.  

في المشروع، يتم استخدام هذه الفئة كفئة أساسية للفئة `not_registered_func_child`، والتي تضيف سمة `type` من نوع `sqltypes.Integer`. هذا يعني أن `not_registered_func_child` ترث عدم التسجيل التلقائي من `not_registered_func`، مع إضافة وظائف إضافية خاصة بها.  

**Note**:  
- هذه الفئة غير مخصصة للاستخدام المباشر، بل كفئة أساسية لفئات أخرى.  
- يجب التأكد من أن أي فئة ترث من `not_registered_func` لا تحتاج إلى التسجيل التلقائي في النظام.  
- عند استخدام هذه الفئة، يجب مراعاة أن السمة `_register` لن تسمح بالتسجيل التلقائي، مما قد يتطلب تسجيلًا يدويًا إذا لزم الأمر.
##### FunctionDef __init__(self)
**__init__**: وظيفة `__init__` هي تهيئة الكائن عند إنشائه.  
**parameters**: معاملات هذه الوظيفة.  
· `*args`: معاملات غير محددة يتم تمريرها كمجموعة.  
· `**kwargs`: معاملات محددة يتم تمريرها كقاموس.  
**Code Description**: تقوم هذه الوظيفة بتهيئة الكائن من خلال استدعاء دالة `__init__` الخاصة بالكلاس الأب `GenericFunction`. يتم تمرير جميع المعاملات (`*args` و `**kwargs`) إلى دالة `__init__` الخاصة بالكلاس الأب لضمان تنفيذ أي عمليات تهيئة مطلوبة من قبل الكلاس الأب.  
**Note**: يجب التأكد من أن الكلاس الأب `GenericFunction` يحتوي على دالة `__init__` قادرة على التعامل مع المعاملات الممررة.
***
***
#### ClassDef not_registered_func_child
**not_registered_func_child**: وظيفة `not_registered_func_child` هي توفير فئة فرعية لا يتم تسجيلها تلقائيًا في النظام، مع تحديد نوع البيانات الذي تعمل عليه.  

**attributes**: السمات الخاصة بهذه الفئة.  
· `type`: سمة تحدد نوع البيانات الذي تعمل عليه الفئة. في هذه الحالة، القيمة هي `sqltypes.Integer`، مما يعني أن الفئة مصممة للتعامل مع البيانات من نوع الأعداد الصحيحة.  

**Code Description**:  
تمثل هذه الفئة `not_registered_func_child` فئة فرعية ترث من الفئة الأساسية `not_registered_func`. الغرض الرئيسي منها هو توفير هيكل لفئة لا يتم تسجيلها تلقائيًا في النظام، مع إضافة سمة `type` لتحديد نوع البيانات الذي تعمل عليه.  

بما أن الفئة `not_registered_func_child` ترث من `not_registered_func`، فإنها ترث أيضًا السمة `_register` التي تم تعيينها إلى `False`، مما يعني أن هذه الفئة لن يتم تسجيلها تلقائيًا في النظام. بالإضافة إلى ذلك، تضيف هذه الفئة سمة `type` من نوع `sqltypes.Integer`، مما يشير إلى أن الفئة مصممة للتعامل مع البيانات من نوع الأعداد الصحيحة.  

في المشروع، يتم استخدام هذه الفئة كفئة فرعية للفئة `not_registered_func`، مما يوفر مرونة في التعامل مع أنواع البيانات المختلفة دون الحاجة إلى التسجيل التلقائي في النظام.  

**Note**:  
- هذه الفئة غير مخصصة للاستخدام المباشر، بل كفئة فرعية لفئات أخرى تحتاج إلى عدم التسجيل التلقائي مع تحديد نوع بيانات معين.  
- يجب التأكد من أن أي فئة ترث من `not_registered_func_child` لا تحتاج إلى التسجيل التلقائي في النظام.  
- عند استخدام هذه الفئة، يجب مراعاة أن السمة `_register` لن تسمح بالتسجيل التلقائي، مما قد يتطلب تسجيلًا يدويًا إذا لزم الأمر.
***
***
## ClassDef TableValuedCompileTest
**TableValuedCompileTest**: وظيفة `TableValuedCompileTest` هي اختبار مجموعة كاملة من الوظائف التي تم تطويرها كجزء من استعلامات SQL باستخدام `FROM`، مع التركيز على الوظائف التي تعمل على قيم الجداول (Table-Valued Functions).  
**attributes**: السمات الخاصة بهذا الكلاس.  
· `__dialect__`: يُستخدم لتحديد اللهجة الافتراضية المُحسنة (default_enhanced) للتعامل مع استعلامات SQL.  

**Code Description**:  
يحتوي هذا الكلاس على مجموعة من الاختبارات التي تتحقق من صحة بناء استعلامات SQL التي تستخدم وظائف تعمل على قيم الجداول (Table-Valued Functions). هذه الوظائف تُستخدم لتحويل البيانات المعقدة (مثل JSON) إلى جداول يمكن التعامل معها في SQL.  

1. **test_aggregate_scalar_over_table_valued**:  
   يختبر هذا الاختبار استخدام وظيفة `json_array_elements_text` لتحويل عناصر JSON إلى جدول، ثم حساب القيمة القصوى (max) للعناصر المحولة. يتم التحقق من صحة بناء الاستعلام باستخدام `assert_compile`.  

2. **test_scalar_table_valued**:  
   يختبر هذا الاختبار استخدام وظيفة `jsonb_each` لتحويل محتويات JSON إلى أزواج من المفاتيح والقيم (key-value pairs) كجدول.  

3. **test_table_valued_one**:  
   يختبر هذا الاختبار استخدام وظيفة `jsonb_each` لإنشاء جدول من محتويات JSON، ثم الانضمام إليه في استعلام SQL.  

4. **test_table_valued_two**:  
   يختبر هذا الاختبار استخدام وظيفة `value_ids` لإنشاء جدول افتراضي، ثم الانضمام إليه مع جدول آخر.  

5. **test_table_as_table_valued**:  
   يختبر هذا الاختبار تحويل جدول عادي إلى جدول يمكن استخدامه في وظائف SQL مثل `row_to_json`.  

6. **test_subquery_as_table_valued**:  
   يختبر هذا الاختبار استخدام استعلام فرعي (subquery) كجدول في وظيفة `row_to_json`.  

7. **test_scalar_subquery**:  
   يختبر هذا الاختبار استخدام استعلام فرعي كقيمة قياسية (scalar) في وظيفة `row_to_json`.  

8. **test_named_with_ordinality**:  
   يختبر هذا الاختبار استخدام وظيفة `unnest` مع خيار `WITH ORDINALITY` لإنشاء جدول يحتوي على ترتيب العناصر.  

9. **test_render_derived_maintains_tableval_type**:  
   يتحقق هذا الاختبار من أن نوع البيانات (type) للجدول المحول يظل محفوظًا بعد استخدام `render_derived`.  

10. **test_alias_maintains_tableval_type**:  
    يتحقق هذا الاختبار من أن نوع البيانات (type) للجدول المحول يظل محفوظًا بعد استخدام `alias`.  

11. **test_star_with_ordinality**:  
    يختبر هذا الاختبار استخدام `SELECT *` مع وظيفة `generate_series` وخيار `WITH ORDINALITY`.  

12. **test_json_object_keys_with_ordinality**:  
    يختبر هذا الاختبار استخدام وظيفة `json_object_keys` مع خيار `WITH ORDINALITY`.  

13. **test_alias_column**:  
    يختبر هذا الاختبار استخدام أعمدة من جداول تم إنشاؤها بواسطة وظائف مثل `generate_series`.  

14. **test_column_valued_one**:  
    يختبر هذا الاختبار استخدام وظيفة `unnest` لإنشاء عمود يمكن استخدامه في استعلام SQL.  

15. **test_column_valued_two**:  
    يختبر هذا الاختبار استخدام وظيفتين `generate_series` لإنشاء أعمدة متعددة في استعلام SQL.  

16. **test_column_valued_subquery**:  
    يختبر هذا الاختبار استخدام استعلام فرعي يحتوي على أعمدة تم إنشاؤها بواسطة وظائف.  

17. **test_render_derived_with_lateral**:  
    يختبر هذا الاختبار استخدام `LATERAL` مع وظيفة `jsonb_to_recordset` لإنشاء جدول مشتق.  

18. **test_function_alias**:  
    يختبر هذا الاختبار استخدام وظيفة `json_array_elements` مع استعلام فرعي وإنشاء اسم مستعار (alias) لها.  

19. **test_named_table_valued**:  
    يختبر هذا الاختبار استخدام وظيفة `json_to_recordset` لإنشاء جدول بأعمدة محددة.  

20. **test_named_table_valued_w_quoting**:  
    يختبر هذا الاختبار استخدام وظيفة `json_to_recordset` مع أسماء أعمدة تحتوي على أحرف خاصة.  

21. **test_named_table_valued_subquery**:  
    يختبر هذا الاختبار استخدام استعلام فرعي يحتوي على جدول تم إنشاؤه بواسطة وظيفة `json_to_recordset`.  

22. **test_named_table_valued_alias**:  
    يختبر هذا الاختبار استخدام اسم مستعار (alias) لجدول تم إنشاؤه بواسطة وظيفة `json_to_recordset`.  

**Note**:  
- يجب التأكد من أن الوظائف المستخدمة مدعومة في قاعدة البيانات المستهدفة.  
- يُفضل استخدام `assert_compile` للتحقق من صحة بناء استعلامات SQL.  
- يمكن استخدام `render_derived` و `alias` للحفاظ على نوع البيانات (type) عند تحويل الجداول.
### FunctionDef test_aggregate_scalar_over_table_valued(self)
**test_aggregate_scalar_over_table_valued**: وظيفة `test_aggregate_scalar_over_table_valued` تهدف إلى اختبار عملية تجميع قيم عددية (scalar aggregation) على جدول قيم (table-valued function) باستخدام SQLAlchemy.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على البيانات المحددة داخليًا في الكود.

**Code Description**: 
1. يتم إنشاء جدول افتراضي باسم `test` يحتوي على عمودين: `id` و `data`، حيث يكون عمود `data` من نوع JSON.
2. يتم استخدام الدالة `json_array_elements_text` لاستخراج العناصر النصية من المفتاح `key` داخل عمود `data`، ويتم تحويل النتيجة إلى جدول قيم (table-valued) باستخدام `.table_valued("value")`. يتم تسمية النتيجة بـ `elem`.
3. يتم حساب القيمة العظمى (max) للعناصر المستخرجة بعد تحويلها إلى نوع `Float`، ويتم تسمية النتيجة بـ `maxdepth`.
4. يتم إنشاء استعلام (query) باستخدام `select` لاستخراج `id` من الجدول `test` والقيمة `maxdepth`، مع ترتيب النتائج بناءً على `maxdepth`.
5. يتم استخدام `self.assert_compile` لمقارنة الاستعلام المترجم مع النص المتوقع للاستعلام، للتأكد من أن الترجمة تتم بشكل صحيح.

**Note**: 
- هذه الوظيفة مخصصة للاختبارات، حيث يتم التحقق من صحة ترجمة الاستعلامات باستخدام SQLAlchemy.
- يجب التأكد من أن النص المتوقع للاستعلام يتطابق تمامًا مع الناتج الفعلي للاستعلام، حيث إن أي اختلاف بسيط قد يؤدي إلى فشل الاختبار.
- يتم استخدام `cast` لتحويل القيم إلى نوع `Float`، مما يضمن أن العمليات الحسابية تتم بشكل صحيح.
***
### FunctionDef test_scalar_table_valued(self)
**test_scalar_table_valued**: وظيفة `test_scalar_table_valued` هي اختبار استخدام الدالة `scalar_table_valued` لاستخراج قيم محددة من عمود JSON في قاعدة البيانات.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذها داخل إطار اختبار (test case) وتعتمد على البيانات المحددة داخلها.

**Code Description**: 
- تقوم الدالة بإنشاء جدول افتراضي باسم `assets_transactions` يحتوي على عمودين: `id` من النوع العادي و`contents` من نوع JSON.
- يتم استخدام استعلام `select` لاستخراج القيم من الجدول، حيث يتم استخدام الدالة `jsonb_each` لفك محتويات العمود `contents` الذي يحتوي على بيانات JSON.
- يتم استخدام الدالة `scalar_table_valued` لاستخراج القيم المحددة من JSON، وهي `key` و`value`، حيث يتم تعيينها كأعمدة في نتيجة الاستعلام.
- يتم استخدام `self.assert_compile` لمقارنة الاستعلام المترجم مع النتيجة المتوقعة، للتأكد من أن الاستعلام يتم ترجمته بشكل صحيح إلى SQL.

**Note**: 
- يجب التأكد من أن الدالة `jsonb_each` متاحة في نظام إدارة قواعد البيانات المستخدم، حيث أنها تعمل على فك محتويات JSON إلى أزواج من المفاتيح والقيم.
- هذه الدالة مخصصة للاختبارات، لذا يجب استخدامها في سياق اختبار الوحدة (unit testing) وليس في الكود الإنتاجي.
***
### FunctionDef test_table_valued_one(self)
**test_table_valued_one**: وظيفة `test_table_valued_one` هي اختبار استخدام الدوال الجدولية (Table-Valued Functions) في SQLAlchemy مع تحويل JSON إلى أعمدة.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) لأنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى الكائن الحالي.

**Code Description**:  
تقوم هذه الدالة باختبار كيفية استخدام الدوال الجدولية في SQLAlchemy لتحويل بيانات JSON إلى أعمدة في استعلام SQL. يتم ذلك عبر الخطوات التالية:

1. **إنشاء جدول افتراضي**: يتم إنشاء جدول افتراضي باسم `assets_transactions` يحتوي على عمودين: `id` من النوع العادي و`contents` من نوع JSON.

2. **استخدام الدالة الجدولية**: يتم استخدام الدالة `jsonb_each` من مكتبة SQLAlchemy لتحويل محتويات العمود `contents` (التي تكون من نوع JSON) إلى جدول يحتوي على عمودين: `key` و`value`. يتم ذلك باستخدام الطريقة `table_valued` التي تحدد أسماء الأعمدة الناتجة.

3. **إنشاء استعلام SQL**: يتم إنشاء استعلام SQL باستخدام `select` لاسترداد قيم `id` من الجدول `assets_transactions`، بالإضافة إلى قيم `key` و`value` من الجدول الناتج عن الدالة الجدولية. يتم الربط بين الجدولين باستخدام `join` مع شرط `true()`، مما يعني أن الربط سيتم دون أي شروط محددة.

4. **اختبار التجميع (Compilation)**: يتم استخدام `self.assert_compile` للتحقق من أن الاستعلام الذي تم إنشاؤه يتطابق مع النص المتوقع للاستعلام SQL. النص المتوقع هو:
   ```sql
   SELECT assets_transactions.id, anon_1.key, anon_1.value 
   FROM assets_transactions 
   JOIN jsonb_each(assets_transactions.contents) AS anon_1 ON true
   ```

**Note**:  
- هذه الدالة مخصصة للاختبار فقط وتستخدم ضمن فئة اختبار (test class) في SQLAlchemy.
- يتم استخدام `jsonb_each` لتحويل بيانات JSON إلى أعمدة، وهي وظيفة متوفرة في قواعد البيانات التي تدعم JSONB مثل PostgreSQL.
- يجب التأكد من أن الاستعلام الذي يتم إنشاؤه يتطابق مع النص المتوقع للاستعلام SQL لضمان صحة الاختبار.
***
### FunctionDef test_table_valued_two(self)
**test_table_valued_two**: وظيفة `test_table_valued_two` هي اختبار عملية إنشاء واستخدام جدول افتراضي (table-valued function) في استعلام SQL باستخدام مكتبة SQLAlchemy.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث إنها جزء من فئة اختبار (test class) وتستخدم `self` للإشارة إلى الكائن الحالي.

**Code Description**: 
- تقوم الدالة بإنشاء جدول افتراضي باسم `values` يحتوي على عمودين: `id` من نوع `Integer` و`value` من نوع `String`.
- يتم إنشاء جدول افتراضي آخر باستخدام الدالة `value_ids()` والتي تُرجع جدولًا افتراضيًا يحتوي على عمود `id` من نوع `Integer`. يتم تسمية هذا الجدول بـ `vi`.
- يتم إنشاء استعلام SQL باستخدام `select` حيث يتم تحديد الأعمدة `id` من الجدول `vi` و`value` من الجدول `vv` (وهو اسم مستعار للجدول `values`).
- يتم تنفيذ عملية `JOIN` بين الجدولين `vi` و`vv` بناءً على تطابق القيم في العمود `id`.
- أخيرًا، يتم استخدام الدالة `assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع للاستعلام SQL.

**Note**: 
- هذه الدالة مخصصة للاختبار ولا تُستخدم في بيئة الإنتاج.
- يجب التأكد من أن الدالة `value_ids()` موجودة ومُعرَّفة بشكل صحيح في قاعدة البيانات قبل تنفيذ هذا الاختبار.
- يتم استخدام `alias` لتسمية الجداول الافتراضية لتسهيل قراءة الاستعلام وتجنب التعارض في الأسماء.
***
### FunctionDef test_table_as_table_valued(self)
**test_table_as_table_valued**: وظيفة `test_table_as_table_valued` تهدف إلى اختبار تحويل جدول إلى جدول قيم (table-valued) واستخدامه في استعلام SQL باستخدام الدالة `row_to_json`.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذ كل العمليات داخلها بشكل مباشر.

**Code Description**: 
1. يتم إنشاء جدول افتراضي باسم `a` باستخدام الدالة `table`، حيث يحتوي هذا الجدول على ثلاثة أعمدة: `id`، `x`، و `y`. يتم تعريف هذه الأعمدة باستخدام الدالة `column`.
2. يتم إنشاء استعلام SQL باستخدام الدالة `select`، حيث يتم استدعاء الدالة `row_to_json` لتحويل الجدول `a` إلى تنسيق JSON. يتم استخدام الدالة `table_valued()` لتحويل الجدول إلى جدول قيم (table-valued) يمكن استخدامه في الاستعلام.
3. يتم استخدام الدالة `assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع، وهو `"SELECT row_to_json(a) AS row_to_json_1 FROM a"`.

**Note**: 
- هذه الدالة تستخدم بشكل أساسي في اختبارات الوحدة (unit tests) للتحقق من صحة تحويل الجدول إلى جدول قيم واستخدامه في استعلامات SQL.
- يجب التأكد من أن الدالة `row_to_json` مدعومة في قاعدة البيانات المستخدمة، حيث أنها تقوم بتحويل الصفوف إلى تنسيق JSON.
***
### FunctionDef test_subquery_as_table_valued(self)
**test_subquery_as_table_valued**: وظيفة `test_subquery_as_table_valued` هي اختبار استخدام الاستعلام الفرعي (subquery) كجدول قيم (table-valued) في استعلام SQL.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة.

**Code Description**:  
تقوم هذه الدالة باختبار عملية تحويل استعلام فرعي إلى جدول قيم (table-valued) واستخدامه في استعلام SQL. يتم ذلك من خلال الخطوات التالية:

1. يتم إنشاء جدول افتراضي باسم `a` يحتوي على الأعمدة التالية: `id`، `x`، و `y` باستخدام الدالة `table` والدالة `column`.

2. يتم إنشاء استعلام فرعي (subquery) باستخدام الدالة `select` لاستخراج البيانات من الجدول `a`. يتم بعد ذلك تحويل هذا الاستعلام الفرعي إلى جدول قيم (table-valued) باستخدام الدالة `subquery().table_valued()`.

3. يتم استخدام الدالة `func.row_to_json` لتحويل الصفوف الناتجة من الجدول القيم إلى تنسيق JSON.

4. يتم استخدام الدالة `self.assert_compile` لمقارنة الاستعلام الذي تم إنشاؤه مع النص المتوقع للاستعلام. النص المتوقع هو:
   ```sql
   SELECT row_to_json(anon_1) AS row_to_json_1 FROM (SELECT a.id AS id, a.x AS x, a.y AS y FROM a) AS anon_1
   ```
   حيث يتم التأكد من أن الاستعلام الذي تم إنشاؤه يتطابق مع هذا النص.

**Note**:  
- هذه الدالة تستخدم بشكل أساسي في اختبارات الوحدة (unit tests) للتأكد من أن الاستعلامات التي تستخدم الاستعلامات الفرعية كجداول قيم يتم إنشاؤها بشكل صحيح.
- يجب التأكد من أن النص المتوقع للاستعلام يتطابق تمامًا مع الاستعلام الذي يتم إنشاؤه في الكود.
***
### FunctionDef test_scalar_subquery(self)
**test_scalar_subquery**: وظيفة `test_scalar_subquery` هي اختبار استخدام الاستعلام الفرعي القياسي (scalar subquery) مع دالة `row_to_json` في SQLAlchemy.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة.

**Code Description**: 
- تقوم الوظيفة بإنشاء جدول افتراضي باسم `a` يحتوي على ثلاثة أعمدة: `id`، `x`، و `y`.
- يتم إنشاء استعلام (`stmt`) باستخدام الدالة `select` من SQLAlchemy، حيث يتم استخدام الاستعلام الفرعي القياسي (`scalar_subquery`) لاختيار جميع الأعمدة من الجدول `a`. يتم تمرير هذا الاستعلام الفرعي إلى الدالة `row_to_json` التي تقوم بتحويل النتيجة إلى تنسيق JSON.
- يتم استخدام الدالة `assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع. النص المتوقع هو استعلام SQL الذي يقوم بتحويل النتيجة الناتجة من الاستعلام الفرعي إلى JSON باستخدام الدالة `row_to_json`.

**Note**: 
- هذه الوظيفة مخصصة للاختبار، حيث يتم التحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع.
- يتم استخدام `scalar_subquery` لإنشاء استعلام فرعي يعيد صفًا واحدًا فقط، وهو مناسب للاستخدام مع الدوال التي تتوقع قيمة واحدة مثل `row_to_json`.
***
### FunctionDef test_named_with_ordinality(self)
**test_named_with_ordinality**: وظيفة `test_named_with_ordinality` تهدف إلى اختبار عملية إنشاء استعلام SQL مع استخدام وظيفة `unnest` جنبًا إلى جنب مع خاصية `WITH ORDINALITY` لإنشاء جدول مشتق يحتوي على قيم مفردة مع ترتيبها العددي.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذ كل العمليات داخلها باستخدام المتغيرات المحددة مسبقًا.

**Code Description**: 
- يتم في البداية تعريف جدولين `a` و `b` باستخدام الدالة `table`، حيث يحتوي الجدول `a` على العمودين `id` و `refs`، بينما يحتوي الجدول `b` على العمودين `id` و `ref`.
- يتم استخدام الدالة `func.unnest` لتفكيك القيم في العمود `refs` من الجدول `a` إلى قيم مفردة، مع إضافة خاصية `WITH ORDINALITY` لتحديد ترتيب هذه القيم. يتم بعد ذلك إنشاء جدول مشتق باسم `unnested` يحتوي على عمودين: `unnested` و `ordinality`.
- يتم إنشاء استعلام `SELECT` باستخدام الدالة `select`، حيث يتم تحديد الأعمدة المطلوبة من الجدول `a` والجدول المشتق `unnested`. يتم بعد ذلك إجراء عملية `LEFT OUTER JOIN` بين الجدول `a` والجدول المشتق `unnested` باستخدام الشرط `true()`، مما يعني أن جميع الصفوف من الجدول `a` سيتم تضمينها في النتيجة حتى لو لم يكن هناك تطابق في الجدول المشتق.
- يتم أيضًا إجراء عملية `LEFT OUTER JOIN` بين الجدول المشتق `unnested` والجدول `b` باستخدام الشرط `unnested.unnested = b.ref`، مما يعني أن الصفوف من الجدول `b` سيتم تضمينها في النتيجة إذا كانت هناك تطابق مع القيم المفردة من الجدول المشتق.
- أخيرًا، يتم استخدام الدالة `self.assert_compile` للتحقق من أن الاستعلام الذي تم إنشاؤه يتطابق مع النص المتوقع للاستعلام SQL.

**Note**: 
- هذه الدالة تستخدم بشكل أساسي لاختبار صحة بناء استعلام SQL مع استخدام وظيفة `unnest` وخاصية `WITH ORDINALITY`.
- يجب التأكد من أن الجداول والأعمدة المستخدمة في الاستعلام موجودة ومحددة بشكل صحيح قبل تنفيذ الدالة.
- الدالة لا تحتوي على معاملات، لذا يتم تنفيذها بشكل مباشر دون الحاجة إلى تمرير أي بيانات إضافية.
***
### FunctionDef test_render_derived_maintains_tableval_type(self)
**test_render_derived_maintains_tableval_type**: وظيفة `test_render_derived_maintains_tableval_type` هي التحقق من أن عملية `render_derived` تحافظ على نوع `TableValueType` للأعمدة في الجدول المشتق.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة.

**Code Description**: 
- تقوم الوظيفة بإنشاء دالة `json_something()` باستخدام `func.json_something()`.
- يتم إنشاء جدول قيم (`table_valued`) باستخدام الدالة السابقة، مع تحديد عمود واحد باسم `x` ونوعه `String`.
- يتم التحقق من أن نوع العمود في الجدول (`tv.column.type`) هو من نوع `TableValueType` باستخدام `testing.eq_type_affinity`.
- يتم أيضًا التحقق من أن نوع العنصر الأول داخل `TableValueType` (`tv.column.type._elements[0].type`) هو من نوع `String`.
- بعد ذلك، يتم استدعاء `render_derived()` على الجدول (`tv`) لإنشاء جدول مشتق.
- يتم التحقق مرة أخرى من أن نوع العمود في الجدول المشتق (`tv.column.type`) لا يزال من نوع `TableValueType`، وأن نوع العنصر الأول داخل `TableValueType` لا يزال من نوع `String`.

**Note**: 
- هذه الوظيفة تُستخدم للتحقق من أن عملية `render_derived` تحافظ على نوع البيانات (`TableValueType`) للأعمدة في الجدول المشتق، مما يضمن استمرارية سلامة البيانات ونوعها بعد التحويل.
- يُستخدم `testing.eq_type_affinity` للتحقق من تطابق أنواع البيانات بشكل صحيح.
***
### FunctionDef test_alias_maintains_tableval_type(self)
**test_alias_maintains_tableval_type**: وظيفة `test_alias_maintains_tableval_type` هي التحقق من أن إنشاء alias (اسم مستعار) للجدول القيمي (table-valued) يحافظ على نوع الجدول القيمي وعناصره.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة.

**Code Description**: تقوم هذه الوظيفة باختبار ما إذا كان إنشاء alias للجدول القيمي يحافظ على نوع الجدول القيمي ونوع العناصر داخله. يتم ذلك من خلال الخطوات التالية:

1. يتم إنشاء دالة `json_something()` باستخدام `func.json_something()`.
2. يتم تحويل هذه الدالة إلى جدول قيمي (table-valued) باستخدام `table_valued()`، مع تحديد عمود واحد باسم `x` ونوع `String`.
3. يتم التحقق من أن نوع العمود في الجدول القيمي هو `sqltypes.TableValueType` باستخدام `eq_()`، كما يتم التحقق من أن نوع العنصر الأول داخل العمود هو `String`.
4. يتم إنشاء alias للجدول القيمي باستخدام `alias()`.
5. يتم التحقق مرة أخرى من أن نوع العمود في الجدول القيمي بعد إنشاء الـ alias لا يزال `sqltypes.TableValueType`، وأن نوع العنصر الأول داخل العمود لا يزال `String`.

**Note**: هذه الوظيفة مهمة للتأكد من أن إنشاء alias للجدول القيمي لا يؤثر على نوع الجدول أو أنواع العناصر داخله، مما يضمن استمرارية العمل مع البيانات بشكل صحيح.
***
### FunctionDef test_star_with_ordinality(self)
**test_star_with_ordinality**: وظيفة `test_star_with_ordinality` هي اختبار استعلام SQL يستخدم الدالة `generate_series` مع خيار `WITH ORDINALITY` لإنشاء سلسلة من الأرقام مع إضافة عمود ترتيبي.

**parameters**: لا تحتوي هذه الوظيفة على أي معاملات (parameters) محددة.

**Code Description**: 
- تقوم الوظيفة بإنشاء استعلام SQL باستخدام مكتبة SQLAlchemy. الهدف من الاستعلام هو استرداد جميع الأعمدة (`SELECT *`) من نتيجة دالة `generate_series` التي تنشئ سلسلة من الأرقام تبدأ من 4 وتنتهي عند 1 بخطوة -1. يتم استخدام الخيار `WITH ORDINALITY` لإضافة عمود ترتيبي إلى النتيجة، حيث يتم تسمية هذا العمود بـ "ordinality".
- يتم استخدام الدالة `func.generate_series(4, 1, -1)` لإنشاء السلسلة، ويتم تحويل النتيجة إلى جدول باستخدام `table_valued` مع تحديد `with_ordinality="ordinality"`.
- يتم بعد ذلك تجميع الاستعلام باستخدام `select("*").select_from` وتمريره إلى الدالة `self.assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع.

**Note**: 
- يجب التأكد من أن الدالة `generate_series` مدعومة في قاعدة البيانات المستخدمة، حيث أنها قد لا تكون متاحة في جميع أنظمة قواعد البيانات.
- الخيار `WITH ORDINALITY` يضيف عمودًا ترتيبيًا إلى النتيجة، وهو مفيد عند الحاجة إلى ترقيم الصفوف الناتجة.
***
### FunctionDef test_json_object_keys_with_ordinality(self)
Doc is waiting to be generated...
***
### FunctionDef test_alias_column(self)
Doc is waiting to be generated...
***
### FunctionDef test_column_valued_one(self)
Doc is waiting to be generated...
***
### FunctionDef test_column_valued_two(self)
Doc is waiting to be generated...
***
### FunctionDef test_column_valued_subquery(self)
Doc is waiting to be generated...
***
### FunctionDef test_render_derived_with_lateral(self, apply_alias_after_lateral)
Doc is waiting to be generated...
***
### FunctionDef test_function_alias(self)
Doc is waiting to be generated...
***
### FunctionDef test_named_table_valued(self)
Doc is waiting to be generated...
***
### FunctionDef test_named_table_valued_w_quoting(self)
Doc is waiting to be generated...
***
### FunctionDef test_named_table_valued_subquery(self)
**test_named_table_valued_subquery**: وظيفة `test_named_table_valued_subquery` هي اختبار استخدام استعلام جدولي ذي قيمة مع اسم محدد (named table-valued subquery) باستخدام مكتبة SQLAlchemy.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) حيث يتم تنفيذ الاختبار بشكل مباشر داخل الدالة.

**Code Description**: 
- تقوم الدالة بإنشاء استعلام جدولي ذي قيمة باستخدام الدالة `func.json_to_recordset` التي تقوم بتحويل سلسلة JSON إلى مجموعة من السجلات (records). في هذه الحالة، يتم تحويل السلسلة `'[{"a":1,"b":"foo"},{"a":"2","c":"bar"}]'` إلى سجلات.
- يتم تحديد الأعمدة التي سيتم استردادها من الجدول باستخدام الدالة `table_valued`، حيث يتم تحديد عمودين: `a` من نوع `Integer` و `b` من نوع `String`.
- يتم استخدام الدالة `render_derived(with_types=True)` لتوليد استعلام مشتق مع تحديد أنواع البيانات للأعمدة.
- يتم إنشاء استعلام فرعي (subquery) باستخدام الدالة `subquery()` على الاستعلام الذي تم إنشاؤه مسبقًا.
- يتم بعد ذلك إنشاء استعلام آخر (`select`) لاسترداد الأعمدة `a` و `b` من الاستعلام الفرعي.
- أخيرًا، يتم استخدام الدالة `self.assert_compile` للتحقق من أن الاستعلام المترجم يتطابق مع النص المتوقع. النص المتوقع هو استعلام SQL يقوم باختيار الأعمدة `a` و `b` من الجدول المشتق الذي تم إنشاؤه من تحويل JSON.

**Note**: 
- يجب التأكد من أن أنواع البيانات المحددة في الدالة `table_valued` تتطابق مع أنواع البيانات الفعلية في JSON لتجنب أية أخطاء في وقت التشغيل.
- الدالة `render_derived(with_types=True)` تُستخدم لتضمين أنواع البيانات في الاستعلام المشتق، مما يزيد من وضوح ودقة الاستعلام.
***
### FunctionDef test_named_table_valued_alias(self)
**test_named_table_valued_alias**: وظيفة `test_named_table_valued_alias` هي اختبار استخدام دالة `json_to_recordset` لتحويل بيانات JSON إلى جدول مع تحديد أسماء الأعمدة وأنواعها، ثم استخدامها في استعلام SQL مع تسمية الجدول الناتج.

**parameters**: لا تحتوي هذه الدالة على أي معاملات (parameters) محددة من قبل المستخدم، حيث إنها تعتمد على بيانات ثابتة داخل الكود.

**Code Description**: 
- تقوم الدالة بإنشاء استعلام SQL يستخدم الدالة `json_to_recordset` لتحويل سلسلة JSON إلى جدول. تحتوي سلسلة JSON على كائنين، الأول يحتوي على الحقلين `a` و`b`، بينما يحتوي الثاني على الحقلين `a` و`c`.
- يتم تحديد أعمدة الجدول الناتج باستخدام الدالة `table_valued`، حيث يتم تعريف العمود `a` كنوع `Integer` والعمود `b` كنوع `String`.
- يتم استخدام الدالة `render_derived` مع الخيار `with_types=True` لضمان تضمين أنواع الأعمدة في الاستعلام الناتج.
- يتم تسمية الجدول الناتج باستخدام الدالة `alias` باسم `jbr`.
- يتم إنشاء استعلام `SELECT` لاسترداد الأعمدة `a` و`b` من الجدول الناتج.
- أخيرًا، يتم استخدام الدالة `assert_compile` لمقارنة الاستعلام المترجم مع النتيجة المتوقعة، والتي تتضمن اسم الجدول `jbr` وأنواع الأعمدة المحددة.

**Note**: 
- يجب التأكد من أن سلسلة JSON المقدمة صحيحة وتتوافق مع الهيكل المتوقع للأعمدة.
- يتم استخدام أنواع البيانات `Integer` و`String` لتحديد أنواع الأعمدة في الجدول الناتج، ويجب أن تكون هذه الأنواع متوافقة مع البيانات الموجودة في JSON.
- يمكن تعديل اسم الجدول الناتج (`jbr`) حسب الحاجة، ولكن يجب التأكد من تحديث الاستعلام وفقًا لذلك.
***
</div>
