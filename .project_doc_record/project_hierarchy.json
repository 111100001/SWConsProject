{
  "dataset/verify.py": [
    {
      "type": "ClassDef",
      "name": "ReturnCode",
      "md_content": [
        "**ReturnCode**: وظيفة ReturnCode هي تحديد رموز الحالة المختلفة التي يمكن أن ترجعها العمليات المختلفة في البرنامج.\n\n**attributes**: خصائص هذه الفئة.\n· SUCCESS: رمز الحالة الذي يشير إلى نجاح العملية (0).\n· INTEGRITY_FAILURE: رمز الحالة الذي يشير إلى فشل في التحقق من النزاهة (1).\n· FILE_GET_FAILED: رمز الحالة الذي يشير إلى فشل في الحصول على الملف (4).\n· FILE_MISSING_FROM_ONE_HOST: رمز الحالة الذي يشير إلى عدم وجود ملف من أحد المضيفين (5).\n· FILES_NOT_EQUAL: رمز الحالة الذي يشير إلى أن الملفات ليست متساوية (6).\n· NO_BINARIES_MATCH: رمز الحالة الذي يشير إلى عدم تطابق أي ثنائيات (7).\n· NOT_ENOUGH_GOOD_SIGS: رمز الحالة الذي يشير إلى عدم وجود عدد كافٍ من التوقيعات الجيدة (9).\n· BINARY_DOWNLOAD_FAILED: رمز الحالة الذي يشير إلى فشل في تنزيل الثنائيات (10).\n· BAD_VERSION: رمز الحالة الذي يشير إلى إصدار غير صحيح (11).\n\n**Code Description**: ReturnCode هي فئة تستخدم لتحديد مجموعة من رموز الحالة التي تعكس نتائج العمليات المختلفة في البرنامج. يتم استخدام هذه الرموز لتسهيل فهم حالة العملية التي تم تنفيذها، سواء كانت ناجحة أو فشلت لأسباب معينة. \n\nتستخدم هذه الفئة في عدة وظائف في البرنامج مثل `get_files_from_hosts_and_compare` و `verify_shasums_signature` و `verify_binary_hashes` و `verify_published_handler` و `verify_binaries_handler`. كل من هذه الوظائف تعتمد على ReturnCode لتحديد النتيجة النهائية للعملية. على سبيل المثال، إذا فشلت عملية تنزيل ملف، فإن الوظيفة ستعيد ReturnCode.FILE_GET_FAILED. إذا كانت جميع الملفات متساوية، فستعيد ReturnCode.SUCCESS. \n\nتساعد ReturnCode المطورين في تتبع الأخطاء وفهم النتائج بشكل أفضل، مما يسهل عملية التصحيح وتحسين الأداء العام للبرنامج.\n\n**Note**: من المهم ملاحظة أن استخدام ReturnCode يجب أن يكون متسقًا عبر جميع الوظائف لضمان فهم واضح لحالة كل عملية."
      ],
      "code_start_line": 56,
      "code_end_line": 65,
      "params": [],
      "have_return": false,
      "code_content": "class ReturnCode(enum.IntEnum):\n    SUCCESS = 0\n    INTEGRITY_FAILURE = 1\n    FILE_GET_FAILED = 4\n    FILE_MISSING_FROM_ONE_HOST = 5\n    FILES_NOT_EQUAL = 6\n    NO_BINARIES_MATCH = 7\n    NOT_ENOUGH_GOOD_SIGS = 9\n    BINARY_DOWNLOAD_FAILED = 10\n    BAD_VERSION = 11\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/get_files_from_hosts_and_compare",
        "dataset/verify.py/verify_shasums_signature",
        "dataset/verify.py/verify_binary_hashes",
        "dataset/verify.py/verify_published_handler",
        "dataset/verify.py/verify_binaries_handler"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "set_up_logger",
      "md_content": [
        "**set_up_logger**: The function of set_up_logger is إعداد مسجل يسجل الرسائل إلى stderr.\n\n**parameters**: The parameters of this Function.\n· is_verbose: bool = True - يحدد ما إذا كان يجب تسجيل الرسائل بمستوى معلوماتي (INFO) أو تحذيري (WARNING).\n\n**Code Description**: \nتقوم دالة set_up_logger بإعداد مسجل (logger) يستخدم لتسجيل الرسائل. يتم استخدام مكتبة logging في بايثون لإنشاء هذا المسجل. عند استدعاء الدالة، يتم تحديد مستوى التسجيل بناءً على قيمة المعامل is_verbose. إذا كانت القيمة True، يتم تعيين مستوى التسجيل إلى INFO، مما يعني أنه سيتم تسجيل الرسائل بمستوى المعلومات وما فوق. إذا كانت القيمة False، يتم تعيين مستوى التسجيل إلى WARNING، مما يعني أنه سيتم تسجيل الرسائل التحذيرية وما فوق فقط.\n\nتقوم الدالة أيضًا بإنشاء معالج تدفق (StreamHandler) يقوم بتوجيه الرسائل إلى stderr (الإخراج القياسي للأخطاء). يتم تعيين مستوى هذا المعالج إلى DEBUG، مما يعني أنه يمكنه تسجيل جميع الرسائل بمستوى DEBUG وما فوق. بعد ذلك، يتم إعداد تنسيق الرسائل باستخدام Formatter، حيث يتم عرض مستوى الرسالة ونص الرسالة. وأخيرًا، يتم إضافة المعالج إلى المسجل وإرجاع المسجل المعد.\n\n**Note**: يجب الانتباه إلى أن استخدام is_verbose كقيمة افتراضية True يعني أن الرسائل بمستوى المعلومات ستكون مسجلة بشكل افتراضي، مما قد يكون مفيدًا أثناء التطوير ولكن قد يتطلب تعديلات في بيئات الإنتاج.\n\n**Output Example**: \nعند استدعاء الدالة set_up_logger() مع القيمة الافتراضية، قد يظهر الإخراج كالتالي عند تسجيل رسالة:\n```\n[INFO] هذه رسالة معلوماتية\n```"
      ],
      "code_start_line": 68,
      "code_end_line": 77,
      "params": [
        "is_verbose"
      ],
      "have_return": true,
      "code_content": "def set_up_logger(is_verbose: bool = True) -> logging.Logger:\n    \"\"\"Set up a logger that writes to stderr.\"\"\"\n    log = logging.getLogger(__name__)\n    log.setLevel(logging.INFO if is_verbose else logging.WARNING)\n    console = logging.StreamHandler(sys.stderr)  # log to stderr\n    console.setLevel(logging.DEBUG)\n    formatter = logging.Formatter('[%(levelname)s] %(message)s')\n    console.setFormatter(formatter)\n    log.addHandler(console)\n    return log\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "indent",
      "md_content": [
        "**indent**: The function of indent is إضافة مسافة بادئة إلى نص معين.\n\n**parameters**: The parameters of this Function.\n· output: نص الإدخال الذي سيتم إضافة المسافة البادئة إليه.\n\n**Code Description**: تقوم دالة indent بإضافة مسافة بادئة إلى النص المقدم كمدخل. تستخدم هذه الدالة مكتبة textwrap في بايثون، والتي توفر أدوات لتنسيق النصوص. عند استدعاء هذه الدالة، يتم تمرير نص معين، وتقوم الدالة بإرجاع النص نفسه مع إضافة مسافة بادئة من مسافتين في بداية كل سطر. \n\nتظهر أهمية هذه الدالة في سياق استخدامها في دوال أخرى مثل files_are_equal وget_files_from_hosts_and_compare وcheck_multisig وverify_shasums_signature. في هذه الدوال، يتم استخدام indent لتنسيق المخرجات النصية، مثل رسائل الخطأ أو التحذيرات، مما يسهل قراءتها وفهمها. على سبيل المثال، في دالة files_are_equal، يتم استخدام indent لتنسيق الاختلافات بين الملفات عند عدم تطابق محتوياتها، مما يساعد المطورين على تحديد المشكلات بسرعة أكبر.\n\n**Note**: يجب التأكد من أن النص المدخل إلى الدالة ليس فارغًا، حيث أن النص الفارغ سيؤدي إلى إرجاع نص فارغ مع مسافة بادئة، مما قد يكون غير مفيد في بعض الحالات.\n\n**Output Example**: إذا كانت قيمة output هي \"Hello\\nWorld\"، فإن نتيجة الدالة ستكون:\n```\n  Hello\n  World\n```"
      ],
      "code_start_line": 83,
      "code_end_line": 84,
      "params": [
        "output"
      ],
      "have_return": true,
      "code_content": "def indent(output: str) -> str:\n    return textwrap.indent(output, '  ')\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/files_are_equal",
        "dataset/verify.py/get_files_from_hosts_and_compare",
        "dataset/verify.py/check_multisig",
        "dataset/verify.py/verify_shasums_signature",
        "dataset/verify.py/verify_published_handler"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "bool_from_env",
      "md_content": [
        "**bool_from_env**: The function of bool_from_env is استرجاع قيمة من متغير بيئة على شكل قيمة منطقية.\n\n**parameters**: The parameters of this Function.\n· parameter1: key - المفتاح الذي يمثل اسم متغير البيئة المطلوب استرجاع قيمته.\n· parameter2: default - القيمة الافتراضية التي سيتم إرجاعها إذا لم يكن هناك متغير بيئة بالاسم المحدد (افتراضيًا False).\n\n**Code Description**: \nتقوم دالة bool_from_env بالتحقق مما إذا كان هناك متغير بيئة بالاسم المحدد في المعامل الأول (key). إذا لم يكن المتغير موجودًا، فإنها تعيد القيمة الافتراضية المحددة في المعامل الثاني (default). إذا كان المتغير موجودًا، تقوم الدالة بقراءة قيمته وتحويلها إلى قيمة منطقية. إذا كانت القيمة تساوي '1' أو 'true' (بغض النظر عن حالة الأحرف)، فإن الدالة تعيد True. إذا كانت القيمة تساوي '0' أو 'false'، فإنها تعيد False. في حالة وجود قيمة غير معروفة، يتم رفع استثناء ValueError مع رسالة توضح القيمة غير المعروفة.\n\nتستخدم هذه الدالة في مشروع verify.py، حيث يتم استدعاؤها لتحديد القيم الافتراضية للخيارات المختلفة عند تنفيذ البرنامج. على سبيل المثال، يتم استخدامها لتحديد ما إذا كان يجب تشغيل البرنامج في وضع verbose أو quiet، أو ما إذا كان يجب استيراد مفاتيح جديدة. هذا يسمح للمستخدمين بتخصيص سلوك البرنامج بناءً على إعدادات البيئة الخاصة بهم.\n\n**Note**: يجب التأكد من أن القيم المستخدمة في متغيرات البيئة تتوافق مع القيم المتوقعة ('1', 'true', '0', 'false') لتجنب رفع استثناءات غير مرغوب فيها.\n\n**Output Example**: \nإذا كان متغير البيئة 'BINVERIFY_VERBOSE' موجودًا ويحتوي على القيمة 'true'، فإن الدالة ستعيد True. إذا لم يكن متغير البيئة موجودًا، فستعيد القيمة الافتراضية المحددة، والتي هي False."
      ],
      "code_start_line": 87,
      "code_end_line": 96,
      "params": [
        "key",
        "default"
      ],
      "have_return": true,
      "code_content": "def bool_from_env(key, default=False) -> bool:\n    if key not in os.environ:\n        return default\n    raw = os.environ[key]\n\n    if raw.lower() in ('1', 'true'):\n        return True\n    elif raw.lower() in ('0', 'false'):\n        return False\n    raise ValueError(f\"Unrecognized environment value {key}={raw!r}\")\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/main"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "parse_version_string",
      "md_content": [
        "**parse_version_string**: The function of parse_version_string is تحليل سلسلة الإصدار.\n\n**parameters**: \n· version_str: سلسلة نصية تمثل إصدار البرنامج، والتي قد تحتوي على معلومات إضافية مثل \"rc\" أو نظام التشغيل.\n\n**Code Description**: \nتقوم دالة parse_version_string بتحليل سلسلة الإصدار المقدمة كمعامل. تبدأ الدالة بتقسيم السلسلة إلى أجزاء باستخدام الفاصل \"-\"، حيث يتم تخزين الجزء الأول في متغير version_base. إذا كانت السلسلة تحتوي على جزءين، يتم التحقق مما إذا كان الجزء الثاني يحتوي على \"rc\" لتحديد ما إذا كان الإصدار هو إصدار مرشح (release candidate) أو نظام تشغيل. في حالة وجود ثلاثة أجزاء، يتم تعيين الجزء الثاني كإصدار مرشح والجزء الثالث كنظام تشغيل. في النهاية، تقوم الدالة بإرجاع ثلاثة قيم: version_base، version_rc، وversion_os.\n\nتستخدم هذه الدالة في سياق دالة verify_published_handler، حيث يتم استدعاؤها لتحليل سلسلة الإصدار التي يتم تمريرها كجزء من معلمات الدالة. إذا كانت السلسلة غير صحيحة أو لا تتبع التنسيق المتوقع، يتم تسجيل خطأ وإرجاع رمز خطأ. هذا يضمن أن الدالة verify_published_handler تعمل مع معلومات إصدار صحيحة قبل المتابعة إلى خطوات التحقق من الملفات.\n\n**Note**: يجب التأكد من أن سلسلة الإصدار تتبع التنسيق الصحيح، وإلا ستؤدي إلى أخطاء في معالجة البيانات.\n\n**Output Example**: \nإذا كانت سلسلة الإصدار المدخلة هي \"1.0.0-rc1-linux\"، فإن القيم المرجعة ستكون:\n- version_base: \"1.0.0\"\n- version_rc: \"rc1\"\n- version_os: \"linux\""
      ],
      "code_start_line": 102,
      "code_end_line": 116,
      "params": [
        "version_str"
      ],
      "have_return": true,
      "code_content": "def parse_version_string(version_str):\n    parts = version_str.split('-')\n    version_base = parts[0]\n    version_rc = \"\"\n    version_os = \"\"\n    if len(parts) == 2:  # \"<version>-rcN\" or \"version-platform\"\n        if \"rc\" in parts[1]:\n            version_rc = parts[1]\n        else:\n            version_os = parts[1]\n    elif len(parts) == 3:  # \"<version>-rcN-platform\"\n        version_rc = parts[1]\n        version_os = parts[2]\n\n    return version_base, version_rc, version_os\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/verify_published_handler"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "download_with_wget",
      "md_content": [
        "**download_with_wget**: The function of download_with_wget is تحميل ملف من الإنترنت باستخدام أداة wget.\n\n**parameters**: The parameters of this Function.\n· parameter1: remote_file - عنوان URL للملف الذي سيتم تحميله.\n· parameter2: local_file - اسم الملف المحلي الذي سيتم حفظ الملف المحمل فيه.\n\n**Code Description**: تقوم الدالة download_with_wget بتنفيذ عملية تحميل ملف من مصدر بعيد باستخدام أداة wget. يتم تمرير عنوان URL للملف المراد تحميله واسم الملف المحلي الذي سيتم حفظه فيه كمعاملات. تستخدم الدالة subprocess.run لتشغيل أمر wget، حيث يتم توجيه الإخراج القياسي (stdout) والأخطاء (stderr) إلى المتغيرات المناسبة. تعيد الدالة قيمة منطقية تشير إلى نجاح العملية (True إذا تم التحميل بنجاح، وFalse إذا فشلت) بالإضافة إلى الإخراج الناتج عن أمر wget.\n\nتُستخدم هذه الدالة في سياق أكبر من خلال استدعائها في دوال أخرى مثل get_files_from_hosts_and_compare و verify_published_handler. في get_files_from_hosts_and_compare، يتم استخدام download_with_wget لتحميل الملفات من مجموعة من المضيفين والتحقق من تطابق المحتويات. بينما في verify_published_handler، يتم استخدامها لتحميل ملفات التوقيع وملفات المجموعات (SUMS) من مضيفين محددين، مما يساهم في عملية التحقق من سلامة الملفات المحملة.\n\n**Note**: من المهم التأكد من أن أداة wget مثبتة على النظام قبل استخدام هذه الدالة، حيث تعتمد على وجودها لتنفيذ عملية التحميل.\n\n**Output Example**: \nيمكن أن تكون نتيجة الدالة كما يلي:\n```python\n(success, output) = download_with_wget(\"http://example.com/file.txt\", \"local_file.txt\")\n# حيث success سيكون True إذا تم التحميل بنجاح، وoutput يحتوي على نص الإخراج من wget.\n```"
      ],
      "code_start_line": 119,
      "code_end_line": 122,
      "params": [
        "remote_file",
        "local_file"
      ],
      "have_return": true,
      "code_content": "def download_with_wget(remote_file, local_file):\n    result = subprocess.run(['wget', '-O', local_file, remote_file],\n                            stderr=subprocess.STDOUT, stdout=subprocess.PIPE)\n    return result.returncode == 0, result.stdout.decode().rstrip()\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/get_files_from_hosts_and_compare",
        "dataset/verify.py/verify_published_handler"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "download_lines_with_urllib",
      "md_content": [
        "**download_lines_with_urllib**: وظيفة download_lines_with_urllib هي الحصول على (نجاح، خطوط نصية من ملف) عبر HTTP.\n\n**parameters**: معلمات هذه الوظيفة.\n· url: عنوان URL للملف الذي سيتم تحميله.\n\n**Code Description**: تقوم وظيفة download_lines_with_urllib بمحاولة تحميل محتوى نصي من ملف موجود على الإنترنت باستخدام بروتوكول HTTP. تأخذ الوظيفة عنوان URL كمعامل، وتقوم بإجراء طلب HTTP للحصول على محتوى الملف. إذا كان الطلب ناجحًا، تقوم الوظيفة بقراءة كل سطر من المحتوى، وتقوم بإزالة المسافات البيضاء من البداية والنهاية، ثم تعيد قائمة تحتوي على هذه الأسطر. إذا حدث خطأ أثناء الطلب، مثل HTTPError، يتم تسجيل تحذير مع تفاصيل الخطأ، وتعيد الوظيفة قيمة (False، قائمة فارغة) للإشارة إلى الفشل في تحميل البيانات.\n\n**Note**: من المهم التأكد من أن عنوان URL صالح وأن الملف المطلوب متاح على الخادم. يجب أن تكون مكتبة urllib مستوردة في بداية البرنامج لاستخدام هذه الوظيفة بشكل صحيح.\n\n**Output Example**: قد تكون نتيجة الوظيفة كما يلي:\n(True, ['السطر الأول من النص', 'السطر الثاني من النص', 'السطر الثالث من النص'])"
      ],
      "code_start_line": 125,
      "code_end_line": 134,
      "params": [
        "url"
      ],
      "have_return": true,
      "code_content": "def download_lines_with_urllib(url) -> t.Tuple[bool, t.List[str]]:\n    \"\"\"Get (success, text lines of a file) over HTTP.\"\"\"\n    try:\n        return (True, [\n            line.strip().decode() for line in urllib.request.urlopen(url).readlines()])\n    except urllib.error.HTTPError as e:\n        log.warning(f\"HTTP request to {url} failed (HTTPError): {e}\")\n    except Exception as e:\n        log.warning(f\"HTTP request to {url} failed ({e})\")\n    return (False, [])\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "verify_with_gpg",
      "md_content": [
        "**verify_with_gpg**: The function of verify_with_gpg is التحقق من صحة ملف باستخدام GPG.\n\n**parameters**: The parameters of this Function.\n· filename: اسم الملف الذي سيتم التحقق من صحته.  \n· signature_filename: اسم ملف التوقيع الذي سيتم استخدامه للتحقق.  \n· output_filename: اسم الملف الذي سيتم تخزين الناتج فيه (اختياري).  \n\n**Code Description**: تقوم الدالة verify_with_gpg بالتحقق من صحة ملف معين باستخدام أداة GPG. يتم تمرير اسم الملف واسم ملف التوقيع كمعاملات أساسية. إذا تم توفير اسم ملف للإخراج، فسيتم استخدامه لتخزين الناتج، وإلا سيتم تركه فارغًا. \n\nتقوم الدالة بإنشاء ملف مؤقت لتخزين حالة التحقق، ثم تقوم ببناء قائمة من الأوامر التي سيتم تمريرها إلى GPG. يتم ضبط البيئة لتكون اللغة الإنجليزية. بعد ذلك، يتم تنفيذ الأمر باستخدام subprocess.run، حيث يتم التقاط كل من الإخراج والأخطاء. \n\nبعد تنفيذ الأمر، يتم قراءة البيانات من ملف الحالة المؤقت وفك تشفيرها. يتم تسجيل نتائج GPG باستخدام log.debug، حيث يتم تضمين كود الإرجاع والناتج. في النهاية، تعيد الدالة كود الإرجاع وبيانات GPG.\n\nتُستخدم هذه الدالة في سياق الدالة check_multisig، التي تتحقق من صحة التوقيع لملف معين. تقوم check_multisig باستدعاء verify_with_gpg للتحقق من صحة ملف التوقيع، ثم تقوم بتحليل الناتج. إذا كانت هناك توقيعات غير موثوقة، يمكن أن تطلب من المستخدم استرداد المفاتيح المفقودة قبل إعادة التحقق. \n\n**Note**: يجب التأكد من أن GPG مثبتة ومهيأة بشكل صحيح على النظام قبل استخدام هذه الدالة. كما يجب أن تكون الملفات المقدمة موجودة وقابلة للوصول.\n\n**Output Example**: قد يكون الناتج من الدالة على الشكل التالي:\n```\n(0, \"gpg: Signature made ...\\ngpg: Good signature from ...\")\n```"
      ],
      "code_start_line": 137,
      "code_end_line": 154,
      "params": [
        "filename",
        "signature_filename",
        "output_filename"
      ],
      "have_return": true,
      "code_content": "def verify_with_gpg(\n    filename,\n    signature_filename,\n    output_filename: t.Optional[str] = None\n) -> t.Tuple[int, str]:\n    with tempfile.NamedTemporaryFile() as status_file:\n        args = [\n            'gpg', '--yes', '--verify', '--verify-options', 'show-primary-uid-only', \"--status-file\", status_file.name,\n            '--output', output_filename if output_filename else '', signature_filename, filename]\n\n        env = dict(os.environ, LANGUAGE='en')\n        result = subprocess.run(args, stderr=subprocess.STDOUT, stdout=subprocess.PIPE, env=env)\n\n        gpg_data = status_file.read().decode().rstrip()\n\n    log.debug(f'Result from GPG ({result.returncode}): {result.stdout.decode()}')\n    log.debug(f\"{gpg_data}\")\n    return result.returncode, gpg_data\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/check_multisig"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "remove_files",
      "md_content": [
        "**remove_files**: The function of remove_files is حذف الملفات المحددة من النظام.\n\n**parameters**: The parameters of this Function.\n· parameter1: filenames - قائمة تحتوي على أسماء الملفات التي سيتم حذفها.\n\n**Code Description**: تقوم دالة remove_files بأخذ قائمة من أسماء الملفات كمدخلات، ثم تقوم بحذف كل ملف من هذه القائمة باستخدام دالة os.remove. يتم تنفيذ عملية الحذف من خلال حلقة for، حيث يتم تكرار كل اسم ملف في القائمة واستدعاء دالة os.remove لكل اسم. من المهم أن تكون الملفات الموجودة في القائمة موجودة بالفعل في النظام، وإلا ستظهر رسالة خطأ تفيد بعدم وجود الملف.\n\n**Note**: نقاط يجب مراعاتها عند استخدام الكود:\n- تأكد من أن الملفات التي ترغب في حذفها ليست قيد الاستخدام من قبل أي عملية أخرى.\n- كن حذرًا عند استخدام هذه الدالة، حيث أن حذف الملفات لا يمكن التراجع عنه، مما يعني أنه سيتم فقدان البيانات بشكل دائم.\n- من المستحسن إجراء فحص أو تأكيد قبل تنفيذ عملية الحذف لتجنب حذف الملفات الهامة عن طريق الخطأ."
      ],
      "code_start_line": 157,
      "code_end_line": 159,
      "params": [
        "filenames"
      ],
      "have_return": false,
      "code_content": "def remove_files(filenames):\n    for filename in filenames:\n        os.remove(filename)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "SigData",
      "md_content": [
        "**SigData**: وظيفة SigData هي تمثيل بيانات التوقيع GPG كما تم تحليلها من مخرجات GPG.\n\n**attributes**: خصائص هذه الفئة.\n· key: تمثل مفتاح التوقيع، ويمكن أن تكون None إذا لم يتم تعيينها.\n· name: تمثل اسم التوقيع، وهو سلسلة نصية.\n· trusted: تمثل حالة الثقة في التوقيع، وهي قيمة منطقية (True أو False).\n· status: تمثل حالة التوقيع، وهي سلسلة نصية تصف حالة التوقيع (مثل \"expired\" أو \"revoked\").\n\n**Code Description**: \nتعتبر فئة SigData هيكل بيانات يستخدم لتمثيل معلومات التوقيع الناتجة عن عملية التحقق من التوقيع باستخدام GPG. تحتوي الفئة على أربعة خصائص رئيسية: key، name، trusted، وstatus. يتم تعيين قيمة key إلى None بشكل افتراضي، مما يعني أنه لم يتم تعيين مفتاح بعد. يتم تعيين name كسلسلة نصية فارغة، وtrusted كقيمة False بشكل افتراضي، مما يشير إلى أن التوقيع غير موثوق به حتى يتم التأكيد على عكس ذلك. يمكن أن تحتوي status على معلومات إضافية حول حالة التوقيع، مثل ما إذا كان قد تم إلغاؤه أو انتهت صلاحيته.\n\nتتضمن الفئة أيضًا دالة __bool__ التي تعيد True إذا كان هناك مفتاح معين (أي أن key ليس None)، مما يسمح باستخدام الكائن في سياقات تتطلب قيمة منطقية. كما تحتوي على دالة __repr__ التي توفر تمثيلًا نصيًا للكائن، مما يسهل فهم حالة التوقيع عند الطباعة.\n\nتستخدم فئة SigData في عدة دوال في المشروع، مثل parse_gpg_result وcheck_multisig وverify_shasums_signature. في دالة parse_gpg_result، يتم تحليل مخرجات GPG إلى قائمة من كائنات SigData، حيث يتم تصنيف التوقيعات إلى جيدة وغير معروفة وسيئة. يتم استخدام هذه الكائنات لاحقًا في دالة check_multisig للتحقق من التوقيعات المتعددة، وفي دالة verify_shasums_signature لتأكيد صحة التوقيعات.\n\n**Note**: من المهم ملاحظة أن الكائنات من فئة SigData تُستخدم لتخزين معلومات التوقيع، ويجب أن يتم التعامل معها بعناية لضمان دقة المعلومات المستخرجة من مخرجات GPG.\n\n**Output Example**: \nيمكن أن يبدو مخرجات الكود كالتالي:\n```\nSigData(key='ABC123', name='Example Signature', trusted=True, status='valid')\n```"
      ],
      "code_start_line": 162,
      "code_end_line": 176,
      "params": [],
      "have_return": true,
      "code_content": "class SigData:\n    \"\"\"GPG signature data as parsed from GPG stdout.\"\"\"\n    def __init__(self):\n        self.key = None\n        self.name = \"\"\n        self.trusted = False\n        self.status = \"\"\n\n    def __bool__(self):\n        return self.key is not None\n\n    def __repr__(self):\n        return (\n            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n            (self.key, self.name, self.trusted, self.status))\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/parse_gpg_result",
        "dataset/verify.py/check_multisig",
        "dataset/verify.py/verify_shasums_signature"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the class with default attribute values.\n\n**parameters**: The parameters of this Function.\n· لا توجد معلمات.\n\n**Code Description**: هذه الدالة هي مُنشئ (constructor) تستخدم لتهيئة كائن من الفئة. عند استدعاء هذه الدالة، يتم تعيين القيم الافتراضية للسمات التالية:\n- `self.key`: يتم تعيينه إلى `None`، مما يعني أنه لا يوجد مفتاح محدد عند إنشاء الكائن.\n- `self.name`: يتم تعيينه إلى سلسلة فارغة `\"\"`، مما يشير إلى أن الاسم غير محدد بعد.\n- `self.trusted`: يتم تعيينه إلى `False`، مما يعني أن الكائن غير موثوق به بشكل افتراضي.\n- `self.status`: يتم تعيينه إلى سلسلة فارغة `\"\"`، مما يعني أن الحالة غير محددة.\n\nبشكل عام، هذه الدالة تضمن أن كل كائن يتم إنشاؤه من هذه الفئة يبدأ بحالة معروفة وقيم افتراضية، مما يسهل إدارة الكائنات في البرنامج.\n\n**Note**: من المهم ملاحظة أن هذه الدالة لا تأخذ أي معلمات عند استدعائها، مما يجعلها بسيطة وسهلة الاستخدام. يجب على المطورين التأكد من تحديث السمات بعد إنشاء الكائن إذا كانت هناك حاجة لتعيين قيم معينة."
      ],
      "code_start_line": 164,
      "code_end_line": 168,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def __init__(self):\n        self.key = None\n        self.name = \"\"\n        self.trusted = False\n        self.status = \"\"\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__bool__",
      "md_content": [
        "**__bool__**: The function of __bool__ is تحديد ما إذا كانت الكائنات تحتوي على مفتاح صالح أم لا.\n\n**parameters**: لا توجد معلمات لهذه الدالة.\n\n**Code Description**: تقوم دالة __bool__ بإرجاع قيمة منطقية (Boolean) تحدد ما إذا كان الكائن يحتوي على مفتاح صالح. يتم ذلك من خلال التحقق مما إذا كانت الخاصية `key` غير فارغة (أي ليست None). إذا كانت `key` تحتوي على قيمة، فإن الدالة تعيد True، مما يعني أن الكائن يعتبر \"صحيحًا\" أو \"موجودًا\". أما إذا كانت `key` تساوي None، فإن الدالة تعيد False، مما يعني أن الكائن يعتبر \"غير موجود\" أو \"غير صحيح\". هذه الدالة مفيدة في حالات التحقق من وجود الكائنات أو استخدامها في الشروط.\n\n**Note**: من المهم ملاحظة أن هذه الدالة تعتمد على وجود خاصية `key` في الكائن. إذا لم تكن الخاصية موجودة أو لم يتم تعيينها، فقد يؤدي ذلك إلى سلوك غير متوقع.\n\n**Output Example**: \n- إذا كانت `key` تساوي \"abc\"، فإن الدالة ستعيد True.\n- إذا كانت `key` تساوي None، فإن الدالة ستعيد False."
      ],
      "code_start_line": 170,
      "code_end_line": 171,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __bool__(self):\n        return self.key is not None\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__repr__",
      "md_content": [
        "**__repr__**: The function of __repr__ is إرجاع تمثيل نصي لكائن SigData.\n\n**parameters**: لا توجد معلمات لهذا الدالة.\n\n**Code Description**: تقوم دالة __repr__ بإرجاع تمثيل نصي لكائن من نوع SigData. يتم استخدام هذه الدالة عادةً لتوفير معلومات مفيدة عند طباعة الكائن أو عند استخدامه في بيئات تفاعلية. في هذا التمثيل النصي، يتم تضمين الخصائص الأساسية للكائن، وهي: المفتاح (key)، الاسم (name)، الثقة (trusted)، والحالة (status). يتم تنسيق هذه القيم في سلسلة نصية باستخدام صيغة معينة، مما يسهل على المطورين فهم حالة الكائن بسرعة.\n\n**Note**: من المهم ملاحظة أن دالة __repr__ يجب أن تعكس بدقة الحالة الحالية للكائن، حيث يمكن أن تكون هذه المعلومات مفيدة في تصحيح الأخطاء أو أثناء تطوير البرمجيات.\n\n**Output Example**: قد يكون مظهر القيمة المرجعة من هذه الدالة كما يلي: \nSigData('12345', 'ExampleName', trusted=True, status='active')"
      ],
      "code_start_line": 173,
      "code_end_line": 176,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def __repr__(self):\n        return (\n            \"SigData(%r, %r, trusted=%s, status=%r)\" %\n            (self.key, self.name, self.trusted, self.status))\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "parse_gpg_result",
      "md_content": [
        "**parse_gpg_result**: وظيفة parse_gpg_result هي تحليل مخرجات GPG لاسترجاع التوقيعات الجيدة وغير المعروفة والسيئة.\n\n**parameters**: المعلمات لهذه الوظيفة.\n· output: قائمة من السلاسل النصية تمثل مخرجات GPG.\n\n**Code Description**: تقوم دالة parse_gpg_result بتحليل مخرجات GPG التي يتم تمريرها كقائمة من السلاسل النصية. الهدف من هذه الدالة هو تصنيف التوقيعات المستخرجة إلى ثلاث فئات: التوقيعات الجيدة (good signatures)، التوقيعات غير المعروفة (unknown signatures)، والتوقيعات السيئة (bad signatures). يتم استخدام كائنات من فئة SigData لتخزين معلومات كل توقيع.\n\nتبدأ الدالة بتعريف ثلاث قوائم فارغة لتخزين التوقيعات الجيدة وغير المعروفة والسيئة. كما يتم تعريف دالة داخلية line_begins_with للتحقق مما إذا كانت السطور تبدأ بنمط معين، مما يساعد في منع إدخال بيانات ضارة.\n\nتقوم الدالة بعد ذلك بقراءة كل سطر في مخرجات GPG. بناءً على الأنماط المحددة، يتم تصنيف كل توقيع إلى الفئة المناسبة. على سبيل المثال، إذا كان السطر يحتوي على \"GOODSIG\"، يتم إضافة التوقيع إلى قائمة التوقيعات الجيدة. إذا كان السطر يحتوي على \"BADSIG\"، يتم إضافته إلى قائمة التوقيعات السيئة.\n\nبعد معالجة جميع السطور، يتم التحقق من أن العدد الإجمالي للتوقيعات المستخرجة يتطابق مع العدد المتوقع، وإذا لم يكن كذلك، يتم رفع استثناء. في النهاية، تعيد الدالة ثلاث قوائم: التوقيعات الجيدة، التوقيعات غير المعروفة، والتوقيعات السيئة.\n\nتُستخدم هذه الدالة في دالة check_multisig، حيث يتم استدعاؤها لتحليل مخرجات GPG بعد التحقق من التوقيعات. يتم تمرير المخرجات الناتجة عن عملية التحقق إلى parse_gpg_result، مما يسمح بتصنيف التوقيعات ومعالجة النتائج بشكل مناسب.\n\n**Note**: من المهم التأكد من أن مخرجات GPG الممررة إلى الدالة تتبع التنسيق المتوقع لضمان دقة التحليل. كما يجب التعامل مع كائنات SigData الناتجة بعناية لضمان دقة المعلومات المستخرجة.\n\n**Output Example**: يمكن أن يبدو مخرجات الكود كالتالي:\n```\n([SigData(key='ABC123', name='Example Signature', trusted=True, status='valid')],\n [SigData(key='XYZ789', name='Unknown Signature', trusted=False, status='')],\n [SigData(key='DEF456', name='Bad Signature', trusted=False, status='')])\n```"
      ],
      "code_start_line": 179,
      "code_end_line": 244,
      "params": [
        "output"
      ],
      "have_return": true,
      "code_content": "def parse_gpg_result(\n    output: t.List[str]\n) -> t.Tuple[t.List[SigData], t.List[SigData], t.List[SigData]]:\n    \"\"\"Returns good, unknown, and bad signatures from GPG stdout.\"\"\"\n    good_sigs: t.List[SigData] = []\n    unknown_sigs: t.List[SigData] = []\n    bad_sigs: t.List[SigData] = []\n    total_resolved_sigs = 0\n\n    # Ensure that all lines we match on include a prefix that prevents malicious input\n    # from fooling the parser.\n    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n\n    curr_sigs = unknown_sigs\n    curr_sigdata = SigData()\n\n    for line in output:\n        if line_begins_with(r\"NEWSIG(?:\\s|$)\", line):\n            total_resolved_sigs += 1\n            if curr_sigdata:\n                curr_sigs.append(curr_sigdata)\n                curr_sigdata = SigData()\n            newsig_split = line.split()\n            if len(newsig_split) == 3:\n                curr_sigdata.name = newsig_split[2]\n\n        elif line_begins_with(r\"GOODSIG(?:\\s|$)\", line):\n            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n            curr_sigs = good_sigs\n\n        elif line_begins_with(r\"EXPKEYSIG(?:\\s|$)\", line):\n            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n            curr_sigs = good_sigs\n            curr_sigdata.status = \"expired\"\n\n        elif line_begins_with(r\"REVKEYSIG(?:\\s|$)\", line):\n            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n            curr_sigs = good_sigs\n            curr_sigdata.status = \"revoked\"\n\n        elif line_begins_with(r\"BADSIG(?:\\s|$)\", line):\n            curr_sigdata.key, curr_sigdata.name = line.split(maxsplit=3)[2:4]\n            curr_sigs = bad_sigs\n\n        elif line_begins_with(r\"ERRSIG(?:\\s|$)\", line):\n            curr_sigdata.key, _, _, _, _, _ = line.split()[2:8]\n            curr_sigs = unknown_sigs\n\n        elif line_begins_with(r\"TRUST_(UNDEFINED|NEVER)(?:\\s|$)\", line):\n            curr_sigdata.trusted = False\n\n        elif line_begins_with(r\"TRUST_(MARGINAL|FULLY|ULTIMATE)(?:\\s|$)\", line):\n            curr_sigdata.trusted = True\n\n    # The last one won't have been added, so add it now\n    assert curr_sigdata\n    curr_sigs.append(curr_sigdata)\n\n    all_found = len(good_sigs + bad_sigs + unknown_sigs)\n    if all_found != total_resolved_sigs:\n        raise RuntimeError(\n            f\"failed to evaluate all signatures: found {all_found} \"\n            f\"but expected {total_resolved_sigs}\")\n\n    return (good_sigs, unknown_sigs, bad_sigs)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/check_multisig"
      ],
      "reference_who": [
        "dataset/verify.py/SigData"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "line_begins_with",
      "md_content": [
        "**line_begins_with**: The function of line_begins_with is التحقق مما إذا كانت السلسلة تبدأ بنمط معين.\n\n**parameters**: The parameters of this Function.\n· parameter1: patt - نمط السلسلة الذي سيتم التحقق منه. يجب أن يكون من نوع str.\n· parameter2: line - السلسلة التي سيتم فحصها. يجب أن تكون من نوع str.\n\n**Code Description**: هذه الدالة تستخدم للتحقق مما إذا كانت السلسلة المدخلة (line) تبدأ بنمط معين (patt) بعد وجود علامة معينة \"[GNUPG:]\". يتم استخدام تعبير عادي (regular expression) للقيام بذلك. الدالة تستخدم دالة `re.match` من مكتبة `re` في بايثون، والتي تتحقق مما إذا كانت بداية السلسلة تتطابق مع النمط المحدد. النمط المستخدم هو '^(\\[GNUPG:\\])\\s+' متبوعًا بالنمط المحدد في المتغير `patt`. إذا كانت السلسلة تبدأ بهذا النمط، ستعيد الدالة كائن `re.Match`، وإذا لم تتطابق، ستعيد `None`.\n\n**Note**: يجب التأكد من أن السلسلة المدخلة (line) تحتوي على النص \"[GNUPG:]\" في بدايتها، وإلا فلن يتم العثور على تطابق. كما يجب أن يكون النمط (patt) مصممًا بشكل صحيح ليتناسب مع ما تبحث عنه.\n\n**Output Example**: إذا كانت السلسلة المدخلة هي \"[GNUPG:] هذا هو النص\" والنمط هو \"هذا هو النص\"، ستعيد الدالة كائن `re.Match`، بينما إذا كانت السلسلة هي \"هذا هو النص\" بدون \"[GNUPG:]\"، ستعيد `None`."
      ],
      "code_start_line": 190,
      "code_end_line": 191,
      "params": [
        "patt",
        "line"
      ],
      "have_return": true,
      "code_content": "    def line_begins_with(patt: str, line: str) -> t.Optional[re.Match]:\n        return re.match(r'^(\\[GNUPG:\\])\\s+' + patt, line)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "files_are_equal",
      "md_content": [
        "**files_are_equal**: The function of files_are_equal is مقارنة محتويات ملفين والتحقق مما إذا كانت متساوية.\n\n**parameters**: The parameters of this Function.\n· filename1: اسم الملف الأول الذي سيتم مقارنته.  \n· filename2: اسم الملف الثاني الذي سيتم مقارنته.\n\n**Code Description**: تقوم دالة files_are_equal بفتح ملفين وقراءة محتوياتهما بتنسيق ثنائي (binary) للتحقق مما إذا كانت المحتويات متساوية. إذا كانت المحتويات غير متساوية، تقوم الدالة بفتح كلا الملفين مرة أخرى بتنسيق نصي (text) لقراءة الأسطر. بعد ذلك، تستخدم مكتبة difflib لإنشاء فرق (diff) بين الأسطر، وتقوم بتنسيق هذا الفرق باستخدام دالة indent لإضافة مسافة بادئة إلى النص الناتج. يتم تسجيل أي اختلافات باستخدام سجل التحذيرات (log.warning). في النهاية، تعيد الدالة قيمة Boolean تشير إلى ما إذا كانت الملفات متساوية أم لا.\n\nتُستخدم هذه الدالة في سياق دالة أخرى تُدعى get_files_from_hosts_and_compare، والتي تسترجع نفس الملف من عدة مضيفين (hosts) وتتحقق من أن المحتويات متطابقة. بعد استرجاع الملفات، تقوم الدالة بالتحقق من تساوي الملفات باستخدام دالة files_are_equal. إذا كانت الملفات غير متساوية، يتم تسجيل خطأ وإرجاع رمز يدل على عدم تساوي الملفات.\n\n**Note**: يجب التأكد من أن الملفات المدخلة موجودة وقابلة للقراءة، حيث أن محاولة فتح ملفات غير موجودة أو غير قابلة للقراءة ستؤدي إلى حدوث استثناءات.\n\n**Output Example**: إذا كانت الملفات متساوية، ستعيد الدالة القيمة True. وإذا كانت غير متساوية، ستعيد القيمة False، مع تسجيل الاختلافات في السجل."
      ],
      "code_start_line": 247,
      "code_end_line": 264,
      "params": [
        "filename1",
        "filename2"
      ],
      "have_return": true,
      "code_content": "def files_are_equal(filename1, filename2):\n    with open(filename1, 'rb') as file1:\n        contents1 = file1.read()\n    with open(filename2, 'rb') as file2:\n        contents2 = file2.read()\n    eq = contents1 == contents2\n\n    if not eq:\n        with open(filename1, 'r', encoding='utf-8') as f1, \\\n                open(filename2, 'r', encoding='utf-8') as f2:\n            f1lines = f1.readlines()\n            f2lines = f2.readlines()\n\n            diff = indent(\n                ''.join(difflib.unified_diff(f1lines, f2lines)))\n            log.warning(f\"found diff in files ({filename1}, {filename2}):\\n{diff}\\n\")\n\n    return eq\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/get_files_from_hosts_and_compare"
      ],
      "reference_who": [
        "dataset/verify.py/indent"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "get_files_from_hosts_and_compare",
      "md_content": [
        "**get_files_from_hosts_and_compare**: The function of get_files_from_hosts_and_compare is استرجاع نفس الملف من عدد من المضيفين والتأكد من أن محتوياتها متطابقة.\n\n**parameters**: The parameters of this Function.\n· hosts: قائمة من عناوين المضيفين (strings) التي سيتم استرجاع الملفات منها.  \n· path: المسار الذي يحتوي على الملف المراد استرجاعه.  \n· filename: اسم الملف الذي سيتم كتابته محليًا.  \n· require_all: قيمة منطقية تحدد ما إذا كان يجب أن يكون جميع المضيفين ناجحين في استرجاع الملف (افتراضي: False).\n\n**Code Description**: تقوم دالة get_files_from_hosts_and_compare باسترجاع ملف معين من مجموعة من المضيفين والتحقق من أن جميع الملفات المسترجعة متطابقة. يتم اعتبار المضيف الأول في القائمة هو \"المضيف الرئيسي\"، ويجب أن تنجح عملية استرجاع الملف منه. \n\nتبدأ الدالة بالتحقق من أن هناك أكثر من مضيف واحد. ثم تقوم بتعريف دالة داخلية join_url، التي تقوم بإنشاء عنوان URL للمضيفات عن طريق دمج المضيف مع المسار. بعد ذلك، يتم استرجاع الملف من المضيف الرئيسي باستخدام دالة download_with_wget. إذا فشلت هذه العملية، يتم تسجيل الخطأ وإرجاع رمز الحالة المناسب.\n\nبعد استرجاع الملف من المضيف الرئيسي، تقوم الدالة بمحاولة استرجاع نفس الملف من المضيفين الآخرين. إذا كانت قيمة require_all صحيحة، فإن أي فشل في استرجاع الملف من مضيف آخر سيؤدي إلى تسجيل خطأ وإرجاع رمز الحالة المناسب. إذا كانت القيمة False، فإن الدالة ستقوم بتسجيل تحذير ولكنها ستستمر في العمل.\n\nبعد استرجاع جميع الملفات، تقوم الدالة بمقارنة محتويات الملفات المسترجعة باستخدام دالة files_are_equal. إذا كانت الملفات غير متطابقة، يتم تسجيل خطأ وإرجاع رمز الحالة المناسب. إذا كانت جميع الملفات متطابقة، يتم إرجاع رمز الحالة SUCCESS.\n\nتستخدم هذه الدالة في سياق دالة verify_published_handler، حيث يتم استرجاع ملفات التوقيع وملفات المجموعات من مجموعة من المضيفين والتحقق من سلامتها. تعتبر get_files_from_hosts_and_compare جزءًا أساسيًا من عملية التحقق من الملفات، حيث تضمن أن الملفات المسترجعة من مصادر متعددة متطابقة قبل اتخاذ أي خطوات إضافية.\n\n**Note**: من المهم التأكد من أن المضيفين المحددين متاحين وأن المسار والملف المطلوبين صحيحين لتجنب الأخطاء أثناء عملية الاسترجاع.\n\n**Output Example**: يمكن أن تكون نتيجة الدالة كما يلي:\n```python\nReturnCode.SUCCESS\n```"
      ],
      "code_start_line": 267,
      "code_end_line": 326,
      "params": [
        "hosts",
        "path",
        "filename",
        "require_all"
      ],
      "have_return": true,
      "code_content": "def get_files_from_hosts_and_compare(\n    hosts: t.List[str], path: str, filename: str, require_all: bool = False\n) -> ReturnCode:\n    \"\"\"\n    Retrieve the same file from a number of hosts and ensure they have the same contents.\n    The first host given will be treated as the \"primary\" host, and is required to succeed.\n\n    Args:\n        filename: for writing the file locally.\n    \"\"\"\n    assert len(hosts) > 1\n    primary_host = hosts[0]\n    other_hosts = hosts[1:]\n    got_files = []\n\n    def join_url(host: str) -> str:\n        return host.rstrip('/') + '/' + path.lstrip('/')\n\n    url = join_url(primary_host)\n    success, output = download_with_wget(url, filename)\n    if not success:\n        log.error(\n            f\"couldn't fetch file ({url}). \"\n            \"Have you specified the version number in the following format?\\n\"\n            f\"{VERSION_FORMAT} \"\n            f\"(example: {VERSION_EXAMPLE})\\n\"\n            f\"wget output:\\n{indent(output)}\")\n        return ReturnCode.FILE_GET_FAILED\n    else:\n        log.info(f\"got file {url} as {filename}\")\n        got_files.append(filename)\n\n    for i, host in enumerate(other_hosts):\n        url = join_url(host)\n        fname = filename + f'.{i + 2}'\n        success, output = download_with_wget(url, fname)\n\n        if require_all and not success:\n            log.error(\n                f\"{host} failed to provide file ({url}), but {primary_host} did?\\n\"\n                f\"wget output:\\n{indent(output)}\")\n            return ReturnCode.FILE_MISSING_FROM_ONE_HOST\n        elif not success:\n            log.warning(\n                f\"{host} failed to provide file ({url}). \"\n                f\"Continuing based solely upon {primary_host}.\")\n        else:\n            log.info(f\"got file {url} as {fname}\")\n            got_files.append(fname)\n\n    for i, got_file in enumerate(got_files):\n        if got_file == got_files[-1]:\n            break  # break on last file, nothing after it to compare to\n\n        compare_to = got_files[i + 1]\n        if not files_are_equal(got_file, compare_to):\n            log.error(f\"files not equal: {got_file} and {compare_to}\")\n            return ReturnCode.FILES_NOT_EQUAL\n\n    return ReturnCode.SUCCESS\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/verify_published_handler"
      ],
      "reference_who": [
        "dataset/verify.py/ReturnCode",
        "dataset/verify.py/indent",
        "dataset/verify.py/download_with_wget",
        "dataset/verify.py/files_are_equal"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "join_url",
      "md_content": [
        "**join_url**: The function of join_url is دمج عنوان المضيف مع مسار معين بشكل صحيح.\n\n**parameters**: The parameters of this Function.\n· parameter1: host - سلسلة نصية تمثل عنوان المضيف الذي سيتم دمجه مع المسار.\n\n**Code Description**: تقوم الدالة join_url بأخذ عنوان مضيف (host) كمدخل، وتقوم بإزالة أي شرطة مائلة (/) من نهاية العنوان باستخدام الدالة rstrip، ثم تضيف شرطة مائلة واحدة، تليها المسار (path) الذي يتم إزالته من أي شرطة مائلة في البداية باستخدام الدالة lstrip. هذا يضمن أن النتيجة النهائية ستكون عنوان URL صحيحًا، حيث يتم دمج المضيف والمسار بشكل متسق دون تكرار الشرط المائل.\n\n**Note**: يجب التأكد من أن المتغير path معرف مسبقًا في السياق الذي يتم فيه استدعاء الدالة join_url، وإلا ستظهر خطأ. كما يجب الانتباه إلى أن الدالة لا تتحقق من صحة عنوان المضيف، لذا يجب التأكد من أن المدخل هو عنوان مضيف صالح.\n\n**Output Example**: إذا كان المدخل host هو \"http://example.com\" و path هو \"/path/to/resource\"، فإن النتيجة ستكون \"http://example.com/path/to/resource\"."
      ],
      "code_start_line": 282,
      "code_end_line": 283,
      "params": [
        "host"
      ],
      "have_return": true,
      "code_content": "    def join_url(host: str) -> str:\n        return host.rstrip('/') + '/' + path.lstrip('/')\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "check_multisig",
      "md_content": [
        "**check_multisig**: The function of check_multisig is التحقق من صحة التوقيعات المتعددة لملف باستخدام GPG.\n\n**parameters**: The parameters of this Function.\n· sums_file: اسم ملف المجموعات الذي يحتوي على البيانات المراد التحقق منها.  \n· sigfilename: اسم ملف التوقيع الذي سيتم استخدامه للتحقق من صحة التوقيع.  \n· args: كائن يحتوي على خيارات إضافية مثل مستوى التفاصيل (verbose) ومفتاح الخادم (keyserver).\n\n**Code Description**: تقوم دالة check_multisig بالتحقق من صحة التوقيعات المتعددة باستخدام أداة GPG. تبدأ الدالة باستدعاء دالة verify_with_gpg للتحقق من صحة ملف المجموعات باستخدام ملف التوقيع. يتم التقاط كود الإرجاع والناتج من GPG. إذا كانت خيارات verbose مفعلة، يتم تسجيل مخرجات GPG لتسهيل تتبع الأخطاء.\n\nبعد ذلك، يتم تحليل الناتج باستخدام دالة parse_gpg_result، التي تقوم بتصنيف التوقيعات إلى ثلاث فئات: التوقيعات الجيدة (good signatures)، التوقيعات غير المعروفة (unknown signatures)، والتوقيعات السيئة (bad signatures). إذا كانت هناك توقيعات غير معروفة وكان الخيار لاسترداد المفاتيح مفعلاً، يتم طلب إذن المستخدم لاسترداد المفاتيح المفقودة باستخدام دالة prompt_yn. إذا وافق المستخدم، يتم استرداد المفتاح باستخدام أمر gpg.\n\nبعد استرداد المفاتيح، يتم إعادة التحقق من التوقيعات مرة أخرى. في النهاية، تعيد الدالة كود الإرجاع، الناتج، والتوقيعات المصنفة.\n\nتُستخدم دالة check_multisig في دالة verify_shasums_signature، حيث يتم استدعاؤها للتحقق من صحة التوقيعات قبل اتخاذ قرار بشأن سلامة البيانات. إذا كان كود الإرجاع غير مقبول، يتم تسجيل الأخطاء المناسبة وإرجاع حالة الفشل. \n\n**Note**: يجب التأكد من أن GPG مثبتة ومهيأة بشكل صحيح على النظام، وأن الملفات المقدمة موجودة وقابلة للوصول. كما يجب التعامل مع المدخلات بعناية لضمان دقة النتائج.\n\n**Output Example**: قد يكون الناتج من الدالة على الشكل التالي:\n```\n(0, \"gpg: Signature made ...\\ngpg: Good signature from ...\", \n [SigData(key='ABC123', name='Example Signature', trusted=True, status='valid')],\n [SigData(key='XYZ789', name='Unknown Signature', trusted=False, status='')],\n [SigData(key='DEF456', name='Bad Signature', trusted=False, status='')])\n```"
      ],
      "code_start_line": 329,
      "code_end_line": 356,
      "params": [
        "sums_file",
        "sigfilename",
        "args"
      ],
      "have_return": true,
      "code_content": "def check_multisig(sums_file: str, sigfilename: str, args: argparse.Namespace) -> t.Tuple[int, str, t.List[SigData], t.List[SigData], t.List[SigData]]:\n    # check signature\n    #\n    # We don't write output to a file because this command will almost certainly\n    # fail with GPG exit code '2' (and so not writing to --output) because of the\n    # likely presence of multiple untrusted signatures.\n    retval, output = verify_with_gpg(sums_file, sigfilename)\n\n    if args.verbose:\n        log.info(f\"gpg output:\\n{indent(output)}\")\n\n    good, unknown, bad = parse_gpg_result(output.splitlines())\n\n    if unknown and args.import_keys:\n        # Retrieve unknown keys and then try GPG again.\n        for unsig in unknown:\n            if prompt_yn(f\" ? Retrieve key {unsig.key} ({unsig.name})? (y/N) \"):\n                ran = subprocess.run(\n                    [\"gpg\", \"--keyserver\", args.keyserver, \"--recv-keys\", unsig.key])\n\n                if ran.returncode != 0:\n                    log.warning(f\"failed to retrieve key {unsig.key}\")\n\n        # Reparse the GPG output now that we have more keys\n        retval, output = verify_with_gpg(sums_file, sigfilename)\n        good, unknown, bad = parse_gpg_result(output.splitlines())\n\n    return retval, output, good, unknown, bad\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/verify_shasums_signature"
      ],
      "reference_who": [
        "dataset/verify.py/indent",
        "dataset/verify.py/verify_with_gpg",
        "dataset/verify.py/SigData",
        "dataset/verify.py/parse_gpg_result",
        "dataset/verify.py/prompt_yn"
      ],
      "special_reference_type": [
        false,
        false,
        true,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "prompt_yn",
      "md_content": [
        "**prompt_yn**: The function of prompt_yn is إرجاع قيمة صحيحة إذا أدخل المستخدم 'y'.\n\n**parameters**: المعلمات الخاصة بهذه الدالة.\n· prompt: نص الرسالة الذي سيتم عرضه للمستخدم عند الطلب.\n\n**Code Description**: تقوم دالة prompt_yn بطلب إدخال من المستخدم، حيث تعرض رسالة محددة (المعلمة prompt) وتنتظر حتى يقوم المستخدم بإدخال إما 'y' أو 'n'. يتم تحويل الإدخال إلى أحرف صغيرة لضمان عدم التأثر بحالة الأحرف. إذا كان الإدخال غير صحيح (أي ليس 'y' أو 'n')، تستمر الدالة في الطلب من المستخدم حتى يتم إدخال قيمة صحيحة. في النهاية، تعيد الدالة قيمة صحيحة (True) إذا كان الإدخال هو 'y'، وقيمة خاطئة (False) إذا كان الإدخال هو 'n'.\n\nتستخدم هذه الدالة في دالة أخرى تُدعى check_multisig، والتي تتحقق من التوقيعات. في حالة وجود مفاتيح غير معروفة، يتم استخدام prompt_yn لطلب إذن المستخدم لاسترداد المفتاح المفقود. إذا أجاب المستخدم بـ 'y'، يتم تنفيذ أمر لاسترداد المفتاح باستخدام gpg. هذا يوضح كيف أن prompt_yn تلعب دورًا حيويًا في تحسين تجربة المستخدم من خلال توفير وسيلة للتفاعل مع المستخدم في سياق التحقق من التوقيعات.\n\n**Note**: يجب على المطورين التأكد من أن الإدخال من المستخدم يتوافق مع القيم المتوقعة ('y' أو 'n')، حيث أن أي إدخال آخر سيؤدي إلى حلقة لا نهائية حتى يتم إدخال قيمة صحيحة.\n\n**Output Example**: إذا أدخل المستخدم 'y'، ستعيد الدالة القيمة True. إذا أدخل المستخدم 'n'، ستعيد الدالة القيمة False."
      ],
      "code_start_line": 359,
      "code_end_line": 364,
      "params": [
        "prompt"
      ],
      "have_return": true,
      "code_content": "def prompt_yn(prompt) -> bool:\n    \"\"\"Return true if the user inputs 'y'.\"\"\"\n    got = ''\n    while got not in ['y', 'n']:\n        got = input(prompt).lower()\n    return got == 'y'\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/check_multisig"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "verify_shasums_signature",
      "md_content": [
        "**verify_shasums_signature**: The function of verify_shasums_signature is التحقق من صحة التوقيعات لملف SHA256SUMS باستخدام GPG.\n\n**parameters**: The parameters of this Function.\n· signature_file_path: مسار ملف التوقيع الذي يحتوي على التوقيعات المراد التحقق منها.  \n· sums_file_path: مسار ملف المجموعات الذي يحتوي على البيانات المراد التحقق منها.  \n· args: كائن يحتوي على خيارات إضافية مثل عدد التوقيعات الجيدة المطلوبة ومفتاح الخادم.\n\n**Code Description**: تقوم دالة verify_shasums_signature بالتحقق من صحة التوقيعات المرتبطة بملف SHA256SUMS. تبدأ الدالة بتحديد الحد الأدنى من التوقيعات الجيدة المطلوبة من خلال المتغير min_good_sigs، وتحدد رموز الخروج المسموح بها من GPG. يتم استدعاء دالة check_multisig للتحقق من صحة التوقيعات، والتي تعيد كود الإرجاع، الناتج، والتوقيعات المصنفة إلى جيدة وغير معروفة وسيئة.\n\nإذا كان كود الإرجاع غير مقبول، يتم تسجيل الأخطاء المناسبة وإرجاع حالة الفشل. يتم بعد ذلك تحديد المفاتيح الموثوقة بناءً على المدخلات المقدمة، ويتم حساب عدد التوقيعات الجيدة الموثوقة وغير الموثوقة. إذا كان عدد التوقيعات الجيدة أقل من الحد الأدنى المطلوب، يتم تسجيل تحذيرات وإرجاع حالة عدم كفاية التوقيعات الجيدة.\n\nتقوم الدالة أيضًا بتسجيل معلومات حول التوقيعات الجيدة، التوقيعات المنتهية، والتوقيعات السيئة وغير المعروفة. في النهاية، تعيد الدالة كود الإرجاع مع قوائم التوقيعات الجيدة الموثوقة وغير الموثوقة، والتوقيعات غير المعروفة والسيئة.\n\nتُستخدم هذه الدالة في دوال أخرى مثل verify_published_handler وverify_binaries_handler، حيث يتم استدعاؤها للتحقق من صحة التوقيعات قبل اتخاذ أي إجراءات إضافية. تعتمد هذه الدوال على نتائج verify_shasums_signature لتحديد ما إذا كانت البيانات موثوقة أم لا.\n\n**Note**: من المهم التأكد من أن جميع المدخلات صحيحة وأن GPG مثبتة بشكل صحيح على النظام. يجب التعامل مع التوقيعات بعناية لضمان دقة النتائج.\n\n**Output Example**: قد يبدو الناتج من الدالة كالتالي:\n```\n(ReturnCode.SUCCESS, \n [SigData(key='ABC123', name='Example Signature', trusted=True, status='valid')], \n [SigData(key='XYZ789', name='Untrusted Signature', trusted=False, status='')], \n [SigData(key='DEF456', name='Unknown Signature', trusted=False, status='')], \n [SigData(key='GHI789', name='Bad Signature', trusted=False, status='')])\n```"
      ],
      "code_start_line": 366,
      "code_end_line": 429,
      "params": [
        "signature_file_path",
        "sums_file_path",
        "args"
      ],
      "have_return": true,
      "code_content": "def verify_shasums_signature(\n    signature_file_path: str, sums_file_path: str, args: argparse.Namespace\n) -> t.Tuple[\n   ReturnCode, t.List[SigData], t.List[SigData], t.List[SigData], t.List[SigData]\n]:\n    min_good_sigs = args.min_good_sigs\n    gpg_allowed_codes = [0, 2]  # 2 is returned when untrusted signatures are present.\n\n    gpg_retval, gpg_output, good, unknown, bad = check_multisig(sums_file_path, signature_file_path, args)\n\n    if gpg_retval not in gpg_allowed_codes:\n        if gpg_retval == 1:\n            log.critical(f\"Bad signature (code: {gpg_retval}).\")\n        else:\n            log.critical(f\"unexpected GPG exit code ({gpg_retval})\")\n\n        log.error(f\"gpg output:\\n{indent(gpg_output)}\")\n        return (ReturnCode.INTEGRITY_FAILURE, [], [], [], [])\n\n    # Decide which keys we trust, though not \"trust\" in the GPG sense, but rather\n    # which pubkeys convince us that this sums file is legitimate. In other words,\n    # which pubkeys within the Bitcoin community do we trust for the purposes of\n    # binary verification?\n    trusted_keys = set()\n    if args.trusted_keys:\n        trusted_keys |= set(args.trusted_keys.split(','))\n\n    # Tally signatures and make sure we have enough goods to fulfill\n    # our threshold.\n    good_trusted = [sig for sig in good if sig.trusted or sig.key in trusted_keys]\n    good_untrusted = [sig for sig in good if sig not in good_trusted]\n    num_trusted = len(good_trusted) + len(good_untrusted)\n    log.info(f\"got {num_trusted} good signatures\")\n\n    if num_trusted < min_good_sigs:\n        log.info(\"Maybe you need to import \"\n                  f\"(`gpg --keyserver {args.keyserver} --recv-keys <key-id>`) \"\n                  \"some of the following keys: \")\n        log.info('')\n        for sig in unknown:\n            log.info(f\"    {sig.key} ({sig.name})\")\n        log.info('')\n        log.error(\n            \"not enough trusted sigs to meet threshold \"\n            f\"({num_trusted} vs. {min_good_sigs})\")\n\n        return (ReturnCode.NOT_ENOUGH_GOOD_SIGS, [], [], [], [])\n\n    for sig in good_trusted:\n        log.info(f\"GOOD SIGNATURE: {sig}\")\n\n    for sig in good_untrusted:\n        log.info(f\"GOOD SIGNATURE (untrusted): {sig}\")\n\n    for sig in [sig for sig in good if sig.status == 'expired']:\n        log.warning(f\"key {sig.key} for {sig.name} is expired\")\n\n    for sig in bad:\n        log.warning(f\"BAD SIGNATURE: {sig}\")\n\n    for sig in unknown:\n        log.warning(f\"UNKNOWN SIGNATURE: {sig}\")\n\n    return (ReturnCode.SUCCESS, good_trusted, good_untrusted, unknown, bad)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/verify_published_handler",
        "dataset/verify.py/verify_binaries_handler"
      ],
      "reference_who": [
        "dataset/verify.py/ReturnCode",
        "dataset/verify.py/indent",
        "dataset/verify.py/SigData",
        "dataset/verify.py/check_multisig"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "parse_sums_file",
      "md_content": [
        "**parse_sums_file**: The function of parse_sums_file is استخراج التجزئات وأسماء الملفات الثنائية للتحقق منها من ملف التجزئة.\n\n**parameters**: The parameters of this Function.\n· parameter1: sums_file_path - مسار ملف التجزئات الذي يحتوي على التجزئات وأسماء الملفات الثنائية.\n· parameter2: filename_filter - قائمة بأسماء الملفات الثنائية المراد تصفيتها.\n\n**Code Description**: تقوم دالة parse_sums_file بفتح ملف التجزئات المحدد بواسطة sums_file_path وقراءة محتوياته. كل سطر في الملف يجب أن يحتوي على تجزئة واسم ملف ثنائي مفصولين بمسافة. تقوم الدالة بتصفية النتائج بناءً على قائمة filename_filter، حيث إذا كانت القائمة فارغة، سيتم إرجاع جميع السطور. إذا كانت تحتوي على أسماء ملفات، سيتم إرجاع السطور التي تحتوي على أي من هذه الأسماء. يتم استخدام هذه الدالة في سياق دالتين أخريين: verify_published_handler و verify_binaries_handler. في الدالة verify_published_handler، يتم استدعاء parse_sums_file لاستخراج التجزئات والأسماء من ملف SUMS_FILENAME، حيث يتم استخدام os_filter لتصفية النتائج. بينما في verify_binaries_handler، يتم استخدامها لاستخراج التجزئات والأسماء من ملف محدد بواسطة args.sums_file، مع تصفية النتائج بناءً على الملفات الثنائية المحددة من قبل المستخدم. \n\n**Note**: يجب التأكد من أن ملف التجزئات موجود في المسار المحدد وأنه يتبع التنسيق الصحيح، حيث أن أي خطأ في التنسيق قد يؤدي إلى نتائج غير صحيحة أو عدم العثور على الملفات المطلوبة.\n\n**Output Example**: \nإذا كان ملف التجزئات يحتوي على السطور التالية:\n```\nabc123 binary1\ndef456 binary2\nghi789 binary3\n```\nوتم تمرير قائمة filename_filter تحتوي على ['binary1', 'binary3']، فإن الدالة ستعيد:\n```\n[['abc123', 'binary1'], ['ghi789', 'binary3']]\n```"
      ],
      "code_start_line": 432,
      "code_end_line": 436,
      "params": [
        "sums_file_path",
        "filename_filter"
      ],
      "have_return": true,
      "code_content": "def parse_sums_file(sums_file_path: str, filename_filter: t.List[str]) -> t.List[t.List[str]]:\n    # extract hashes/filenames of binaries to verify from hash file;\n    # each line has the following format: \"<hash> <binary_filename>\"\n    with open(sums_file_path, 'r', encoding='utf8') as hash_file:\n        return [line.split()[:2] for line in hash_file if len(filename_filter) == 0 or any(f in line for f in filename_filter)]\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/verify_published_handler",
        "dataset/verify.py/verify_binaries_handler"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "verify_binary_hashes",
      "md_content": [
        "**verify_binary_hashes**: وظيفة verify_binary_hashes هي التحقق من تطابق تجزئات الملفات الثنائية مع القيم المتوقعة.\n\n**parameters**: المعلمات لهذه الوظيفة.\n· hashes_to_verify: قائمة من القوائم تحتوي على تجزئات الملفات الثنائية المتوقعة وأسماء الملفات الثنائية للتحقق منها.\n\n**Code Description**: تقوم وظيفة verify_binary_hashes بالتحقق من صحة تجزئات الملفات الثنائية. تأخذ هذه الوظيفة قائمة من القوائم، حيث يحتوي كل عنصر على تجزئة متوقعة واسم ملف ثنائي. تقوم الوظيفة بفتح كل ملف ثنائي وقراءة محتوياته، ثم تحسب التجزئة باستخدام خوارزمية SHA-256. إذا كانت التجزئة المحسوبة لا تتطابق مع التجزئة المتوقعة، يتم إضافة اسم الملف إلى قائمة الملفات المخالفة. إذا كانت جميع التجزئات متطابقة، يتم تخزين أسماء الملفات والتجزئات المحسوبة في قاموس.\n\nتستخدم هذه الوظيفة رموز الحالة من فئة ReturnCode لتحديد نتيجة العملية. إذا كانت هناك ملفات مخالفة، يتم تسجيل رسالة خطأ حرجة تحتوي على أسماء الملفات المخالفة، وتعيد الوظيفة رمز الحالة INTEGRITY_FAILURE. إذا كانت جميع التجزئات متطابقة، تعيد الوظيفة رمز الحالة SUCCESS مع قاموس يحتوي على أسماء الملفات والتجزئات المحسوبة.\n\nتُستدعى هذه الوظيفة من قبل كل من verify_published_handler و verify_binaries_handler، حيث يتم استخدامها للتحقق من صحة التجزئات بعد تحميل الملفات الثنائية. في verify_published_handler، يتم استدعاء verify_binary_hashes بعد تحميل الملفات الثنائية من مضيفين مختلفين، بينما في verify_binaries_handler، يتم استدعاءها بعد التحقق من صحة ملف التجزئات SHA256SUMS. في كلا الحالتين، تساهم verify_binary_hashes في ضمان سلامة الملفات الثنائية التي يتم التعامل معها.\n\n**Note**: من المهم التأكد من أن الملفات الثنائية التي يتم التحقق منها موجودة وأن التجزئات المتوقعة صحيحة، حيث أن أي خطأ في هذه العملية قد يؤدي إلى فشل في التحقق من سلامة الملفات.\n\n**Output Example**: \n(ReturnCode.SUCCESS, {'file1.bin': 'abc123...', 'file2.bin': 'def456...'})"
      ],
      "code_start_line": 439,
      "code_end_line": 458,
      "params": [
        "hashes_to_verify"
      ],
      "have_return": true,
      "code_content": "def verify_binary_hashes(hashes_to_verify: t.List[t.List[str]]) -> t.Tuple[ReturnCode, t.Dict[str, str]]:\n    offending_files = []\n    files_to_hashes = {}\n\n    for hash_expected, binary_filename in hashes_to_verify:\n        with open(binary_filename, 'rb') as binary_file:\n            hash_calculated = sha256(binary_file.read()).hexdigest()\n        if hash_calculated != hash_expected:\n            offending_files.append(binary_filename)\n        else:\n            files_to_hashes[binary_filename] = hash_calculated\n\n    if offending_files:\n        joined_files = '\\n'.join(offending_files)\n        log.critical(\n            \"Hashes don't match.\\n\"\n            f\"Offending files:\\n{joined_files}\")\n        return (ReturnCode.INTEGRITY_FAILURE, files_to_hashes)\n\n    return (ReturnCode.SUCCESS, files_to_hashes)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/verify_published_handler",
        "dataset/verify.py/verify_binaries_handler"
      ],
      "reference_who": [
        "dataset/verify.py/ReturnCode"
      ],
      "special_reference_type": [
        true
      ]
    },
    {
      "type": "FunctionDef",
      "name": "verify_published_handler",
      "md_content": [
        "**verify_published_handler**: The function of verify_published_handler is التحقق من صحة التوقيعات والملفات الثنائية لإصدار محدد من برنامج Bitcoin.\n\n**parameters**: The parameters of this Function.\n· args: كائن من نوع argparse.Namespace يحتوي على المعلمات المدخلة من سطر الأوامر، بما في ذلك إصدار Bitcoin المراد التحقق منه وخيارات إضافية مثل التنظيف وإلزام جميع المضيفين.\n\n**Code Description**: تقوم دالة verify_published_handler بتنفيذ عملية التحقق من صحة التوقيعات والملفات الثنائية لإصدار محدد من برنامج Bitcoin. تبدأ الدالة بتحديد دليل العمل المؤقت الذي سيتم استخدامه لتخزين الملفات المؤقتة. يتم تنفيذ عملية تنظيف في حالة الحاجة، حيث يتم حذف الملفات المؤقتة بعد الانتهاء من العملية.\n\nتقوم الدالة أولاً بتحليل سلسلة الإصدار المدخلة باستخدام دالة parse_version_string، حيث يتم استخراج المعلومات الأساسية مثل الإصدار الأساسي، وإصدار المرشح (إذا كان موجودًا)، ونظام التشغيل. إذا كانت سلسلة الإصدار غير صحيحة، يتم تسجيل خطأ وإرجاع رمز الحالة BAD_VERSION.\n\nبعد ذلك، يتم تحديد المسارات البعيدة للملفات التي سيتم التحقق منها، بما في ذلك ملفات التوقيع وملفات المجموعات (SUMS). يتم استخدام دالة get_files_from_hosts_and_compare لاسترجاع هذه الملفات من مجموعة من المضيفين والتحقق من تطابقها. إذا فشلت هذه العملية، يتم إرجاع رمز الحالة المناسب.\n\nتتطلب عملية التحقق من صحة التوقيعات أن يكون الإصدار 22.0 أو أعلى، حيث يتم التحقق من صحة التوقيعات باستخدام دالة verify_shasums_signature. إذا كانت التوقيعات غير صحيحة، يتم تنفيذ عملية التنظيف وإرجاع رمز الحالة INTEGRITY_FAILURE.\n\nبعد التحقق من صحة التوقيعات، يتم استخراج التجزئات وأسماء الملفات الثنائية باستخدام دالة parse_sums_file. إذا لم تتطابق أي من الملفات الثنائية مع النظام المحدد، يتم إرجاع رمز الحالة NO_BINARIES_MATCH.\n\nتقوم الدالة بعد ذلك بتنزيل الملفات الثنائية المطلوبة والتحقق من تطابق تجزئاتها باستخدام دالة verify_binary_hashes. إذا كانت جميع التجزئات متطابقة، يتم إرجاع رمز الحالة SUCCESS، مع إمكانية عرض النتائج بتنسيق JSON إذا تم تحديد ذلك في المعلمات.\n\nتستدعي هذه الدالة من دالة main، حيث يتم تعيينها كوظيفة افتراضية عند استخدام الأمر \"pub\" للتحقق من إصدار منشور. يتم تمرير المعلمات المدخلة من سطر الأوامر إلى verify_published_handler، مما يتيح للمستخدمين التحقق من إصدارات مختلفة من برنامج Bitcoin بسهولة.\n\n**Note**: من المهم التأكد من أن جميع المدخلات صحيحة وأن النظام يحتوي على الأدوات اللازمة مثل wget وGPG، حيث تعتمد الدالة على هذه الأدوات لتنفيذ عمليات التحميل والتحقق.\n\n**Output Example**: قد يبدو الناتج من الدالة كالتالي:\n```\n{\n  \"good_trusted_sigs\": [\"sig1\", \"sig2\"],\n  \"good_untrusted_sigs\": [\"sig3\"],\n  \"unknown_sigs\": [\"sig4\"],\n  \"bad_sigs\": [\"sig5\"],\n  \"verified_binaries\": [\"binary1\", \"binary2\"]\n}\n```"
      ],
      "code_start_line": 461,
      "code_end_line": 567,
      "params": [
        "args"
      ],
      "have_return": true,
      "code_content": "def verify_published_handler(args: argparse.Namespace) -> ReturnCode:\n    WORKINGDIR = Path(tempfile.gettempdir()) / f\"bitcoin_verify_binaries.{args.version}\"\n\n    def cleanup():\n        log.info(\"cleaning up files\")\n        os.chdir(Path.home())\n        shutil.rmtree(WORKINGDIR)\n\n    # determine remote dir dependent on provided version string\n    try:\n        version_base, version_rc, os_filter = parse_version_string(args.version)\n        version_tuple = [int(i) for i in version_base.split('.')]\n    except Exception as e:\n        log.debug(e)\n        log.error(f\"unable to parse version; expected format is {VERSION_FORMAT}\")\n        log.error(f\"  e.g. {VERSION_EXAMPLE}\")\n        return ReturnCode.BAD_VERSION\n\n    remote_dir = f\"/bin/{VERSIONPREFIX}{version_base}/\"\n    if version_rc:\n        remote_dir += f\"test.{version_rc}/\"\n    remote_sigs_path = remote_dir + SIGNATUREFILENAME\n    remote_sums_path = remote_dir + SUMS_FILENAME\n\n    # create working directory\n    os.makedirs(WORKINGDIR, exist_ok=True)\n    os.chdir(WORKINGDIR)\n\n    hosts = [HOST1, HOST2]\n\n    got_sig_status = get_files_from_hosts_and_compare(\n        hosts, remote_sigs_path, SIGNATUREFILENAME, args.require_all_hosts)\n    if got_sig_status != ReturnCode.SUCCESS:\n        return got_sig_status\n\n    # Multi-sig verification is available after 22.0.\n    if version_tuple[0] < 22:\n        log.error(\"Version too old - single sig not supported. Use a previous \"\n                  \"version of this script from the repo.\")\n        return ReturnCode.BAD_VERSION\n\n    got_sums_status = get_files_from_hosts_and_compare(\n        hosts, remote_sums_path, SUMS_FILENAME, args.require_all_hosts)\n    if got_sums_status != ReturnCode.SUCCESS:\n        return got_sums_status\n\n    # Verify the signature on the SHA256SUMS file\n    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(SIGNATUREFILENAME, SUMS_FILENAME, args)\n    if sigs_status != ReturnCode.SUCCESS:\n        if sigs_status == ReturnCode.INTEGRITY_FAILURE:\n            cleanup()\n        return sigs_status\n\n    # Extract hashes and filenames\n    hashes_to_verify = parse_sums_file(SUMS_FILENAME, [os_filter])\n    if not hashes_to_verify:\n        log.error(\"no files matched the platform specified\")\n        return ReturnCode.NO_BINARIES_MATCH\n\n    # remove binaries that are known not to be hosted by bitcoincore.org\n    fragments_to_remove = ['-unsigned', '-debug', '-codesignatures']\n    for fragment in fragments_to_remove:\n        nobinaries = [i for i in hashes_to_verify if fragment in i[1]]\n        if nobinaries:\n            remove_str = ', '.join(i[1] for i in nobinaries)\n            log.info(\n                f\"removing *{fragment} binaries ({remove_str}) from verification \"\n                f\"since {HOST1} does not host *{fragment} binaries\")\n            hashes_to_verify = [i for i in hashes_to_verify if fragment not in i[1]]\n\n    # download binaries\n    for _, binary_filename in hashes_to_verify:\n        log.info(f\"downloading {binary_filename} to {WORKINGDIR}\")\n        success, output = download_with_wget(\n            HOST1 + remote_dir + binary_filename, binary_filename)\n\n        if not success:\n            log.error(\n                f\"failed to download {binary_filename}\\n\"\n                f\"wget output:\\n{indent(output)}\")\n            return ReturnCode.BINARY_DOWNLOAD_FAILED\n\n    # verify hashes\n    hashes_status, files_to_hashes = verify_binary_hashes(hashes_to_verify)\n    if hashes_status != ReturnCode.SUCCESS:\n        return hashes_status\n\n\n    if args.cleanup:\n        cleanup()\n    else:\n        log.info(f\"did not clean up {WORKINGDIR}\")\n\n    if args.json:\n        output = {\n            'good_trusted_sigs': [str(s) for s in good_trusted],\n            'good_untrusted_sigs': [str(s) for s in good_untrusted],\n            'unknown_sigs': [str(s) for s in unknown],\n            'bad_sigs': [str(s) for s in bad],\n            'verified_binaries': files_to_hashes,\n        }\n        print(json.dumps(output, indent=2))\n    else:\n        for filename in files_to_hashes:\n            print(f\"VERIFIED: {filename}\")\n\n    return ReturnCode.SUCCESS\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/main"
      ],
      "reference_who": [
        "dataset/verify.py/ReturnCode",
        "dataset/verify.py/indent",
        "dataset/verify.py/parse_version_string",
        "dataset/verify.py/download_with_wget",
        "dataset/verify.py/get_files_from_hosts_and_compare",
        "dataset/verify.py/verify_shasums_signature",
        "dataset/verify.py/parse_sums_file",
        "dataset/verify.py/verify_binary_hashes"
      ],
      "special_reference_type": [
        true,
        false,
        false,
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "cleanup",
      "md_content": [
        "**cleanup**: وظيفة cleanup هي تنظيف الملفات وإزالة الدليل العامل.\n\n**parameters**: لا توجد معلمات لهذه الوظيفة.\n\n**Code Description**: تقوم وظيفة cleanup بتنفيذ عدة خطوات لتنظيف الملفات. أولاً، تسجل رسالة معلوماتية باستخدام log.info تشير إلى بدء عملية التنظيف. بعد ذلك، تقوم بتغيير الدليل الحالي إلى الدليل الرئيسي للمستخدم باستخدام os.chdir(Path.home()). وأخيرًا، تقوم بإزالة الدليل العامل المحدد بواسطة WORKINGDIR باستخدام shutil.rmtree، مما يؤدي إلى حذف جميع الملفات والمجلدات الموجودة فيه بشكل نهائي.\n\n**Note**: من المهم التأكد من أن WORKINGDIR يحتوي على الملفات التي يمكن حذفها، حيث أن استخدام shutil.rmtree سيؤدي إلى فقدان البيانات بشكل دائم. يجب استخدام هذه الوظيفة بحذر، خاصة في بيئات الإنتاج."
      ],
      "code_start_line": 464,
      "code_end_line": 467,
      "params": [],
      "have_return": false,
      "code_content": "    def cleanup():\n        log.info(\"cleaning up files\")\n        os.chdir(Path.home())\n        shutil.rmtree(WORKINGDIR)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "verify_binaries_handler",
      "md_content": [
        "**verify_binaries_handler**: The function of verify_binaries_handler is التحقق من صحة الثنائيات المحلية باستخدام ملف SHA256SUMS والتوقيع المرتبط به.\n\n**parameters**: The parameters of this Function.\n· args: كائن يحتوي على خيارات المستخدم، بما في ذلك مسارات الملفات الثنائية وملف SHA256SUMS وملف التوقيع.\n\n**Code Description**: تقوم دالة verify_binaries_handler بمعالجة التحقق من صحة الثنائيات المحلية من خلال عدة خطوات. أولاً، يتم إنشاء قاموس binary_to_basename لتخزين أسماء الملفات الثنائية مع مساراتها. بعد ذلك، يتم تحديد مسار ملف التوقيع (sums_sig_file) إما من المدخلات أو يتم افتراضه بناءً على ملف sums_file. \n\nتقوم الدالة بعد ذلك بالتحقق من صحة التوقيع على ملف SHA256SUMS باستخدام دالة verify_shasums_signature، والتي تعيد رموز الحالة والتوقيعات الجيدة وغير المعروفة والسيئة. إذا كانت حالة التوقيع غير ناجحة، يتم إرجاع رمز الحالة المناسب.\n\nبعد ذلك، يتم استخراج التجزئات والأسماء من ملف sums_file باستخدام دالة parse_sums_file، حيث يتم تصفية النتائج بناءً على الملفات الثنائية المحددة. إذا لم تتطابق أي من الملفات، يتم تسجيل خطأ وإرجاع رمز الحالة NO_BINARIES_MATCH.\n\nتتحقق الدالة بعد ذلك من أن جميع الملفات موجودة، وإذا كانت هناك ملفات مفقودة، يتم تسجيلها. يتم استخدام دالة verify_binary_hashes للتحقق من تطابق التجزئات المحسوبة مع القيم المتوقعة. إذا كانت هناك أي مشاكل في التحقق من التجزئات، يتم إرجاع رمز الحالة المناسب.\n\nإذا تم تحديد خيار الإخراج بصيغة JSON، يتم طباعة النتائج بتنسيق JSON، وإلا يتم طباعة أسماء الملفات التي تم التحقق منها وأي ملفات مفقودة. في النهاية، تعيد الدالة رمز الحالة SUCCESS إذا تمت جميع العمليات بنجاح.\n\nتُستدعى هذه الدالة من دالة main، حيث يتم تحديدها كأحد الأوامر الفرعية للتحقق من الثنائيات المحلية. يتم تمرير كائن args الذي يحتوي على جميع الخيارات المحددة من قبل المستخدم.\n\n**Note**: من المهم التأكد من أن جميع الملفات المطلوبة موجودة وأنها تتبع التنسيق الصحيح، حيث أن أي خطأ في هذه العملية قد يؤدي إلى فشل في التحقق من صحة الثنائيات.\n\n**Output Example**: قد يبدو الناتج من الدالة كالتالي:\n```\nVERIFIED: binary1\nVERIFIED: binary2\nMISSING: binary3\n```"
      ],
      "code_start_line": 570,
      "code_end_line": 634,
      "params": [
        "args"
      ],
      "have_return": true,
      "code_content": "def verify_binaries_handler(args: argparse.Namespace) -> ReturnCode:\n    binary_to_basename = {}\n    for file in args.binary:\n        binary_to_basename[PurePath(file).name] = file\n\n    sums_sig_path = None\n    if args.sums_sig_file:\n        sums_sig_path = Path(args.sums_sig_file)\n    else:\n        log.info(f\"No signature file specified, assuming it is {args.sums_file}.asc\")\n        sums_sig_path = Path(args.sums_file).with_suffix(\".asc\")\n\n    # Verify the signature on the SHA256SUMS file\n    sigs_status, good_trusted, good_untrusted, unknown, bad = verify_shasums_signature(str(sums_sig_path), args.sums_file, args)\n    if sigs_status != ReturnCode.SUCCESS:\n        return sigs_status\n\n    # Extract hashes and filenames\n    hashes_to_verify = parse_sums_file(args.sums_file, [k for k, n in binary_to_basename.items()])\n    if not hashes_to_verify:\n        log.error(f\"No files in {args.sums_file} match the specified binaries\")\n        return ReturnCode.NO_BINARIES_MATCH\n\n    # Make sure all files are accounted for\n    sums_file_path = Path(args.sums_file)\n    missing_files = []\n    files_to_hash = []\n    if len(binary_to_basename) > 0:\n        for file_hash, file in hashes_to_verify:\n            files_to_hash.append([file_hash, binary_to_basename[file]])\n            del binary_to_basename[file]\n        if len(binary_to_basename) > 0:\n            log.error(f\"Not all specified binaries are in {args.sums_file}\")\n            return ReturnCode.NO_BINARIES_MATCH\n    else:\n        log.info(f\"No binaries specified, assuming all files specified in {args.sums_file} are located relatively\")\n        for file_hash, file in hashes_to_verify:\n            file_path = Path(sums_file_path.parent.joinpath(file))\n            if file_path.exists():\n                files_to_hash.append([file_hash, str(file_path)])\n            else:\n                missing_files.append(file)\n\n    # verify hashes\n    hashes_status, files_to_hashes = verify_binary_hashes(files_to_hash)\n    if hashes_status != ReturnCode.SUCCESS:\n        return hashes_status\n\n    if args.json:\n        output = {\n            'good_trusted_sigs': [str(s) for s in good_trusted],\n            'good_untrusted_sigs': [str(s) for s in good_untrusted],\n            'unknown_sigs': [str(s) for s in unknown],\n            'bad_sigs': [str(s) for s in bad],\n            'verified_binaries': files_to_hashes,\n            \"missing_binaries\": missing_files,\n        }\n        print(json.dumps(output, indent=2))\n    else:\n        for filename in files_to_hashes:\n            print(f\"VERIFIED: {filename}\")\n        for filename in missing_files:\n            print(f\"MISSING: {filename}\")\n\n    return ReturnCode.SUCCESS\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "dataset/verify.py/main"
      ],
      "reference_who": [
        "dataset/verify.py/ReturnCode",
        "dataset/verify.py/verify_shasums_signature",
        "dataset/verify.py/parse_sums_file",
        "dataset/verify.py/verify_binary_hashes"
      ],
      "special_reference_type": [
        true,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "main",
      "md_content": [
        "**main**: The function of main is إعداد وتحليل خيارات سطر الأوامر لتحديد كيفية التحقق من صحة التوقيعات والملفات الثنائية.\n\n**parameters**: The parameters of this Function.\n· args: كائن يحتوي على خيارات المستخدم المدخلة من سطر الأوامر، والتي تحدد كيفية تنفيذ البرنامج.\n\n**Code Description**: تقوم دالة main بإنشاء محلل خيارات سطر الأوامر باستخدام مكتبة argparse. يتم تعريف مجموعة من الخيارات التي يمكن للمستخدم تحديدها عند تشغيل البرنامج، مثل وضع verbose أو quiet، واستيراد المفاتيح، والحد الأدنى من التوقيعات الجيدة المطلوبة، ومعلومات حول خادم المفاتيح، والمفاتيح الموثوقة، وإخراج النتائج بتنسيق JSON.\n\nتقوم الدالة أيضًا بإنشاء مجموعة من الأوامر الفرعية، حيث يتم تعريف أمرين رئيسيين: \"pub\" و \"bin\". يتم تعيين كل أمر إلى دالة معالجة محددة، حيث يتم استدعاء verify_published_handler عند استخدام الأمر \"pub\" للتحقق من إصدار منشور، و verify_binaries_handler عند استخدام الأمر \"bin\" للتحقق من الثنائيات المحلية.\n\nبعد تحليل الخيارات، يتم تحديد مستوى السجل بناءً على ما إذا كان الخيار quiet قد تم تحديده. إذا كان محددًا، يتم ضبط مستوى السجل على تحذير فقط.\n\nفي النهاية، يتم استدعاء الدالة المحددة بناءً على الأمر المدخل، ويتم تمرير كائن args الذي يحتوي على جميع الخيارات المحددة. هذا يسمح للمستخدمين بتخصيص سلوك البرنامج بناءً على احتياجاتهم، مما يسهل عملية التحقق من صحة التوقيعات والملفات الثنائية.\n\n**Note**: من المهم التأكد من أن جميع المدخلات صحيحة وأن الخيارات المحددة تتوافق مع المتطلبات، حيث أن أي خطأ في هذه المدخلات قد يؤدي إلى نتائج غير صحيحة أو فشل في التحقق.\n\n**Output Example**: قد يبدو الناتج من الدالة كالتالي:\n```\n{\n  \"command\": \"pub\",\n  \"version\": \"0.21.0\",\n  \"cleanup\": true,\n  \"require_all_hosts\": false,\n  \"json\": true\n}\n```"
      ],
      "code_start_line": 637,
      "code_end_line": 709,
      "params": [],
      "have_return": true,
      "code_content": "def main():\n    parser = argparse.ArgumentParser(description=__doc__)\n    parser.add_argument(\n        '-v', '--verbose', action='store_true',\n        default=bool_from_env('BINVERIFY_VERBOSE'),\n    )\n    parser.add_argument(\n        '-q', '--quiet', action='store_true',\n        default=bool_from_env('BINVERIFY_QUIET'),\n    )\n    parser.add_argument(\n        '--import-keys', action='store_true',\n        default=bool_from_env('BINVERIFY_IMPORTKEYS'),\n        help='if specified, ask to import each unknown builder key'\n    )\n    parser.add_argument(\n        '--min-good-sigs', type=int, action='store', nargs='?',\n        default=int(os.environ.get('BINVERIFY_MIN_GOOD_SIGS', 3)),\n        help=(\n            'The minimum number of good signatures to require successful termination.'),\n    )\n    parser.add_argument(\n        '--keyserver', action='store', nargs='?',\n        default=os.environ.get('BINVERIFY_KEYSERVER', 'hkps://keys.openpgp.org'),\n        help='which keyserver to use',\n    )\n    parser.add_argument(\n        '--trusted-keys', action='store', nargs='?',\n        default=os.environ.get('BINVERIFY_TRUSTED_KEYS', ''),\n        help='A list of trusted signer GPG keys, separated by commas. Not \"trusted keys\" in the GPG sense.',\n    )\n    parser.add_argument(\n        '--json', action='store_true',\n        default=bool_from_env('BINVERIFY_JSON'),\n        help='If set, output the result as JSON',\n    )\n\n    subparsers = parser.add_subparsers(title=\"Commands\", required=True, dest=\"command\")\n\n    pub_parser = subparsers.add_parser(\"pub\", help=\"Verify a published release.\")\n    pub_parser.set_defaults(func=verify_published_handler)\n    pub_parser.add_argument(\n        'version', type=str, help=(\n            f'version of the bitcoin release to download; of the format '\n            f'{VERSION_FORMAT}. Example: {VERSION_EXAMPLE}')\n    )\n    pub_parser.add_argument(\n        '--cleanup', action='store_true',\n        default=bool_from_env('BINVERIFY_CLEANUP'),\n        help='if specified, clean up files afterwards'\n    )\n    pub_parser.add_argument(\n        '--require-all-hosts', action='store_true',\n        default=bool_from_env('BINVERIFY_REQUIRE_ALL_HOSTS'),\n        help=(\n            f'If set, require all hosts ({HOST1}, {HOST2}) to provide signatures. '\n            '(Sometimes bitcoin.org lags behind bitcoincore.org.)')\n    )\n\n    bin_parser = subparsers.add_parser(\"bin\", help=\"Verify local binaries.\")\n    bin_parser.set_defaults(func=verify_binaries_handler)\n    bin_parser.add_argument(\"--sums-sig-file\", \"-s\", help=\"Path to the SHA256SUMS.asc file to verify\")\n    bin_parser.add_argument(\"sums_file\", help=\"Path to the SHA256SUMS file to verify\")\n    bin_parser.add_argument(\n        \"binary\", nargs=\"*\",\n        help=\"Path to a binary distribution file to verify. Can be specified multiple times for multiple files to verify.\"\n    )\n\n    args = parser.parse_args()\n    if args.quiet:\n        log.setLevel(logging.WARNING)\n\n    return args.func(args)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "dataset/verify.py/bool_from_env",
        "dataset/verify.py/verify_published_handler",
        "dataset/verify.py/verify_binaries_handler"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    }
  ]
}