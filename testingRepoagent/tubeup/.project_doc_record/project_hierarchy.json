{
  "setup.py": [],
  "tests/constants.py": [],
  "tests/test_utils.py": [
    {
      "type": "ClassDef",
      "name": "UtilsTest",
      "md_content": [],
      "code_start_line": 6,
      "code_end_line": 50,
      "params": [],
      "have_return": false,
      "code_content": "class UtilsTest(unittest.TestCase):\n\n    def test_preserve_valid_identifiers(self):\n        valid = [\n            'youtube--QBwhSklJks',\n            'youtube-_--M04_mN-M',\n            'youtube-Xy2jZABDB40'\n        ]\n        clean = [sanitize_identifier(x) for x in valid]\n        self.assertListEqual(valid, clean)\n\n    def test_sanitize_bad_identifiers(self):\n        bad = [\n            'twitch:vod-v181464551',\n            'twitch:clips-1003820974',\n            'twitter:card-1192732384065708032'\n        ]\n        expect = [\n            'twitch-vod-v181464551',\n            'twitch-clips-1003820974',\n            'twitter-card-1192732384065708032'\n        ]\n        clean = [sanitize_identifier(x) for x in bad]\n        self.assertListEqual(expect, clean)\n\n    def test_check_is_file_empty_when_file_is_empty(self):\n        # Create a file for the test\n        with open('testemptyfile.txt', 'w'):\n            pass\n\n        self.assertTrue(check_is_file_empty('testemptyfile.txt'))\n        os.remove('testemptyfile.txt')\n\n    def test_check_is_file_empty_when_file_is_not_empty(self):\n        with open('testfilenotempty.txt', 'w') as not_empty_file:\n            not_empty_file.write('just a text')\n\n        self.assertFalse(check_is_file_empty('testfilenotempty.txt'))\n        os.remove('testfilenotempty.txt')\n\n    def test_check_is_file_empty_when_file_doesnt_exist(self):\n        with self.assertRaisesRegex(\n                FileNotFoundError,\n                r\"^Path 'file_that_doesnt_exist.txt' doesn't exist$\"):\n            check_is_file_empty('file_that_doesnt_exist.txt')\n",
      "name_column": 6,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_preserve_valid_identifiers",
      "md_content": [],
      "code_start_line": 8,
      "code_end_line": 15,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_preserve_valid_identifiers(self):\n        valid = [\n            'youtube--QBwhSklJks',\n            'youtube-_--M04_mN-M',\n            'youtube-Xy2jZABDB40'\n        ]\n        clean = [sanitize_identifier(x) for x in valid]\n        self.assertListEqual(valid, clean)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/utils.py/sanitize_identifier"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_sanitize_bad_identifiers",
      "md_content": [],
      "code_start_line": 17,
      "code_end_line": 29,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_sanitize_bad_identifiers(self):\n        bad = [\n            'twitch:vod-v181464551',\n            'twitch:clips-1003820974',\n            'twitter:card-1192732384065708032'\n        ]\n        expect = [\n            'twitch-vod-v181464551',\n            'twitch-clips-1003820974',\n            'twitter-card-1192732384065708032'\n        ]\n        clean = [sanitize_identifier(x) for x in bad]\n        self.assertListEqual(expect, clean)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/utils.py/sanitize_identifier"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_check_is_file_empty_when_file_is_empty",
      "md_content": [],
      "code_start_line": 31,
      "code_end_line": 37,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_check_is_file_empty_when_file_is_empty(self):\n        # Create a file for the test\n        with open('testemptyfile.txt', 'w'):\n            pass\n\n        self.assertTrue(check_is_file_empty('testemptyfile.txt'))\n        os.remove('testemptyfile.txt')\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/utils.py/check_is_file_empty"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_check_is_file_empty_when_file_is_not_empty",
      "md_content": [],
      "code_start_line": 39,
      "code_end_line": 44,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_check_is_file_empty_when_file_is_not_empty(self):\n        with open('testfilenotempty.txt', 'w') as not_empty_file:\n            not_empty_file.write('just a text')\n\n        self.assertFalse(check_is_file_empty('testfilenotempty.txt'))\n        os.remove('testfilenotempty.txt')\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/utils.py/check_is_file_empty"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_check_is_file_empty_when_file_doesnt_exist",
      "md_content": [],
      "code_start_line": 46,
      "code_end_line": 50,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_check_is_file_empty_when_file_doesnt_exist(self):\n        with self.assertRaisesRegex(\n                FileNotFoundError,\n                r\"^Path 'file_that_doesnt_exist.txt' doesn't exist$\"):\n            check_is_file_empty('file_that_doesnt_exist.txt')\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/utils.py/check_is_file_empty"
      ],
      "special_reference_type": [
        false
      ]
    }
  ],
  "tests/test_tubeup.py": [
    {
      "type": "FunctionDef",
      "name": "get_testfile_path",
      "md_content": [],
      "code_start_line": 21,
      "code_end_line": 22,
      "params": [
        "name"
      ],
      "have_return": true,
      "code_content": "def get_testfile_path(name):\n    return os.path.join(current_path, 'test_tubeup_files', name)\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_description_text_null",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_no_uploader",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_no_date",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_twitch_clips",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_mass_of_tags",
        "tests/test_tubeup.py/TubeUpTests/test_upload_ia",
        "tests/test_tubeup.py/TubeUpTests/test_archive_urls"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "mocked_ydl_progress_hook",
      "md_content": [],
      "code_start_line": 25,
      "code_end_line": 26,
      "params": [
        "d"
      ],
      "have_return": false,
      "code_content": "def mocked_ydl_progress_hook(d):\n    pass\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options_with_download_archive",
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options",
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options_with_proxy",
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options_with_ydl_account",
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options_with_verbose_mode"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "mock_upload_response_by_videobasename",
      "md_content": [],
      "code_start_line": 29,
      "code_end_line": 36,
      "params": [
        "m",
        "ia_id",
        "videobasename"
      ],
      "have_return": false,
      "code_content": "def mock_upload_response_by_videobasename(m, ia_id, videobasename):\n    files_to_upload = glob.glob(videobasename + '*')\n\n    for file_path in files_to_upload:\n        filename = os.path.basename(file_path)\n        m.put('https://s3.us.archive.org/%s/%s' % (ia_id, filename),\n              content=b'',\n              headers={'content-type': 'text/plain'})\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_upload_ia",
        "tests/test_tubeup.py/TubeUpTests/test_archive_urls"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "copy_testfiles_to_tubeup_rootdir_test",
      "md_content": [],
      "code_start_line": 39,
      "code_end_line": 50,
      "params": [],
      "have_return": false,
      "code_content": "def copy_testfiles_to_tubeup_rootdir_test():\n    # Copy testfiles to rootdir path of TubeUp.\n    # This method was created because after the uploading done by\n    # internetarchive library, it deletes the files that has been uploaded.\n    testfiles_dir = os.path.join(current_path, 'test_tubeup_files',\n                                 'files_for_upload_and_download_tests')\n\n    for filepath in os.listdir(testfiles_dir):\n        shutil.copy(\n            os.path.join(testfiles_dir, filepath),\n            os.path.join(current_path, 'test_tubeup_rootdir', 'downloads',\n                         filepath))\n",
      "name_column": 4,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_get_resource_basenames",
        "tests/test_tubeup.py/TubeUpTests/test_upload_ia",
        "tests/test_tubeup.py/TubeUpTests/test_archive_urls"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "ClassDef",
      "name": "TubeUpTests",
      "md_content": [],
      "code_start_line": 53,
      "code_end_line": 592,
      "params": [],
      "have_return": false,
      "code_content": "class TubeUpTests(unittest.TestCase):\n\n    def setUp(self):\n        self.tu = TubeUp()\n        self.maxDiff = 999999999\n\n    def test_set_dir_path(self):\n        root_path = os.path.join(\n            current_path, '.directory_for_tubeup_set_dir_path_test')\n        dir_paths_dict = dict(root=root_path,\n                              downloads=os.path.join(root_path,\n                                                     DOWNLOAD_DIR_NAME))\n\n        self.tu.dir_path = root_path\n        self.assertEqual(self.tu.dir_path, dir_paths_dict)\n\n        # Make sure that other directories are created as well\n        self.assertTrue(os.path.exists(dir_paths_dict['downloads']))\n\n        # Clean the test directory\n        shutil.rmtree(root_path, ignore_errors=True)\n\n    def test_tubeup_attribute_logger_when_quiet_mode(self):\n        # self.tu is already `TubeUp` instance with quiet mode, so we don't\n        # create a new instance here.\n        self.assertIsInstance(self.tu.logger, logging.Logger)\n        self.assertEqual(self.tu.logger.level, logging.ERROR)\n\n    def test_tubeup_attribute_logger_when_verbose_mode(self):\n        tu = TubeUp(verbose=True)\n        self.assertIsInstance(tu.logger, logging.Logger)\n\n    def test_determine_collection_type(self):\n        soundcloud_colltype = self.tu.determine_collection_type(\n            'https://soundcloud.com/testurl')\n        another_colltype = self.tu.determine_collection_type(\n            'https://www.youtube.com/watch?v=testVideo'\n        )\n\n        self.assertEqual(soundcloud_colltype, 'opensource_audio')\n        self.assertEqual(another_colltype, 'opensource_movies')\n\n    def test_create_basenames_from_ydl_info_dict_video(self):\n        ydl = YoutubeDL()\n        result = self.tu.create_basenames_from_ydl_info_dict(\n            ydl, info_dict_video)\n\n        expected_result = set(\n            ['Video and Blog Competition 2017 - Bank Indonesia & '\n             'NET TV #BIGoesToCampus [hlG3LeFaQwU]'])\n\n        self.assertEqual(result, expected_result)\n\n    def test_create_basenames_from_ydl_info_dict_playlist(self):\n        ydl = YoutubeDL()\n        result = self.tu.create_basenames_from_ydl_info_dict(\n            ydl, info_dict_playlist)\n\n        expected_result = set([\n            'Live Streaming Rafid Aslam [7gjgkH5iPaE]',\n            'Live Streaming Rafid Aslam [q92kxPm-pqM]',\n            'Cara Membuat Laptop Menjadi Hotspot WiFi Dengan CMD [YjFwMSDNphM]',\n            '[CSO] Defeat Boss in Dead End With Thanatos 7 [EEm6MwXLse0]',\n            'Cara Bermain Minecraft Multiplayer Dengan LAN [g2vTZ2ka-tM]',\n            'Live Streaming Rafid Aslam [AXhuSS5_9YU]',\n            'Cara Membuat Disk Baru di Komputer [KDOygJnK7Sw]',\n            'Cara Mendownload Lewat Torrent [cC-9RghkvXs]']\n        )\n\n        self.assertEqual(result, expected_result)\n\n    def test_generate_ydl_options_with_download_archive(self):\n        result = self.tu.generate_ydl_options(mocked_ydl_progress_hook,\n                                              use_download_archive=True)\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': False,\n            'quiet': True,\n            'download_archive': os.path.join(self.tu.dir_path['root'],\n                                             '.ytdlarchive'),\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': self.tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook]}\n\n        self.assertEqual(result, expected_result)\n\n    def test_generate_ydl_options(self):\n        result = self.tu.generate_ydl_options(mocked_ydl_progress_hook)\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': False,\n            'quiet': True,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': self.tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook]}\n\n        self.assertEqual(result, expected_result)\n\n    def test_generate_ydl_options_with_proxy(self):\n        result = self.tu.generate_ydl_options(\n            mocked_ydl_progress_hook, proxy_url='http://proxytest.com:8080')\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': False,\n            'quiet': True,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': self.tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook],\n            'proxy': 'http://proxytest.com:8080'}\n\n        self.assertEqual(result, expected_result)\n\n    def test_generate_ydl_options_with_ydl_account(self):\n        result = self.tu.generate_ydl_options(\n            mocked_ydl_progress_hook, ydl_username='testUsername',\n            ydl_password='testPassword')\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': False,\n            'quiet': True,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': self.tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook],\n            'username': 'testUsername',\n            'password': 'testPassword'}\n\n        self.assertEqual(result, expected_result)\n\n    def test_generate_ydl_options_with_verbose_mode(self):\n        tu = TubeUp(verbose=True)\n        result = tu.generate_ydl_options(\n            mocked_ydl_progress_hook, ydl_username='testUsername',\n            ydl_password='testPassword')\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': True,\n            'quiet': False,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook],\n            'username': 'testUsername',\n            'password': 'testPassword'}\n\n        self.assertEqual(result, expected_result)\n\n    def test_create_archive_org_metadata_from_youtubedl_meta(self):\n        with open(get_testfile_path(\n                'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A.info.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        expected_result = {\n            'mediatype': 'movies',\n            'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n            'creator': 'Video Background',\n            'collection': 'opensource_movies',\n            'title': 'Mountain 3 - Video Background HD 1080p',\n            'description': ('Mountain 3 - Video Background HD 1080p<br>'\n                            'If you use this video please put credits to my '\n                            'channel in description:<br>https://www.youtube.com'\n                            '/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© Don\\'t '\n                            'forget to SUBSCRIBE, LIKE, COMMENT and RATE. '\n                            'Hope you all enjoy!'),\n            'date': '2015-01-05',\n            'year': '2015',\n            'subject': ('Youtube;video;Entertainment;Video Background;Footage;'\n                        'Animation;Cinema;stock video footage;Royalty '\n                        'free videos;Creative Commons videos;free movies '\n                        'online;youtube;HD;1080p;Amazing Nature;Mountain;'),\n            'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A',\n            'licenseurl': 'https://creativecommons.org/licenses/by/3.0/',\n            'scanner': SCANNER}\n\n        self.assertEqual(expected_result, result)\n\n    def test_create_archive_org_metadata_from_youtubedl_meta_description_text_null(self):\n        with open(get_testfile_path(\n                'description_text_null.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        expected_description = ('')\n\n        self.assertEqual(expected_description, result.get('description'))\n\n    def test_create_archive_org_metadata_from_youtubedl_meta_no_uploader(self):\n        with open(get_testfile_path(\n                'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A.info_no_'\n                'uploader.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        expected_result = {\n            'mediatype': 'movies',\n            'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n            'creator': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n            'collection': 'opensource_movies',\n            'title': 'Mountain 3 - Video Background HD 1080p',\n            'description': ('Mountain 3 - Video Background HD 1080p<br>'\n                            'If you use this video please put credits to my '\n                            'channel in description:<br>https://www.youtube.com'\n                            '/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© Don\\'t '\n                            'forget to SUBSCRIBE, LIKE, COMMENT and RATE. '\n                            'Hope you all enjoy!'),\n            'date': '2015-01-05',\n            'year': '2015',\n            'subject': ('Youtube;video;Entertainment;Video Background;Footage;'\n                        'Animation;Cinema;stock video footage;Royalty '\n                        'free videos;Creative Commons videos;free movies '\n                        'online;youtube;HD;1080p;Amazing Nature;Mountain;'),\n            'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A',\n            'licenseurl': 'https://creativecommons.org/licenses/by/3.0/',\n            'scanner': SCANNER}\n\n        self.assertEqual(expected_result, result)\n\n    def test_create_archive_org_metadata_from_youtubedl_meta_no_date(self):\n        with open(get_testfile_path(\n                'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A.'\n                'info_no_date.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        upload_date = time.strftime(\"%Y-%m-%d\")\n        upload_year = time.strftime(\"%Y\")\n\n        expected_result = {\n            'mediatype': 'movies',\n            'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n            'creator': 'Video Background',\n            'collection': 'opensource_movies',\n            'title': 'Mountain 3 - Video Background HD 1080p',\n            'description': ('Mountain 3 - Video Background HD 1080p<br>'\n                            'If you use this video please put credits to my '\n                            'channel in description:<br>https://www.youtube.com'\n                            '/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© Don\\'t '\n                            'forget to SUBSCRIBE, LIKE, COMMENT and RATE. '\n                            'Hope you all enjoy!'),\n            'date': upload_date,\n            'year': upload_year,\n            'subject': ('Youtube;video;Entertainment;Video Background;Footage;'\n                        'Animation;Cinema;stock video footage;Royalty '\n                        'free videos;Creative Commons videos;free movies '\n                        'online;youtube;HD;1080p;Amazing Nature;Mountain;'),\n            'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A',\n            'licenseurl': 'https://creativecommons.org/licenses/by/3.0/',\n            'scanner': SCANNER}\n\n        self.assertEqual(expected_result, result)\n\n    def test_create_archive_org_metadata_from_youtubedl_meta_twitch_clips(self):\n        with open(get_testfile_path(\n                'EA_Play_2016_Live_from_the_Novo_Theatre-42850523.info.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        expected_result = {\n            'mediatype': 'movies',\n            'creator': 'EA',\n            'collection': 'opensource_movies',\n            'title': 'EA Play 2016 Live from the Novo Theatre',\n            'description': (''),\n            'date': '2016-06-12',\n            'year': '2016',\n            'subject': 'TwitchClips;video;',\n            'originalurl': 'https://clips.twitch.tv/FaintLightGullWholeWheat',\n            'licenseurl': '',\n            'scanner': SCANNER}\n\n        self.assertEqual(expected_result, result)\n\n    def test_create_archive_org_metadata_from_youtubedl_meta_mass_of_tags(self):\n        with open(get_testfile_path(\n                'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A.info.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        vid_meta['tags'] = [f't{i}' for i in range(0, 300)]\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        self.assertLessEqual(len(result['subject'].encode(encoding='utf-8')),\n                             255, msg='tags_string not truncated to <= 255 bytes')\n\n    def test_get_resource_basenames(self):\n        tu = TubeUp(dir_path=os.path.join(current_path,\n                                          'test_tubeup_rootdir'))\n\n        copy_testfiles_to_tubeup_rootdir_test()\n\n        result = tu.get_resource_basenames(\n            ['https://www.youtube.com/watch?v=KdsN9YhkDrY'],\n            ignore_existing_item=True)\n\n        expected_result = {os.path.join(\n            current_path, 'test_tubeup_rootdir', 'downloads',\n            'KdsN9YhkDrY')}\n\n        self.assertEqual(expected_result, result)\n\n    def test_upload_ia(self):\n        tu = TubeUp(dir_path=os.path.join(current_path,\n                                          'test_tubeup_rootdir'),\n                    # Use custom ia configuration file so we don't need\n                    # to login with username and password.\n                    ia_config_path=get_testfile_path('ia_config_for_test.ini'))\n\n        videobasename = os.path.join(\n            current_path, 'test_tubeup_rootdir', 'downloads',\n            'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A')\n\n        copy_testfiles_to_tubeup_rootdir_test()\n\n        with requests_mock.Mocker() as m:\n            # Mock the request to s3.us.archive.org, so it will responds\n            # a custom json. `internetarchive` library sends GET request to\n            # that url to check that we don't violate the upload limit.\n            m.get('https://s3.us.archive.org',\n                  content=b'{\"over_limit\": 0}',\n                  headers={'content-type': 'application/json'})\n\n            m.get('https://archive.org/metadata/youtube-6iRV8liah8A',\n                  content=b'{}',\n                  headers={'content-type': 'application/json'})\n\n            # Mock the PUT requests for internetarchive urls that defined\n            # in mock_upload_response_by_videobasename(), so this test\n            # doesn't perform upload to the real archive.org server.\n            mock_upload_response_by_videobasename(\n                m, 'youtube-6iRV8liah8A', videobasename)\n\n            result = tu.upload_ia(videobasename)\n\n            expected_result = (\n                'youtube-6iRV8liah8A',\n                {'mediatype': 'movies',\n                 'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n                 'creator': 'Video Background',\n                 'collection': 'opensource_movies',\n                 'title': 'Mountain 3 - Video Background HD 1080p',\n                 'description': ('Mountain 3 - Video Background HD 1080p<br>If '\n                                 'you use this video please put credits to my'\n                                 ' channel in description:<br>https://www.youtub'\n                                 'e.com/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© D'\n                                 'on\\'t forget to SUBSCRIBE, LIKE, COMMENT an'\n                                 'd RATE. Hope you all enjoy!'),\n                 'date': '2015-01-05',\n                 'year': '2015',\n                 'subject': ('Youtube;video;Entertainment;Video Background;'\n                             'Footage;Animation;Cinema;stock video footage;'\n                             'Royalty free videos;Creative Commons videos;'\n                             'free movies online;youtube;HD;1080p;Amazing '\n                             'Nature;Mountain;'),\n                 'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A',\n                 'licenseurl': 'https://creativecommons.org/licenses/by/3.0/',\n                 'scanner': SCANNER})\n\n            self.assertEqual(expected_result, result)\n\n    def test_archive_urls(self):\n        tu = TubeUp(dir_path=os.path.join(current_path,\n                                          'test_tubeup_rootdir'),\n                    ia_config_path=get_testfile_path('ia_config_for_test.ini'))\n\n        videobasename = os.path.join(\n            current_path, 'test_tubeup_rootdir', 'downloads',\n            'KdsN9YhkDrY')\n\n        copy_testfiles_to_tubeup_rootdir_test()\n\n        with requests_mock.Mocker() as m:\n            # Mock the request to s3.us.archive.org, so it will responds\n            # a custom json. `internetarchive` library sends GET request to\n            # that url to check that we don't violate the upload limit.\n            m.get('https://s3.us.archive.org',\n                  content=b'{\"over_limit\": 0}',\n                  headers={'content-type': 'application/json'})\n\n            m.get('https://archive.org/metadata/youtube-KdsN9YhkDrY',\n                  content=b'{}',\n                  headers={'content-type': 'application/json'})\n\n            # Mock the PUT requests for internetarchive urls that defined\n            # in mock_upload_response_by_videobasename(), so this test\n            # doesn't perform upload to the real archive.org server.\n            mock_upload_response_by_videobasename(\n                m, 'youtube-KdsN9YhkDrY', videobasename)\n\n            result = list(tu.archive_urls(\n                ['https://www.youtube.com/watch?v=KdsN9YhkDrY']))\n\n            expected_result = [(\n                'youtube-KdsN9YhkDrY',\n                {'mediatype': 'movies',\n                 'creator': 'RelaxingWorld',\n                 'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n                 'collection': 'opensource_movies',\n                 'title': 'Epic Ramadan - Video Background HD1080p',\n                 'description': ('If you enjoy my work, please consider Subscribe to my NEW '\n                                 'channel for more videos: <br>'\n                                 'https://www.youtube.com/MusicForRelaxation?sub_confirmation=1 <br>'\n                                 '▷ If you use this video, please put credits to my channel '\n                                 'in description: <br>'\n                                 'Source from RelaxingWorld: https://goo.gl/HsW75m<br>'\n                                 '<br>'\n                                 '▷ Also, do not forget to Subscribe to my channel. Thanks!'),\n                 'date': '2016-06-25',\n                 'year': '2016',\n                 'subject': ('Youtube;video;Film & Animation;Video Background;'\n                             'Footage;Animation;Cinema;Royalty Free Videos;'\n                             'Stock Video Footage;Video Backdrops;'\n                             'Amazing Nature;youtube;HD;1080p;Creative Commons Videos;'\n                             'relaxing music;Ramadan;'),\n                 'originalurl': 'https://www.youtube.com/watch?v=KdsN9YhkDrY',\n                 'licenseurl': '',\n                 'scanner': SCANNER})]\n\n            self.assertEqual(expected_result, result)\n",
      "name_column": 6,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "setUp",
      "md_content": [],
      "code_start_line": 55,
      "code_end_line": 57,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def setUp(self):\n        self.tu = TubeUp()\n        self.maxDiff = 999999999\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/TubeUp.py/TubeUp"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_set_dir_path",
      "md_content": [],
      "code_start_line": 59,
      "code_end_line": 73,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_set_dir_path(self):\n        root_path = os.path.join(\n            current_path, '.directory_for_tubeup_set_dir_path_test')\n        dir_paths_dict = dict(root=root_path,\n                              downloads=os.path.join(root_path,\n                                                     DOWNLOAD_DIR_NAME))\n\n        self.tu.dir_path = root_path\n        self.assertEqual(self.tu.dir_path, dir_paths_dict)\n\n        # Make sure that other directories are created as well\n        self.assertTrue(os.path.exists(dir_paths_dict['downloads']))\n\n        # Clean the test directory\n        shutil.rmtree(root_path, ignore_errors=True)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_tubeup_attribute_logger_when_quiet_mode",
      "md_content": [],
      "code_start_line": 75,
      "code_end_line": 79,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_tubeup_attribute_logger_when_quiet_mode(self):\n        # self.tu is already `TubeUp` instance with quiet mode, so we don't\n        # create a new instance here.\n        self.assertIsInstance(self.tu.logger, logging.Logger)\n        self.assertEqual(self.tu.logger.level, logging.ERROR)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "test_tubeup_attribute_logger_when_verbose_mode",
      "md_content": [],
      "code_start_line": 81,
      "code_end_line": 83,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_tubeup_attribute_logger_when_verbose_mode(self):\n        tu = TubeUp(verbose=True)\n        self.assertIsInstance(tu.logger, logging.Logger)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/TubeUp.py/TubeUp"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_determine_collection_type",
      "md_content": [],
      "code_start_line": 85,
      "code_end_line": 93,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_determine_collection_type(self):\n        soundcloud_colltype = self.tu.determine_collection_type(\n            'https://soundcloud.com/testurl')\n        another_colltype = self.tu.determine_collection_type(\n            'https://www.youtube.com/watch?v=testVideo'\n        )\n\n        self.assertEqual(soundcloud_colltype, 'opensource_audio')\n        self.assertEqual(another_colltype, 'opensource_movies')\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/TubeUp.py/TubeUp/determine_collection_type"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_create_basenames_from_ydl_info_dict_video",
      "md_content": [],
      "code_start_line": 95,
      "code_end_line": 104,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_create_basenames_from_ydl_info_dict_video(self):\n        ydl = YoutubeDL()\n        result = self.tu.create_basenames_from_ydl_info_dict(\n            ydl, info_dict_video)\n\n        expected_result = set(\n            ['Video and Blog Competition 2017 - Bank Indonesia & '\n             'NET TV #BIGoesToCampus [hlG3LeFaQwU]'])\n\n        self.assertEqual(result, expected_result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/TubeUp.py/TubeUp/create_basenames_from_ydl_info_dict"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_create_basenames_from_ydl_info_dict_playlist",
      "md_content": [],
      "code_start_line": 106,
      "code_end_line": 122,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_create_basenames_from_ydl_info_dict_playlist(self):\n        ydl = YoutubeDL()\n        result = self.tu.create_basenames_from_ydl_info_dict(\n            ydl, info_dict_playlist)\n\n        expected_result = set([\n            'Live Streaming Rafid Aslam [7gjgkH5iPaE]',\n            'Live Streaming Rafid Aslam [q92kxPm-pqM]',\n            'Cara Membuat Laptop Menjadi Hotspot WiFi Dengan CMD [YjFwMSDNphM]',\n            '[CSO] Defeat Boss in Dead End With Thanatos 7 [EEm6MwXLse0]',\n            'Cara Bermain Minecraft Multiplayer Dengan LAN [g2vTZ2ka-tM]',\n            'Live Streaming Rafid Aslam [AXhuSS5_9YU]',\n            'Cara Membuat Disk Baru di Komputer [KDOygJnK7Sw]',\n            'Cara Mendownload Lewat Torrent [cC-9RghkvXs]']\n        )\n\n        self.assertEqual(result, expected_result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/TubeUp.py/TubeUp/create_basenames_from_ydl_info_dict"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_generate_ydl_options_with_download_archive",
      "md_content": [],
      "code_start_line": 124,
      "code_end_line": 157,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_generate_ydl_options_with_download_archive(self):\n        result = self.tu.generate_ydl_options(mocked_ydl_progress_hook,\n                                              use_download_archive=True)\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': False,\n            'quiet': True,\n            'download_archive': os.path.join(self.tu.dir_path['root'],\n                                             '.ytdlarchive'),\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': self.tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook]}\n\n        self.assertEqual(result, expected_result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/mocked_ydl_progress_hook",
        "tubeup/TubeUp.py/TubeUp/generate_ydl_options"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_generate_ydl_options",
      "md_content": [],
      "code_start_line": 159,
      "code_end_line": 189,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_generate_ydl_options(self):\n        result = self.tu.generate_ydl_options(mocked_ydl_progress_hook)\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': False,\n            'quiet': True,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': self.tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook]}\n\n        self.assertEqual(result, expected_result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/mocked_ydl_progress_hook",
        "tubeup/TubeUp.py/TubeUp/generate_ydl_options"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_generate_ydl_options_with_proxy",
      "md_content": [],
      "code_start_line": 191,
      "code_end_line": 223,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_generate_ydl_options_with_proxy(self):\n        result = self.tu.generate_ydl_options(\n            mocked_ydl_progress_hook, proxy_url='http://proxytest.com:8080')\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': False,\n            'quiet': True,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': self.tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook],\n            'proxy': 'http://proxytest.com:8080'}\n\n        self.assertEqual(result, expected_result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/mocked_ydl_progress_hook",
        "tubeup/TubeUp.py/TubeUp/generate_ydl_options"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_generate_ydl_options_with_ydl_account",
      "md_content": [],
      "code_start_line": 225,
      "code_end_line": 259,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_generate_ydl_options_with_ydl_account(self):\n        result = self.tu.generate_ydl_options(\n            mocked_ydl_progress_hook, ydl_username='testUsername',\n            ydl_password='testPassword')\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': False,\n            'quiet': True,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': self.tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook],\n            'username': 'testUsername',\n            'password': 'testPassword'}\n\n        self.assertEqual(result, expected_result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/mocked_ydl_progress_hook",
        "tubeup/TubeUp.py/TubeUp/generate_ydl_options"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_generate_ydl_options_with_verbose_mode",
      "md_content": [],
      "code_start_line": 261,
      "code_end_line": 296,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_generate_ydl_options_with_verbose_mode(self):\n        tu = TubeUp(verbose=True)\n        result = tu.generate_ydl_options(\n            mocked_ydl_progress_hook, ydl_username='testUsername',\n            ydl_password='testPassword')\n\n        expected_result = {\n            'outtmpl': os.path.join(\n                self.tu.dir_path['downloads'], '%(id)s.%(ext)s'),\n            'restrictfilenames': True,\n            'verbose': True,\n            'quiet': False,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,\n            'fixup': 'warn',\n            'nooverwrites': True,\n            'consoletitle': True,\n            'prefer_ffmpeg': True,\n            'call_home': False,\n            'logger': tu.logger,\n            'progress_hooks': [mocked_ydl_progress_hook],\n            'username': 'testUsername',\n            'password': 'testPassword'}\n\n        self.assertEqual(result, expected_result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/mocked_ydl_progress_hook",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/generate_ydl_options"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_create_archive_org_metadata_from_youtubedl_meta",
      "md_content": [],
      "code_start_line": 298,
      "code_end_line": 330,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_create_archive_org_metadata_from_youtubedl_meta(self):\n        with open(get_testfile_path(\n                'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A.info.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        expected_result = {\n            'mediatype': 'movies',\n            'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n            'creator': 'Video Background',\n            'collection': 'opensource_movies',\n            'title': 'Mountain 3 - Video Background HD 1080p',\n            'description': ('Mountain 3 - Video Background HD 1080p<br>'\n                            'If you use this video please put credits to my '\n                            'channel in description:<br>https://www.youtube.com'\n                            '/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© Don\\'t '\n                            'forget to SUBSCRIBE, LIKE, COMMENT and RATE. '\n                            'Hope you all enjoy!'),\n            'date': '2015-01-05',\n            'year': '2015',\n            'subject': ('Youtube;video;Entertainment;Video Background;Footage;'\n                        'Animation;Cinema;stock video footage;Royalty '\n                        'free videos;Creative Commons videos;free movies '\n                        'online;youtube;HD;1080p;Amazing Nature;Mountain;'),\n            'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A',\n            'licenseurl': 'https://creativecommons.org/licenses/by/3.0/',\n            'scanner': SCANNER}\n\n        self.assertEqual(expected_result, result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/get_testfile_path",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/create_archive_org_metadata_from_youtubedl_meta"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_create_archive_org_metadata_from_youtubedl_meta_description_text_null",
      "md_content": [],
      "code_start_line": 332,
      "code_end_line": 344,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_create_archive_org_metadata_from_youtubedl_meta_description_text_null(self):\n        with open(get_testfile_path(\n                'description_text_null.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        expected_description = ('')\n\n        self.assertEqual(expected_description, result.get('description'))\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/get_testfile_path",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/create_archive_org_metadata_from_youtubedl_meta"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_create_archive_org_metadata_from_youtubedl_meta_no_uploader",
      "md_content": [],
      "code_start_line": 346,
      "code_end_line": 379,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_create_archive_org_metadata_from_youtubedl_meta_no_uploader(self):\n        with open(get_testfile_path(\n                'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A.info_no_'\n                'uploader.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        expected_result = {\n            'mediatype': 'movies',\n            'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n            'creator': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n            'collection': 'opensource_movies',\n            'title': 'Mountain 3 - Video Background HD 1080p',\n            'description': ('Mountain 3 - Video Background HD 1080p<br>'\n                            'If you use this video please put credits to my '\n                            'channel in description:<br>https://www.youtube.com'\n                            '/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© Don\\'t '\n                            'forget to SUBSCRIBE, LIKE, COMMENT and RATE. '\n                            'Hope you all enjoy!'),\n            'date': '2015-01-05',\n            'year': '2015',\n            'subject': ('Youtube;video;Entertainment;Video Background;Footage;'\n                        'Animation;Cinema;stock video footage;Royalty '\n                        'free videos;Creative Commons videos;free movies '\n                        'online;youtube;HD;1080p;Amazing Nature;Mountain;'),\n            'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A',\n            'licenseurl': 'https://creativecommons.org/licenses/by/3.0/',\n            'scanner': SCANNER}\n\n        self.assertEqual(expected_result, result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/get_testfile_path",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/create_archive_org_metadata_from_youtubedl_meta"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_create_archive_org_metadata_from_youtubedl_meta_no_date",
      "md_content": [],
      "code_start_line": 381,
      "code_end_line": 417,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_create_archive_org_metadata_from_youtubedl_meta_no_date(self):\n        with open(get_testfile_path(\n                'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A.'\n                'info_no_date.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        upload_date = time.strftime(\"%Y-%m-%d\")\n        upload_year = time.strftime(\"%Y\")\n\n        expected_result = {\n            'mediatype': 'movies',\n            'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n            'creator': 'Video Background',\n            'collection': 'opensource_movies',\n            'title': 'Mountain 3 - Video Background HD 1080p',\n            'description': ('Mountain 3 - Video Background HD 1080p<br>'\n                            'If you use this video please put credits to my '\n                            'channel in description:<br>https://www.youtube.com'\n                            '/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© Don\\'t '\n                            'forget to SUBSCRIBE, LIKE, COMMENT and RATE. '\n                            'Hope you all enjoy!'),\n            'date': upload_date,\n            'year': upload_year,\n            'subject': ('Youtube;video;Entertainment;Video Background;Footage;'\n                        'Animation;Cinema;stock video footage;Royalty '\n                        'free videos;Creative Commons videos;free movies '\n                        'online;youtube;HD;1080p;Amazing Nature;Mountain;'),\n            'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A',\n            'licenseurl': 'https://creativecommons.org/licenses/by/3.0/',\n            'scanner': SCANNER}\n\n        self.assertEqual(expected_result, result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/get_testfile_path",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/create_archive_org_metadata_from_youtubedl_meta"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_create_archive_org_metadata_from_youtubedl_meta_twitch_clips",
      "md_content": [],
      "code_start_line": 419,
      "code_end_line": 442,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_create_archive_org_metadata_from_youtubedl_meta_twitch_clips(self):\n        with open(get_testfile_path(\n                'EA_Play_2016_Live_from_the_Novo_Theatre-42850523.info.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        expected_result = {\n            'mediatype': 'movies',\n            'creator': 'EA',\n            'collection': 'opensource_movies',\n            'title': 'EA Play 2016 Live from the Novo Theatre',\n            'description': (''),\n            'date': '2016-06-12',\n            'year': '2016',\n            'subject': 'TwitchClips;video;',\n            'originalurl': 'https://clips.twitch.tv/FaintLightGullWholeWheat',\n            'licenseurl': '',\n            'scanner': SCANNER}\n\n        self.assertEqual(expected_result, result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/get_testfile_path",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/create_archive_org_metadata_from_youtubedl_meta"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_create_archive_org_metadata_from_youtubedl_meta_mass_of_tags",
      "md_content": [],
      "code_start_line": 444,
      "code_end_line": 457,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_create_archive_org_metadata_from_youtubedl_meta_mass_of_tags(self):\n        with open(get_testfile_path(\n                'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A.info.json')\n        ) as f:\n            vid_meta = json.load(f)\n\n        vid_meta['tags'] = [f't{i}' for i in range(0, 300)]\n\n        result = TubeUp.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta\n        )\n\n        self.assertLessEqual(len(result['subject'].encode(encoding='utf-8')),\n                             255, msg='tags_string not truncated to <= 255 bytes')\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/get_testfile_path",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/create_archive_org_metadata_from_youtubedl_meta"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_get_resource_basenames",
      "md_content": [],
      "code_start_line": 459,
      "code_end_line": 473,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_get_resource_basenames(self):\n        tu = TubeUp(dir_path=os.path.join(current_path,\n                                          'test_tubeup_rootdir'))\n\n        copy_testfiles_to_tubeup_rootdir_test()\n\n        result = tu.get_resource_basenames(\n            ['https://www.youtube.com/watch?v=KdsN9YhkDrY'],\n            ignore_existing_item=True)\n\n        expected_result = {os.path.join(\n            current_path, 'test_tubeup_rootdir', 'downloads',\n            'KdsN9YhkDrY')}\n\n        self.assertEqual(expected_result, result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/copy_testfiles_to_tubeup_rootdir_test",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/get_resource_basenames"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_upload_ia",
      "md_content": [],
      "code_start_line": 475,
      "code_end_line": 532,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_upload_ia(self):\n        tu = TubeUp(dir_path=os.path.join(current_path,\n                                          'test_tubeup_rootdir'),\n                    # Use custom ia configuration file so we don't need\n                    # to login with username and password.\n                    ia_config_path=get_testfile_path('ia_config_for_test.ini'))\n\n        videobasename = os.path.join(\n            current_path, 'test_tubeup_rootdir', 'downloads',\n            'Mountain_3_-_Video_Background_HD_1080p-6iRV8liah8A')\n\n        copy_testfiles_to_tubeup_rootdir_test()\n\n        with requests_mock.Mocker() as m:\n            # Mock the request to s3.us.archive.org, so it will responds\n            # a custom json. `internetarchive` library sends GET request to\n            # that url to check that we don't violate the upload limit.\n            m.get('https://s3.us.archive.org',\n                  content=b'{\"over_limit\": 0}',\n                  headers={'content-type': 'application/json'})\n\n            m.get('https://archive.org/metadata/youtube-6iRV8liah8A',\n                  content=b'{}',\n                  headers={'content-type': 'application/json'})\n\n            # Mock the PUT requests for internetarchive urls that defined\n            # in mock_upload_response_by_videobasename(), so this test\n            # doesn't perform upload to the real archive.org server.\n            mock_upload_response_by_videobasename(\n                m, 'youtube-6iRV8liah8A', videobasename)\n\n            result = tu.upload_ia(videobasename)\n\n            expected_result = (\n                'youtube-6iRV8liah8A',\n                {'mediatype': 'movies',\n                 'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n                 'creator': 'Video Background',\n                 'collection': 'opensource_movies',\n                 'title': 'Mountain 3 - Video Background HD 1080p',\n                 'description': ('Mountain 3 - Video Background HD 1080p<br>If '\n                                 'you use this video please put credits to my'\n                                 ' channel in description:<br>https://www.youtub'\n                                 'e.com/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© D'\n                                 'on\\'t forget to SUBSCRIBE, LIKE, COMMENT an'\n                                 'd RATE. Hope you all enjoy!'),\n                 'date': '2015-01-05',\n                 'year': '2015',\n                 'subject': ('Youtube;video;Entertainment;Video Background;'\n                             'Footage;Animation;Cinema;stock video footage;'\n                             'Royalty free videos;Creative Commons videos;'\n                             'free movies online;youtube;HD;1080p;Amazing '\n                             'Nature;Mountain;'),\n                 'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A',\n                 'licenseurl': 'https://creativecommons.org/licenses/by/3.0/',\n                 'scanner': SCANNER})\n\n            self.assertEqual(expected_result, result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/get_testfile_path",
        "tests/test_tubeup.py/mock_upload_response_by_videobasename",
        "tests/test_tubeup.py/copy_testfiles_to_tubeup_rootdir_test",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/upload_ia"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "test_archive_urls",
      "md_content": [],
      "code_start_line": 534,
      "code_end_line": 592,
      "params": [
        "self"
      ],
      "have_return": false,
      "code_content": "    def test_archive_urls(self):\n        tu = TubeUp(dir_path=os.path.join(current_path,\n                                          'test_tubeup_rootdir'),\n                    ia_config_path=get_testfile_path('ia_config_for_test.ini'))\n\n        videobasename = os.path.join(\n            current_path, 'test_tubeup_rootdir', 'downloads',\n            'KdsN9YhkDrY')\n\n        copy_testfiles_to_tubeup_rootdir_test()\n\n        with requests_mock.Mocker() as m:\n            # Mock the request to s3.us.archive.org, so it will responds\n            # a custom json. `internetarchive` library sends GET request to\n            # that url to check that we don't violate the upload limit.\n            m.get('https://s3.us.archive.org',\n                  content=b'{\"over_limit\": 0}',\n                  headers={'content-type': 'application/json'})\n\n            m.get('https://archive.org/metadata/youtube-KdsN9YhkDrY',\n                  content=b'{}',\n                  headers={'content-type': 'application/json'})\n\n            # Mock the PUT requests for internetarchive urls that defined\n            # in mock_upload_response_by_videobasename(), so this test\n            # doesn't perform upload to the real archive.org server.\n            mock_upload_response_by_videobasename(\n                m, 'youtube-KdsN9YhkDrY', videobasename)\n\n            result = list(tu.archive_urls(\n                ['https://www.youtube.com/watch?v=KdsN9YhkDrY']))\n\n            expected_result = [(\n                'youtube-KdsN9YhkDrY',\n                {'mediatype': 'movies',\n                 'creator': 'RelaxingWorld',\n                 'channel': 'http://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg',\n                 'collection': 'opensource_movies',\n                 'title': 'Epic Ramadan - Video Background HD1080p',\n                 'description': ('If you enjoy my work, please consider Subscribe to my NEW '\n                                 'channel for more videos: <br>'\n                                 'https://www.youtube.com/MusicForRelaxation?sub_confirmation=1 <br>'\n                                 '▷ If you use this video, please put credits to my channel '\n                                 'in description: <br>'\n                                 'Source from RelaxingWorld: https://goo.gl/HsW75m<br>'\n                                 '<br>'\n                                 '▷ Also, do not forget to Subscribe to my channel. Thanks!'),\n                 'date': '2016-06-25',\n                 'year': '2016',\n                 'subject': ('Youtube;video;Film & Animation;Video Background;'\n                             'Footage;Animation;Cinema;Royalty Free Videos;'\n                             'Stock Video Footage;Video Backdrops;'\n                             'Amazing Nature;youtube;HD;1080p;Creative Commons Videos;'\n                             'relaxing music;Ramadan;'),\n                 'originalurl': 'https://www.youtube.com/watch?v=KdsN9YhkDrY',\n                 'licenseurl': '',\n                 'scanner': SCANNER})]\n\n            self.assertEqual(expected_result, result)\n",
      "name_column": 8,
      "item_status": "doc_has_not_been_generated",
      "who_reference_me": [],
      "reference_who": [
        "tests/test_tubeup.py/get_testfile_path",
        "tests/test_tubeup.py/mock_upload_response_by_videobasename",
        "tests/test_tubeup.py/copy_testfiles_to_tubeup_rootdir_test",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/archive_urls"
      ],
      "special_reference_type": [
        false,
        false,
        false,
        false,
        false
      ]
    }
  ],
  "tubeup/utils.py": [
    {
      "type": "FunctionDef",
      "name": "key_value_to_dict",
      "md_content": [
        "**key_value_to_dict**: The function of key_value_to_dict is to convert a list of key-value pair strings into a Python dictionary.\n\n**parameters**: The parameters of this Function.\n· lst: A list of strings, where each string is formatted as \"key:value\". If a single string is provided instead of a list, it will be converted into a list containing that string.\n\n**Code Description**: The key_value_to_dict function processes a list of strings, each representing a key-value pair separated by a colon. It first checks if the input is a list; if not, it wraps the input string in a list. The function then initializes a defaultdict of lists to store the results. As it iterates through each item in the list, it splits the string into a key and a value. An assertion ensures that a value is present for each key. If a key already exists in the result and the value is not already associated with that key, the value is appended to the list for that key. If the key does not exist, it initializes a new list with the value. \n\nAfter processing all items, the function converts any lists containing a single item back into a string, ensuring that the output dictionary has a consistent format. The final output is a dictionary where each key maps to either a single value or a list of values, depending on how many values were associated with that key.\n\nThis function is called within the main function of the tubeup/__main__.py module, specifically when parsing command-line arguments. The metadata argument, which is expected to be a string or a list of strings formatted as key-value pairs, is passed to key_value_to_dict. The resulting dictionary is then used to provide metadata for the TubeUp instance, which handles the archiving of URLs. This shows that key_value_to_dict plays a crucial role in transforming user input into a structured format that can be utilized by other components of the application.\n\n**Note**: It is important to ensure that the input strings are correctly formatted as \"key:value\" pairs. If any value is missing for a key, an assertion error will be raised.\n\n**Output Example**: \nGiven an input list like `[\"title:My Video\", \"description:This is a test video\", \"tags:video,test\", \"tags:example\"]`, the function would return:\n```python\n{\n    \"title\": \"My Video\",\n    \"description\": \"This is a test video\",\n    \"tags\": [\"video\", \"test\", \"example\"]\n}\n```"
      ],
      "code_start_line": 9,
      "code_end_line": 26,
      "params": [
        "lst"
      ],
      "have_return": true,
      "code_content": "def key_value_to_dict(lst):\n    \"\"\"\n    Convert many key:value pair strings into a python dictionary\n    \"\"\"\n    if not isinstance(lst, list):\n        lst = [lst]\n\n    result = defaultdict(list)\n    for item in lst:\n        key, value = item.split(\":\", 1)\n        assert value, f\"Expected a value! for {key}\"\n        if result[key] and value not in result[key]:\n            result[key].append(value)\n        else:\n            result[key] = [value]\n\n    # Convert single-item lists back to strings for non-list values\n    return {k: v if len(v) > 1 else v[0] for k, v in result.items()}\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tubeup/__main__.py",
        "tubeup/__main__.py/main"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "sanitize_identifier",
      "md_content": [
        "**sanitize_identifier**: The function of sanitize_identifier is to sanitize a given identifier by replacing any illegal characters with a specified replacement character.\n\n**parameters**: The parameters of this Function.\n· parameter1: identifier - A string that represents the identifier to be sanitized.\n· parameter2: replacement - A string that specifies the character to replace illegal characters with. The default value is a hyphen ('-').\n\n**Code Description**: The sanitize_identifier function utilizes a regular expression to identify and replace any character in the input string that is not a word character (alphanumeric or underscore) or a hyphen. This is achieved through the use of the re.sub function, which substitutes all occurrences of the matched pattern with the specified replacement character. \n\nThis function is particularly useful in scenarios where identifiers need to conform to specific formatting rules, such as when generating URLs or file names that cannot contain certain special characters. \n\nIn the project, sanitize_identifier is called within the get_itemname function, which constructs an identifier by concatenating the 'extractor' and 'display_id' (or 'id') fields from an input dictionary. The resulting string is then sanitized to ensure it adheres to the required format. \n\nAdditionally, the function is tested in the UtilsTest class, where it is used to verify that valid identifiers remain unchanged and that invalid identifiers are correctly sanitized. The tests ensure that the function behaves as expected across a range of inputs, confirming its reliability in maintaining identifier integrity.\n\n**Note**: It is important to ensure that the replacement character does not introduce ambiguity in the identifier, especially if the identifier is used in contexts where unique identification is critical.\n\n**Output Example**: For an input of 'twitch:vod-v181464551', the function would return 'twitch-vod-v181464551' when using the default replacement character '-'."
      ],
      "code_start_line": 28,
      "code_end_line": 29,
      "params": [
        "identifier",
        "replacement"
      ],
      "have_return": true,
      "code_content": "def sanitize_identifier(identifier, replacement='-'):\n    return re.sub(r'[^\\w-]', replacement, identifier)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_utils.py",
        "tests/test_utils.py/UtilsTest/test_preserve_valid_identifiers",
        "tests/test_utils.py/UtilsTest/test_sanitize_bad_identifiers",
        "tubeup/utils.py/get_itemname"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "get_itemname",
      "md_content": [
        "**get_itemname**: The function of get_itemname is to construct a sanitized identifier for an item based on the provided information dictionary.\n\n**parameters**: The parameters of this Function.\n· parameter1: infodict - A dictionary containing information about the item, specifically the 'extractor' and either 'display_id' or 'id'.\n\n**Code Description**: The get_itemname function takes a single parameter, infodict, which is expected to be a dictionary containing metadata about an item. The function constructs a string by concatenating the value associated with the 'extractor' key and the value associated with either the 'display_id' key or the 'id' key from the infodict. If 'display_id' is not present, it defaults to using 'id'. \n\nThis concatenated string is formatted with a hyphen ('-') separating the two values. The resulting string is then passed to the sanitize_identifier function, which sanitizes the identifier by replacing any illegal characters with a specified replacement character (defaulting to a hyphen). This ensures that the identifier conforms to the required formatting rules, making it suitable for use in contexts such as URLs or file names.\n\nThe get_itemname function is called in multiple locations within the project. For instance, in the check_if_ia_item_exists function, get_itemname is used to generate the item name before checking if the item already exists in the Internet Archive. Similarly, in the upload_ia method, get_itemname is invoked to create the item name based on the video metadata before proceeding with the upload process. This highlights the function's role in ensuring that identifiers are consistently formatted and valid across different operations involving item management.\n\n**Note**: It is important to ensure that the infodict passed to get_itemname contains the necessary keys ('extractor', 'display_id', or 'id') to avoid potential KeyError exceptions. Proper handling of these keys is crucial for the function to operate correctly.\n\n**Output Example**: For an input dictionary like {'extractor': 'twitch', 'display_id': 'vod-v181464551'}, the function would return 'twitch-vod-v181464551' after sanitization."
      ],
      "code_start_line": 32,
      "code_end_line": 37,
      "params": [
        "infodict"
      ],
      "have_return": true,
      "code_content": "def get_itemname(infodict):\n    # Remove illegal characters in identifier\n    return sanitize_identifier('%s-%s' % (\n        infodict.get('extractor'),\n        infodict.get('display_id', infodict.get('id')),\n    ))\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tubeup/TubeUp.py",
        "tubeup/TubeUp.py/TubeUp/get_resource_basenames/check_if_ia_item_exists",
        "tubeup/TubeUp.py/TubeUp/upload_ia"
      ],
      "reference_who": [
        "tubeup/utils.py/sanitize_identifier"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "check_is_file_empty",
      "md_content": [
        "**check_is_file_empty**: The function of check_is_file_empty is to determine whether a specified file is empty or not.\n\n**parameters**: The parameters of this Function.\n· filepath: Path of a file that will be checked.\n\n**Code Description**: The check_is_file_empty function checks if a file at the given filepath exists and whether it is empty. It utilizes the os module to verify the existence of the file and to retrieve its size. If the file exists, the function returns True if the file size is zero, indicating that the file is empty. If the file does not exist, the function raises a FileNotFoundError with a message indicating that the specified path does not exist.\n\nThis function is called in various test cases within the tests/test_utils.py file. Specifically, it is used in three test methods: \n1. test_check_is_file_empty_when_file_is_empty: This test creates an empty file and asserts that the function correctly identifies it as empty.\n2. test_check_is_file_empty_when_file_is_not_empty: This test creates a non-empty file and asserts that the function correctly identifies it as not empty.\n3. test_check_is_file_empty_when_file_doesnt_exist: This test checks the function's behavior when a non-existent file path is provided, expecting a FileNotFoundError to be raised.\n\nThe check_is_file_empty function is also utilized in the upload_ia method of the TubeUp class. In this context, it is used to check if certain files, such as a description file and an annotations file, are empty before deciding to delete them. This ensures that only relevant files are uploaded to the Internet Archive, preventing unnecessary empty files from being processed.\n\n**Note**: It is important to ensure that the filepath provided to the function is valid and that the file exists to avoid raising a FileNotFoundError.\n\n**Output Example**: \n- If the file is empty: True\n- If the file is not empty: False\n- If the file does not exist: Raises FileNotFoundError with the message \"Path 'filepath' doesn't exist\""
      ],
      "code_start_line": 40,
      "code_end_line": 50,
      "params": [
        "filepath"
      ],
      "have_return": true,
      "code_content": "def check_is_file_empty(filepath):\n    \"\"\"\n    Check whether file is empty or not.\n\n    :param filepath:  Path of a file that will be checked.\n    :return:          True if the file empty.\n    \"\"\"\n    if os.path.exists(filepath):\n        return os.stat(filepath).st_size == 0\n    else:\n        raise FileNotFoundError(\"Path '%s' doesn't exist\" % filepath)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_utils.py",
        "tests/test_utils.py/UtilsTest/test_check_is_file_empty_when_file_is_empty",
        "tests/test_utils.py/UtilsTest/test_check_is_file_empty_when_file_is_not_empty",
        "tests/test_utils.py/UtilsTest/test_check_is_file_empty_when_file_doesnt_exist",
        "tubeup/TubeUp.py",
        "tubeup/TubeUp.py/TubeUp/upload_ia"
      ],
      "reference_who": [],
      "special_reference_type": []
    }
  ],
  "tubeup/__init__.py": [],
  "tubeup/__main__.py": [
    {
      "type": "FunctionDef",
      "name": "main",
      "md_content": [
        "**main**: The function of main is to parse command-line arguments, configure logging, and manage the process of archiving URLs by utilizing the TubeUp class.\n\n**parameters**: The parameters of this Function.\n· None\n\n**Code Description**: The main function serves as the entry point for the TubeUp application. It begins by parsing command-line arguments using the docopt library, which interprets the command-line input based on the provided documentation string (__doc__). The parsed arguments include a list of URLs to be archived, optional parameters for cookies, proxy settings, user credentials, and various modes such as quiet and debug.\n\nOnce the arguments are parsed, the function checks if the debug mode is enabled. If so, it configures the logging settings to display detailed debug messages. This involves setting the logging level to DEBUG, creating a stream handler that outputs logs to standard output, and formatting the log messages to include timestamps and log levels.\n\nThe function then processes the metadata argument by converting it from a list of key-value pairs into a dictionary using the key_value_to_dict function. This transformation is crucial as it structures the metadata in a way that can be easily utilized by the TubeUp instance.\n\nNext, an instance of the TubeUp class is created, with verbosity controlled by the quiet_mode parameter and an output template specified by the command-line arguments. The TubeUp class is responsible for downloading videos from YouTube and uploading them to archive.org.\n\nThe main function then enters a try-except block where it calls the archive_urls method of the TubeUp instance. This method handles the downloading and uploading of the specified URLs, yielding identifiers and metadata for each successfully uploaded item. After each upload, the function prints the title and URL of the uploaded item.\n\nIn the event of an exception during the archiving process, the function captures the error, prints a user-friendly message, and provides a traceback for debugging purposes. This ensures that users are informed of any issues that arise during execution, particularly those unrelated to connection problems.\n\nOverall, the main function orchestrates the entire process of archiving URLs by coordinating user input, configuring logging, and managing interactions with the TubeUp class, which encapsulates the core functionality of the application.\n\n**Note**: It is essential to ensure that the command-line arguments are correctly formatted and that the necessary dependencies, such as the docopt library and the TubeUp class, are properly installed and configured. Users should also be aware of the requirements for the Internet Archive configuration to facilitate successful uploads."
      ],
      "code_start_line": 64,
      "code_end_line": 113,
      "params": [],
      "have_return": false,
      "code_content": "def main():\n    # Parse arguments from file docstring\n    args = docopt.docopt(__doc__, version=__version__)\n\n    URLs = args['<url>']\n    cookie_file = args['--cookies']\n    proxy_url = args['--proxy']\n    username = args['--username']\n    password = args['--password']\n    quiet_mode = args['--quiet']\n    debug_mode = args['--debug']\n    use_download_archive = args['--use-download-archive']\n    ignore_existing_item = args['--ignore-existing-item']\n\n    if debug_mode:\n        # Display log messages.\n        root = logging.getLogger()\n        root.setLevel(logging.DEBUG)\n\n        ch = logging.StreamHandler(sys.stdout)\n        ch.setLevel(logging.DEBUG)\n        formatter = logging.Formatter(\n            '\\033[92m[DEBUG]\\033[0m %(asctime)s - %(name)s - %(levelname)s - '\n            '%(message)s')\n        ch.setFormatter(formatter)\n        root.addHandler(ch)\n\n    metadata = key_value_to_dict(args['--metadata'])\n\n    tu = TubeUp(verbose=not quiet_mode,\n                output_template=args['--output'])\n\n    try:\n        for identifier, meta in tu.archive_urls(URLs, metadata,\n                                                cookie_file, proxy_url,\n                                                username, password,\n                                                use_download_archive,\n                                                ignore_existing_item):\n            print('\\n:: Upload Finished. Item information:')\n            print('Title: %s' % meta['title'])\n            print('Item URL: https://archive.org/details/%s\\n' % identifier)\n    except Exception:\n        print('\\n\\033[91m'  # Start red color text\n              'An exception just occured, if you found this '\n              \"exception isn't related with any of your connection problem, \"\n              'please report this issue to '\n              'https://github.com/bibanon/tubeup/issues')\n        traceback.print_exc()\n        print('\\033[0m')  # End the red color text\n        sys.exit(1)\n",
      "name_column": 4,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/utils.py/key_value_to_dict",
        "tubeup/TubeUp.py/TubeUp",
        "tubeup/TubeUp.py/TubeUp/archive_urls"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    }
  ],
  "tubeup/TubeUp.py": [
    {
      "type": "ClassDef",
      "name": "TubeUp",
      "md_content": [
        "**TubeUp**: The function of TubeUp is to archive YouTube videos by downloading them and uploading them to archive.org.\n\n**attributes**: The attributes of this Class.\n· verbose: A boolean indicating whether to print all loggings to stdout.  \n· dir_path: A string representing the path to the directory used for saving downloaded resources.  \n· ia_config_path: A string representing the path to an Internet Archive configuration file used for uploading files.  \n· output_template: A string template used to generate output filenames.  \n· logger: A logging.Logger instance for logging messages.  \n· output_template: A string that defines the output filename format for downloaded files.  \n\n**Code Description**: The TubeUp class is designed to facilitate the archiving of YouTube videos by downloading them and subsequently uploading them to the Internet Archive. Upon initialization, the class accepts parameters that configure its behavior, such as verbosity for logging, the directory path for saving downloaded files, and the path to an Internet Archive configuration file. The class maintains a logger that can be set to different levels of verbosity based on the user's preference.\n\nThe class provides several methods to perform its core functionalities:\n- `get_resource_basenames`: This method retrieves the base names of resources from a list of URLs. It utilizes the youtube-dl library to extract video information and checks if the items already exist in the Internet Archive.\n- `upload_ia`: This method uploads a specified video to the Internet Archive, using metadata generated from the downloaded video. It ensures that only complete files are uploaded and handles the creation of necessary metadata.\n- `archive_urls`: This method orchestrates the downloading and uploading process for a list of URLs, yielding the identifiers and metadata of the uploaded items.\n\nThe TubeUp class is called within the test suite located in `tests/test_tubeup.py`, specifically in the `TubeUpTests` class. Various test methods utilize the TubeUp class to validate its functionality, including setting up instances, testing attribute configurations, generating options for youtube-dl, and verifying the creation of metadata for uploads. These tests ensure that the TubeUp class behaves as expected under different scenarios, confirming its reliability and correctness.\n\n**Note**: When using the TubeUp class, ensure that the specified directory for downloads exists or can be created, and that the Internet Archive configuration file is correctly set up to allow for successful uploads.\n\n**Output Example**: A possible output from the `archive_urls` method could be:\n```\n:: Upload Finished. Item information:\nTitle: Mountain 3 - Video Background HD 1080p\nItem URL: https://archive.org/details/youtube-6iRV8liah8A\n```"
      ],
      "code_start_line": 24,
      "code_end_line": 553,
      "params": [],
      "have_return": true,
      "code_content": "class TubeUp(object):\n\n    def __init__(self,\n                 verbose=False,\n                 dir_path='~/.tubeup',\n                 ia_config_path=None,\n                 output_template=None):\n        \"\"\"\n        `tubeup` is a tool to archive YouTube by downloading the videos and\n        uploading it back to the archive.org.\n\n        :param verbose:         A boolean, True means all loggings will be\n                                printed out to stdout.\n        :param dir_path:        A path to directory that will be used for\n                                saving the downloaded resources. Default to\n                               '~/.tubeup'.\n        :param ia_config_path:  Path to an internetarchive config file, will\n                                be used in uploading the file.\n        :param output_template: A template string that will be used to\n                                generate the output filenames.\n        \"\"\"\n        self.dir_path = dir_path\n        self.verbose = verbose\n        self.ia_config_path = ia_config_path\n        self.logger = getLogger(__name__)\n        if output_template is None:\n            self.output_template = '%(id)s.%(ext)s'\n        else:\n            self.output_template = output_template\n\n        # Just print errors in quiet mode\n        if not self.verbose:\n            self.logger.setLevel(logging.ERROR)\n\n    @property\n    def dir_path(self):\n        return self._dir_path\n\n    @dir_path.setter\n    def dir_path(self, dir_path):\n        \"\"\"\n        Set a directory to be the saving directory for resources that have\n        been downloaded.\n\n        :param dir_path:  Path to a directory that will be used to save the\n                          videos, if it not created yet, the directory\n                          will be created.\n        \"\"\"\n        extended_usr_dir_path = os.path.expanduser(dir_path)\n\n        # Create the directories.\n        os.makedirs(\n            os.path.join(extended_usr_dir_path, DOWNLOAD_DIR_NAME),\n            exist_ok=True)\n\n        self._dir_path = {\n            'root': extended_usr_dir_path,\n            'downloads': os.path.join(extended_usr_dir_path,\n                                      DOWNLOAD_DIR_NAME)\n        }\n\n    def get_resource_basenames(self, urls,\n                               cookie_file=None, proxy_url=None,\n                               ydl_username=None, ydl_password=None,\n                               use_download_archive=False,\n                               ignore_existing_item=False):\n        \"\"\"\n        Get resource basenames from an url.\n\n        :param urls:                  A list of urls that will be downloaded with\n                                      youtubedl.\n        :param cookie_file:           A cookie file for YoutubeDL.\n        :param proxy_url:             A proxy url for YoutubeDL.\n        :param ydl_username:          Username that will be used to download the\n                                      resources with youtube_dl.\n        :param ydl_password:          Password of the related username, will be used\n                                      to download the resources with youtube_dl.\n        :param use_download_archive:  Record the video url to the download archive.\n                                      This will download only videos not listed in\n                                      the archive file. Record the IDs of all\n                                      downloaded videos in it.\n        :param ignore_existing_item:  Ignores the check for existing items on archive.org.\n        :return:                      Set of videos basename that has been downloaded.\n        \"\"\"\n        downloaded_files_basename = set()\n\n        def check_if_ia_item_exists(infodict):\n            itemname = get_itemname(infodict)\n            item = internetarchive.get_item(itemname)\n            if item.exists and self.verbose:\n                print(\"\\n:: Item already exists. Not downloading.\")\n                print('Title: %s' % infodict['title'])\n                print('Video URL: %s\\n' % infodict['webpage_url'])\n                return True\n            return False\n\n        def ydl_progress_each(entry):\n            if not entry:\n                self.logger.warning('Video \"%s\" is not available. Skipping.' % url)\n                return\n            if ydl.in_download_archive(entry):\n                return\n            if not check_if_ia_item_exists(entry):\n                ydl.extract_info(entry['webpage_url'])\n                downloaded_files_basename.update(self.create_basenames_from_ydl_info_dict(ydl, entry))\n            else:\n                ydl.record_download_archive(entry)\n\n        def ydl_progress_hook(d):\n            if d['status'] == 'downloading' and self.verbose:\n                if d.get('_total_bytes_str') is not None:\n                    msg_template = ('%(_percent_str)s of %(_total_bytes_str)s '\n                                    'at %(_speed_str)s ETA %(_eta_str)s')\n                elif d.get('_total_bytes_estimate_str') is not None:\n                    msg_template = ('%(_percent_str)s of '\n                                    '~%(_total_bytes_estimate_str)s at '\n                                    '%(_speed_str)s ETA %(_eta_str)s')\n                elif d.get('_downloaded_bytes_str') is not None:\n                    if d.get('_elapsed_str'):\n                        msg_template = ('%(_downloaded_bytes_str)s at '\n                                        '%(_speed_str)s (%(_elapsed_str)s)')\n                    else:\n                        msg_template = ('%(_downloaded_bytes_str)s '\n                                        'at %(_speed_str)s')\n                else:\n                    msg_template = ('%(_percent_str)s % at '\n                                    '%(_speed_str)s ETA %(_eta_str)s')\n\n                process_msg = '\\r[download] ' + (msg_template % d) + '\\033[K'\n                sys.stdout.write(process_msg)\n                sys.stdout.flush()\n\n            if d['status'] == 'finished':\n                msg = '\\nDownloaded %s' % d['filename']\n\n                self.logger.debug(d)\n                self.logger.info(msg)\n                if self.verbose:\n                    print(msg)\n\n            if d['status'] == 'error':\n                # TODO: Complete the error message\n                msg = 'Error when downloading the video'\n\n                self.logger.error(msg)\n                if self.verbose:\n                    print(msg)\n\n        ydl_opts = self.generate_ydl_options(ydl_progress_hook,\n                                             cookie_file, proxy_url,\n                                             ydl_username, ydl_password,\n                                             use_download_archive)\n\n        with YoutubeDL(ydl_opts) as ydl:\n            for url in urls:\n                if not ignore_existing_item:\n                    # Get the info dict of the url\n                    info_dict = ydl.extract_info(url, download=False)\n\n                    if info_dict.get('_type', 'video') == 'playlist':\n                        for entry in info_dict['entries']:\n                            ydl_progress_each(entry)\n                    else:\n                        ydl_progress_each(info_dict)\n                else:\n                    info_dict = ydl.extract_info(url)\n                    downloaded_files_basename.update(self.create_basenames_from_ydl_info_dict(ydl, info_dict))\n\n        self.logger.debug(\n            'Basenames obtained from url (%s): %s'\n            % (url, downloaded_files_basename))\n\n        return downloaded_files_basename\n\n    def create_basenames_from_ydl_info_dict(self, ydl, info_dict):\n        \"\"\"\n        Create basenames from YoutubeDL info_dict.\n\n        :param ydl:        A `youtube_dl.YoutubeDL` instance.\n        :param info_dict:  A ydl info_dict that will be used to create\n                           the basenames.\n        :return:           A set that contains basenames that created from\n                           the `info_dict`.\n        \"\"\"\n        info_type = info_dict.get('_type', 'video')\n        self.logger.debug('Creating basenames from ydl info dict with type %s'\n                          % info_type)\n\n        filenames = set()\n\n        if info_type == 'playlist':\n            # Iterate and get the filenames through the playlist\n            for video in info_dict['entries']:\n                filenames.add(ydl.prepare_filename(video))\n        else:\n            filenames.add(ydl.prepare_filename(info_dict))\n\n        basenames = set()\n\n        for filename in filenames:\n            filename_without_ext = os.path.splitext(filename)[0]\n            file_basename = re.sub(r'(\\.f\\d+)', '', filename_without_ext)\n            basenames.add(file_basename)\n\n        return basenames\n\n    def generate_ydl_options(self,\n                             ydl_progress_hook,\n                             cookie_file=None,\n                             proxy_url=None,\n                             ydl_username=None,\n                             ydl_password=None,\n                             use_download_archive=False,\n                             ydl_output_template=None):\n        \"\"\"\n        Generate a dictionary that contains options that will be used\n        by yt-dlp.\n\n        :param ydl_progress_hook:     A function that will be called during the\n                                      download process by youtube_dl.\n        :param proxy_url:             A proxy url for YoutubeDL.\n        :param ydl_username:          Username that will be used to download the\n                                      resources with youtube_dl.\n        :param ydl_password:          Password of the related username, will be\n                                      used to download the resources with\n                                      youtube_dl.\n        :param use_download_archive:  Record the video url to the download archive.\n                                      This will download only videos not listed in\n                                      the archive file. Record the IDs of all\n                                      downloaded videos in it.\n        :return:                      A dictionary that contains options that will\n                                      be used by youtube_dl.\n        \"\"\"\n        ydl_opts = {\n            'outtmpl': os.path.join(self.dir_path['downloads'],\n                                    self.output_template),\n            'restrictfilenames': True,\n            'quiet': not self.verbose,\n            'verbose': self.verbose,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,  # Geo-blocked,\n                                   # copyrighted/private/deleted\n                                   # will be printed to STDOUT and channel\n                                   # ripping will  continue uninterupted,\n                                   # use with verbose off\n            'fixup': 'warn',  # Slightly more verbosity for debugging\n                              # problems\n            'nooverwrites': True,  # Don't touch what's already been\n                                   # downloaded speeds things\n            'consoletitle': True,   # Download percentage in console title\n            'prefer_ffmpeg': True,  # `ffmpeg` is better than `avconv`,\n                                    # let's prefer it's use\n            # Warns on out of date youtube-dl script, helps debugging for\n            # youtube-dl devs\n            'call_home': False,\n            'logger': self.logger,\n            'progress_hooks': [ydl_progress_hook]\n        }\n\n        if cookie_file is not None:\n            ydl_opts['cookiefile'] = cookie_file\n\n        if proxy_url is not None:\n            ydl_opts['proxy'] = proxy_url\n\n        if ydl_username is not None:\n            ydl_opts['username'] = ydl_username\n\n        if ydl_password is not None:\n            ydl_opts['password'] = ydl_password\n\n        if use_download_archive:\n            ydl_opts['download_archive'] = os.path.join(self.dir_path['root'],\n                                                        '.ytdlarchive')\n\n        return ydl_opts\n\n    def upload_ia(self, videobasename, custom_meta=None):\n        \"\"\"\n        Upload video to archive.org.\n\n        :param videobasename:  A video base name.\n        :param custom_meta:    A custom meta, will be used by internetarchive\n                               library when uploading to archive.org.\n        :return:               A tuple containing item name and metadata used\n                               when uploading to archive.org and whether the item\n                               already exists.\n        \"\"\"\n        json_metadata_filepath = videobasename + '.info.json'\n        with open(json_metadata_filepath, 'r', encoding='utf-8') as f:\n            vid_meta = json.load(f)\n\n        # Exit if video download did not complete, don't upload .part files to IA\n        for ext in ['*.part', '*.f303.*', '*.f302.*', '*.ytdl', '*.f251.*', '*.248.*', '*.f247.*', '*.temp']:\n            if glob.glob(videobasename + ext):\n                msg = 'Video download incomplete, please re-run or delete video stubs in downloads folder, exiting...'\n                raise Exception(msg)\n\n        itemname = get_itemname(vid_meta)\n        metadata = self.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta)\n\n        # Delete empty description file\n        description_file_path = videobasename + '.description'\n        if (os.path.exists(description_file_path) and\n            (('description' in vid_meta and\n             vid_meta['description'] == '') or\n                check_is_file_empty(description_file_path))):\n            os.remove(description_file_path)\n\n        # Delete empty annotations.xml file so it isn't uploaded\n        annotations_file_path = videobasename + '.annotations.xml'\n        if (os.path.exists(annotations_file_path) and\n            (('annotations' in vid_meta and\n             vid_meta['annotations'] in {'', EMPTY_ANNOTATION_FILE}) or\n                check_is_file_empty(annotations_file_path))):\n            os.remove(annotations_file_path)\n\n        # Upload all files with videobase name: e.g. video.mp4,\n        # video.info.json, video.srt, etc.\n        files_to_upload = glob.glob(videobasename + '*')\n\n        # Upload the item to the Internet Archive\n        item = internetarchive.get_item(itemname)\n\n        if custom_meta:\n            metadata.update(custom_meta)\n\n        # Parse internetarchive configuration file.\n        parsed_ia_s3_config = parse_config_file(self.ia_config_path)[2]['s3']\n        s3_access_key = parsed_ia_s3_config['access']\n        s3_secret_key = parsed_ia_s3_config['secret']\n\n        if None in {s3_access_key, s3_secret_key}:\n            msg = ('`internetarchive` configuration file is not configured'\n                   ' properly.')\n\n            self.logger.error(msg)\n            if self.verbose:\n                print(msg)\n            raise Exception(msg)\n\n        item.upload(files_to_upload, metadata=metadata, retries=9001,\n                    request_kwargs=dict(timeout=(9001, 9001)), delete=True,\n                    verbose=self.verbose, access_key=s3_access_key,\n                    secret_key=s3_secret_key)\n\n        return itemname, metadata\n\n    def archive_urls(self, urls, custom_meta=None,\n                     cookie_file=None, proxy=None,\n                     ydl_username=None, ydl_password=None,\n                     use_download_archive=False,\n                     ignore_existing_item=False):\n        \"\"\"\n        Download and upload videos from youtube_dl supported sites to\n        archive.org\n\n        :param urls:                  List of url that will be downloaded and uploaded\n                                      to archive.org\n        :param custom_meta:           A custom metadata that will be used when\n                                      uploading the file with archive.org.\n        :param cookie_file:           A cookie file for YoutubeDL.\n        :param proxy_url:             A proxy url for YoutubeDL.\n        :param ydl_username:          Username that will be used to download the\n                                      resources with youtube_dl.\n        :param ydl_password:          Password of the related username, will be used\n                                      to download the resources with youtube_dl.\n        :param use_download_archive:  Record the video url to the download archive.\n                                      This will download only videos not listed in\n                                      the archive file. Record the IDs of all\n                                      downloaded videos in it.\n        :param ignore_existing_item:  Ignores the check for existing items on archive.org.\n        :return:                      Tuple containing identifier and metadata of the\n                                      file that has been uploaded to archive.org.\n        \"\"\"\n        downloaded_file_basenames = self.get_resource_basenames(\n            urls, cookie_file, proxy, ydl_username, ydl_password, use_download_archive,\n            ignore_existing_item)\n        for basename in downloaded_file_basenames:\n            identifier, meta = self.upload_ia(basename, custom_meta)\n            yield identifier, meta\n\n    @staticmethod\n    def determine_collection_type(url):\n        \"\"\"\n        Determine collection type for an url.\n\n        :param url:  URL that the collection type will be determined.\n        :return:     String, name of a collection.\n        \"\"\"\n        if urlparse(url).netloc == 'soundcloud.com':\n            return 'opensource_audio'\n        return 'opensource_movies'\n\n    @staticmethod\n    def determine_licenseurl(vid_meta):\n        \"\"\"\n        Determine licenseurl for an url\n\n        :param vid_meta:\n        :return:\n        \"\"\"\n        licenseurl = ''\n        licenses = {\n            \"Creative Commons Attribution license (reuse allowed)\": \"https://creativecommons.org/licenses/by/3.0/\",\n            \"Attribution-NonCommercial-ShareAlike\": \"https://creativecommons.org/licenses/by-nc-sa/2.0/\",\n            \"Attribution-NonCommercial\": \"https://creativecommons.org/licenses/by-nc/2.0/\",\n            \"Attribution-NonCommercial-NoDerivs\": \"https://creativecommons.org/licenses/by-nc-nd/2.0/\",\n            \"Attribution\": \"https://creativecommons.org/licenses/by/2.0/\",\n            \"Attribution-ShareAlike\": \"https://creativecommons.org/licenses/by-sa/2.0/\",\n            \"Attribution-NoDerivs\": \"https://creativecommons.org/licenses/by-nd/2.0/\"\n        }\n\n        if 'license' in vid_meta and vid_meta['license']:\n            licenseurl = licenses.get(vid_meta['license'])\n\n        return licenseurl\n\n    @staticmethod\n    def create_archive_org_metadata_from_youtubedl_meta(vid_meta):\n        \"\"\"\n        Create an archive.org from youtubedl-generated metadata.\n\n        :param vid_meta: A dict containing youtubedl-generated metadata.\n        :return:         A dict containing metadata to be used by\n                         internetarchive library.\n        \"\"\"\n        title = '%s' % (vid_meta['title'])\n        videourl = vid_meta['webpage_url']\n\n        collection = TubeUp.determine_collection_type(videourl)\n\n        # Some video services don't tell you the uploader,\n        # use our program's name in that case.\n        try:\n            if vid_meta['extractor_key'] == 'TwitchClips' and 'creator' in vid_meta and vid_meta['creator']:\n                uploader = vid_meta['creator']\n            elif 'uploader' in vid_meta and vid_meta['uploader']:\n                uploader = vid_meta['uploader']\n            elif 'uploader_url' in vid_meta and vid_meta['uploader_url']:\n                uploader = vid_meta['uploader_url']\n            else:\n                uploader = 'tubeup.py'\n        except TypeError:  # apparently uploader is null as well\n            uploader = 'tubeup.py'\n\n        try:  # some videos don't give an upload date\n            d = datetime.strptime(vid_meta['upload_date'], '%Y%m%d')\n            upload_date = d.isoformat().split('T')[0]\n            upload_year = upload_date[:4]  # 20150614 -> 2015\n        except (KeyError, TypeError):\n            # Use current date and time as default values\n            upload_date = time.strftime(\"%Y-%m-%d\")\n            upload_year = time.strftime(\"%Y\")\n\n        # load up tags into an IA compatible semicolon-separated string\n        # example: Youtube;video;\n        tags_string = '%s;video;' % vid_meta['extractor_key']\n\n        if 'categories' in vid_meta:\n            # add categories as tags as well, if they exist\n            try:\n                for category in vid_meta['categories']:\n                    tags_string += '%s;' % category\n            except Exception:\n                print(\"No categories found.\")\n\n        if 'tags' in vid_meta:  # some video services don't have tags\n            try:\n                if 'tags' in vid_meta is None:\n                    tags_string += '%s;' % vid_meta['id']\n                    tags_string += '%s;' % 'video'\n                else:\n                    for tag in vid_meta['tags']:\n                        tags_string += '%s;' % tag\n            except Exception:\n                print(\"Unable to process tags successfully.\")\n\n        # IA's subject field has a 255 bytes length limit, so we need to truncate tags_string\n        while len(tags_string.encode('utf-8')) > 255:\n            tags_list = tags_string.split(';')\n            tags_list.pop()\n            tags_string = ';'.join(tags_list)\n\n        # license\n        licenseurl = TubeUp.determine_licenseurl(vid_meta)\n\n        # if there is no description don't upload the empty .description file\n        description_text = vid_meta.get('description', '')\n        if description_text is None:\n            description_text = ''\n        # archive.org does not display raw newlines\n        description = re.sub('\\r?\\n', '<br>', description_text)\n\n        metadata = dict(\n            mediatype=('audio' if collection == 'opensource_audio'\n                       else 'movies'),\n            creator=uploader,\n            collection=collection,\n            title=title,\n            description=description,\n            date=upload_date,\n            year=upload_year,\n            subject=tags_string,\n            originalurl=videourl,\n            licenseurl=licenseurl,\n\n            # Set 'scanner' metadata pair to allow tracking of TubeUp\n            # powered uploads, per request from archive.org\n            scanner='TubeUp Video Stream Mirroring Application {}'.format(__version__))\n\n        # add channel url if it exists\n        if 'uploader_url' in vid_meta:\n            metadata[\"channel\"] = vid_meta[\"uploader_url\"]\n        elif 'channel_url' in vid_meta:\n            metadata[\"channel\"] = vid_meta[\"channel_url\"]\n\n        return metadata\n",
      "name_column": 6,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_tubeup.py",
        "tests/test_tubeup.py/TubeUpTests/setUp",
        "tests/test_tubeup.py/TubeUpTests/test_tubeup_attribute_logger_when_verbose_mode",
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options_with_verbose_mode",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_description_text_null",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_no_uploader",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_no_date",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_twitch_clips",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_mass_of_tags",
        "tests/test_tubeup.py/TubeUpTests/test_get_resource_basenames",
        "tests/test_tubeup.py/TubeUpTests/test_upload_ia",
        "tests/test_tubeup.py/TubeUpTests/test_archive_urls",
        "tubeup/__main__.py",
        "tubeup/__main__.py/main"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "__init__",
      "md_content": [
        "**__init__**: The function of __init__ is to initialize an instance of the TubeUp class with specified configurations.\n\n**parameters**: The parameters of this Function.\n· verbose: A boolean indicating whether to print all loggings to stdout. Default is False.\n· dir_path: A string representing the path to the directory for saving downloaded resources. Default is '~/.tubeup'.\n· ia_config_path: A string representing the path to an internetarchive configuration file used for uploading files.\n· output_template: A string template used to generate output filenames. Default is None, which results in a standard template.\n\n**Code Description**: The __init__ function serves as the constructor for the TubeUp class, setting up the initial state of an instance. It accepts four parameters that configure the behavior of the instance. The verbose parameter, when set to True, enables detailed logging output to the standard output, which is useful for debugging and monitoring the application's behavior. The dir_path parameter specifies the directory where downloaded resources will be stored, defaulting to a hidden directory in the user's home folder. The ia_config_path parameter allows users to specify a configuration file for the internetarchive, which is necessary for uploading files to the archive. The output_template parameter allows customization of the naming convention for output files; if not provided, it defaults to a template that includes the video ID and file extension.\n\nUpon initialization, the function also sets up a logger for the class. If the verbose parameter is False, the logger's level is set to ERROR, meaning only error messages will be logged, thereby reducing the verbosity of the output. If the output_template is not specified, a default template is assigned to ensure that output filenames are generated in a consistent format.\n\n**Note**: It is important to ensure that the specified dir_path exists and is writable, as this is where the downloaded resources will be saved. Additionally, users should provide a valid ia_config_path if they intend to upload files to the internetarchive, as failure to do so may result in errors during the upload process."
      ],
      "code_start_line": 26,
      "code_end_line": 56,
      "params": [
        "self",
        "verbose",
        "dir_path",
        "ia_config_path",
        "output_template"
      ],
      "have_return": false,
      "code_content": "    def __init__(self,\n                 verbose=False,\n                 dir_path='~/.tubeup',\n                 ia_config_path=None,\n                 output_template=None):\n        \"\"\"\n        `tubeup` is a tool to archive YouTube by downloading the videos and\n        uploading it back to the archive.org.\n\n        :param verbose:         A boolean, True means all loggings will be\n                                printed out to stdout.\n        :param dir_path:        A path to directory that will be used for\n                                saving the downloaded resources. Default to\n                               '~/.tubeup'.\n        :param ia_config_path:  Path to an internetarchive config file, will\n                                be used in uploading the file.\n        :param output_template: A template string that will be used to\n                                generate the output filenames.\n        \"\"\"\n        self.dir_path = dir_path\n        self.verbose = verbose\n        self.ia_config_path = ia_config_path\n        self.logger = getLogger(__name__)\n        if output_template is None:\n            self.output_template = '%(id)s.%(ext)s'\n        else:\n            self.output_template = output_template\n\n        # Just print errors in quiet mode\n        if not self.verbose:\n            self.logger.setLevel(logging.ERROR)\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "dir_path",
      "md_content": [
        "**dir_path**: The function of dir_path is to return the value of the private attribute _dir_path.\n\n**parameters**: The parameters of this Function.\n· There are no parameters for this function.\n\n**Code Description**: The dir_path function is a simple accessor method that retrieves the value of the private attribute _dir_path from the instance of the class it belongs to. This function does not take any arguments and is called on an instance of the class. The purpose of this function is to provide a way to access the _dir_path attribute, which is likely intended to store a directory path relevant to the functionality of the class. By using this accessor method, the encapsulation principle is maintained, allowing controlled access to the internal state of the object.\n\n**Note**: It is important to ensure that the _dir_path attribute is properly initialized before calling this function to avoid returning an undefined or unexpected value.\n\n**Output Example**: If the _dir_path attribute is set to \"/user/home/documents\", calling the dir_path function would return the string \"/user/home/documents\"."
      ],
      "code_start_line": 59,
      "code_end_line": 60,
      "params": [
        "self"
      ],
      "have_return": true,
      "code_content": "    def dir_path(self):\n        return self._dir_path\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "dir_path",
      "md_content": [
        "**dir_path**: The function of dir_path is to set a directory for saving downloaded resources.\n\n**parameters**: The parameters of this Function.\n· dir_path: A string representing the path to the directory that will be used to save videos. If the directory does not exist, it will be created.\n\n**Code Description**: The dir_path function is responsible for configuring a specified directory as the location where downloaded resources, such as videos, will be stored. The function takes a single parameter, dir_path, which is expected to be a string indicating the desired directory path. \n\nUpon receiving the dir_path parameter, the function first expands any user directory shortcuts (like `~` for the home directory) using `os.path.expanduser()`. This ensures that the path is correctly interpreted regardless of the user's operating system.\n\nNext, the function attempts to create the necessary directories for storing the downloaded resources. It constructs a path by joining the expanded user directory path with a predefined constant, DOWNLOAD_DIR_NAME, which represents the subdirectory where downloads will be saved. The `os.makedirs()` function is then called with the `exist_ok=True` argument, which allows the function to create the directory if it does not already exist without raising an error if it does.\n\nFinally, the function assigns a dictionary to the instance variable `_dir_path`. This dictionary contains two keys: 'root', which holds the expanded user directory path, and 'downloads', which holds the full path to the downloads subdirectory. This structure allows for easy access to both the root directory and the specific downloads directory later in the code.\n\n**Note**: It is important to ensure that the provided dir_path is valid and accessible. If the path is incorrect or if there are permission issues, the directory creation may fail. Additionally, the DOWNLOAD_DIR_NAME constant should be defined elsewhere in the code for this function to work correctly."
      ],
      "code_start_line": 63,
      "code_end_line": 83,
      "params": [
        "self",
        "dir_path"
      ],
      "have_return": false,
      "code_content": "    def dir_path(self, dir_path):\n        \"\"\"\n        Set a directory to be the saving directory for resources that have\n        been downloaded.\n\n        :param dir_path:  Path to a directory that will be used to save the\n                          videos, if it not created yet, the directory\n                          will be created.\n        \"\"\"\n        extended_usr_dir_path = os.path.expanduser(dir_path)\n\n        # Create the directories.\n        os.makedirs(\n            os.path.join(extended_usr_dir_path, DOWNLOAD_DIR_NAME),\n            exist_ok=True)\n\n        self._dir_path = {\n            'root': extended_usr_dir_path,\n            'downloads': os.path.join(extended_usr_dir_path,\n                                      DOWNLOAD_DIR_NAME)\n        }\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "get_resource_basenames",
      "md_content": [
        "**get_resource_basenames**: The function of get_resource_basenames is to retrieve the basenames of resources from a list of URLs using the youtube-dl library.\n\n**parameters**: The parameters of this Function.\n· urls: A list of URLs that will be downloaded with youtube-dl.\n· cookie_file: A cookie file for YoutubeDL.\n· proxy_url: A proxy URL for YoutubeDL.\n· ydl_username: Username that will be used to download the resources with youtube_dl.\n· ydl_password: Password of the related username, will be used to download the resources with youtube_dl.\n· use_download_archive: Record the video URL to the download archive. This will download only videos not listed in the archive file and record the IDs of all downloaded videos in it.\n· ignore_existing_item: Ignores the check for existing items on archive.org.\n\n**Code Description**: The get_resource_basenames function is designed to extract and return a set of basenames for videos that are downloaded from the provided URLs. The function begins by initializing an empty set called downloaded_files_basename to store the basenames of the downloaded files.\n\nWithin the function, several nested functions are defined to handle specific tasks. The check_if_ia_item_exists function checks if an item already exists on archive.org by retrieving its item name and checking its existence. If the item exists, it logs a message and returns True; otherwise, it returns False.\n\nThe ydl_progress_each function processes each entry in the URL list. It checks if the entry is available and whether it is already recorded in the download archive. If the item does not exist on archive.org, it extracts information from the entry's webpage URL and updates the downloaded_files_basename set with the basenames created from the extracted information. If the item exists, it records the download in the archive.\n\nThe ydl_progress_hook function provides real-time feedback during the download process. It logs the progress, completion, and any errors encountered during the download.\n\nThe function then generates options for the youtube-dl library by calling generate_ydl_options, passing the necessary parameters including the progress hook. It uses these options to create a YoutubeDL instance and iterates through the provided URLs. For each URL, if ignore_existing_item is False, it extracts the information dictionary for the URL and processes it accordingly. If the URL is a playlist, it iterates through each entry; otherwise, it processes the single entry.\n\nThe downloaded basenames are logged for debugging purposes, and the function ultimately returns the set of downloaded file basenames.\n\nThis function is called by other methods within the TubeUp class, such as archive_urls, which utilizes the retrieved basenames to upload the downloaded videos to archive.org. Additionally, it is tested in the test_get_resource_basenames method, which verifies its functionality by comparing the actual output with the expected result.\n\n**Note**: It is important to ensure that the URLs provided are valid and accessible, as the function relies on the youtube-dl library to extract information and download the resources. Additionally, the parameters related to authentication and proxy settings should be correctly configured to avoid errors during the download process.\n\n**Output Example**: A possible appearance of the code's return value could be a set containing strings like:\n{'KdsN9YhkDrY'} or \n{'Sample Video Title [abc123]', 'Another Video Title [xyz456]', ...}"
      ],
      "code_start_line": 85,
      "code_end_line": 196,
      "params": [
        "self",
        "urls",
        "cookie_file",
        "proxy_url",
        "ydl_username",
        "ydl_password",
        "use_download_archive",
        "ignore_existing_item"
      ],
      "have_return": true,
      "code_content": "    def get_resource_basenames(self, urls,\n                               cookie_file=None, proxy_url=None,\n                               ydl_username=None, ydl_password=None,\n                               use_download_archive=False,\n                               ignore_existing_item=False):\n        \"\"\"\n        Get resource basenames from an url.\n\n        :param urls:                  A list of urls that will be downloaded with\n                                      youtubedl.\n        :param cookie_file:           A cookie file for YoutubeDL.\n        :param proxy_url:             A proxy url for YoutubeDL.\n        :param ydl_username:          Username that will be used to download the\n                                      resources with youtube_dl.\n        :param ydl_password:          Password of the related username, will be used\n                                      to download the resources with youtube_dl.\n        :param use_download_archive:  Record the video url to the download archive.\n                                      This will download only videos not listed in\n                                      the archive file. Record the IDs of all\n                                      downloaded videos in it.\n        :param ignore_existing_item:  Ignores the check for existing items on archive.org.\n        :return:                      Set of videos basename that has been downloaded.\n        \"\"\"\n        downloaded_files_basename = set()\n\n        def check_if_ia_item_exists(infodict):\n            itemname = get_itemname(infodict)\n            item = internetarchive.get_item(itemname)\n            if item.exists and self.verbose:\n                print(\"\\n:: Item already exists. Not downloading.\")\n                print('Title: %s' % infodict['title'])\n                print('Video URL: %s\\n' % infodict['webpage_url'])\n                return True\n            return False\n\n        def ydl_progress_each(entry):\n            if not entry:\n                self.logger.warning('Video \"%s\" is not available. Skipping.' % url)\n                return\n            if ydl.in_download_archive(entry):\n                return\n            if not check_if_ia_item_exists(entry):\n                ydl.extract_info(entry['webpage_url'])\n                downloaded_files_basename.update(self.create_basenames_from_ydl_info_dict(ydl, entry))\n            else:\n                ydl.record_download_archive(entry)\n\n        def ydl_progress_hook(d):\n            if d['status'] == 'downloading' and self.verbose:\n                if d.get('_total_bytes_str') is not None:\n                    msg_template = ('%(_percent_str)s of %(_total_bytes_str)s '\n                                    'at %(_speed_str)s ETA %(_eta_str)s')\n                elif d.get('_total_bytes_estimate_str') is not None:\n                    msg_template = ('%(_percent_str)s of '\n                                    '~%(_total_bytes_estimate_str)s at '\n                                    '%(_speed_str)s ETA %(_eta_str)s')\n                elif d.get('_downloaded_bytes_str') is not None:\n                    if d.get('_elapsed_str'):\n                        msg_template = ('%(_downloaded_bytes_str)s at '\n                                        '%(_speed_str)s (%(_elapsed_str)s)')\n                    else:\n                        msg_template = ('%(_downloaded_bytes_str)s '\n                                        'at %(_speed_str)s')\n                else:\n                    msg_template = ('%(_percent_str)s % at '\n                                    '%(_speed_str)s ETA %(_eta_str)s')\n\n                process_msg = '\\r[download] ' + (msg_template % d) + '\\033[K'\n                sys.stdout.write(process_msg)\n                sys.stdout.flush()\n\n            if d['status'] == 'finished':\n                msg = '\\nDownloaded %s' % d['filename']\n\n                self.logger.debug(d)\n                self.logger.info(msg)\n                if self.verbose:\n                    print(msg)\n\n            if d['status'] == 'error':\n                # TODO: Complete the error message\n                msg = 'Error when downloading the video'\n\n                self.logger.error(msg)\n                if self.verbose:\n                    print(msg)\n\n        ydl_opts = self.generate_ydl_options(ydl_progress_hook,\n                                             cookie_file, proxy_url,\n                                             ydl_username, ydl_password,\n                                             use_download_archive)\n\n        with YoutubeDL(ydl_opts) as ydl:\n            for url in urls:\n                if not ignore_existing_item:\n                    # Get the info dict of the url\n                    info_dict = ydl.extract_info(url, download=False)\n\n                    if info_dict.get('_type', 'video') == 'playlist':\n                        for entry in info_dict['entries']:\n                            ydl_progress_each(entry)\n                    else:\n                        ydl_progress_each(info_dict)\n                else:\n                    info_dict = ydl.extract_info(url)\n                    downloaded_files_basename.update(self.create_basenames_from_ydl_info_dict(ydl, info_dict))\n\n        self.logger.debug(\n            'Basenames obtained from url (%s): %s'\n            % (url, downloaded_files_basename))\n\n        return downloaded_files_basename\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_get_resource_basenames",
        "tubeup/TubeUp.py/TubeUp/archive_urls"
      ],
      "reference_who": [
        "tubeup/TubeUp.py/TubeUp/create_basenames_from_ydl_info_dict",
        "tubeup/TubeUp.py/TubeUp/generate_ydl_options"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "check_if_ia_item_exists",
      "md_content": [
        "**check_if_ia_item_exists**: The function of check_if_ia_item_exists is to determine whether an item already exists in the Internet Archive based on the provided information dictionary.\n\n**parameters**: The parameters of this Function.\n· parameter1: infodict - A dictionary containing information about the item, specifically the 'title' and 'webpage_url' keys, along with other metadata.\n\n**Code Description**: The check_if_ia_item_exists function takes a single parameter, infodict, which is expected to be a dictionary that includes metadata about an item. The function first calls the get_itemname function to generate a sanitized identifier for the item using the information contained in infodict. This identifier is then used to query the Internet Archive through the internetarchive.get_item method.\n\nIf the item exists in the Internet Archive and the verbose mode is enabled (indicated by self.verbose being True), the function prints a message indicating that the item already exists and provides the title and video URL from the infodict. In this case, the function returns True, indicating that the item is already present and does not need to be downloaded again. If the item does not exist, the function returns False, indicating that the item can be processed further.\n\nThis function is called within the ydl_progress_each function, which is responsible for managing the download process of video entries. In ydl_progress_each, check_if_ia_item_exists is used to check if the item has already been downloaded before proceeding to extract information from the entry's webpage URL. If the item does not exist, the function continues with the download process; otherwise, it records the download in the archive.\n\n**Note**: It is important to ensure that the infodict passed to check_if_ia_item_exists contains the necessary keys ('title' and 'webpage_url') to avoid potential KeyError exceptions. Proper handling of these keys is crucial for the function to operate correctly.\n\n**Output Example**: For an input dictionary like {'title': 'Sample Video', 'webpage_url': 'http://example.com/sample-video'}, if the item exists in the Internet Archive, the function would print the message indicating the item's existence and return True."
      ],
      "code_start_line": 110,
      "code_end_line": 118,
      "params": [
        "infodict"
      ],
      "have_return": true,
      "code_content": "        def check_if_ia_item_exists(infodict):\n            itemname = get_itemname(infodict)\n            item = internetarchive.get_item(itemname)\n            if item.exists and self.verbose:\n                print(\"\\n:: Item already exists. Not downloading.\")\n                print('Title: %s' % infodict['title'])\n                print('Video URL: %s\\n' % infodict['webpage_url'])\n                return True\n            return False\n",
      "name_column": 12,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tubeup/TubeUp.py/TubeUp/get_resource_basenames/ydl_progress_each"
      ],
      "reference_who": [
        "tubeup/utils.py/get_itemname"
      ],
      "special_reference_type": [
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "ydl_progress_each",
      "md_content": [
        "**ydl_progress_each**: The function of ydl_progress_each is to manage the download process of video entries by checking their availability and recording their download status.\n\n**parameters**: The parameters of this Function.\n· entry: A dictionary containing information about the video entry, which includes keys such as 'webpage_url' and other metadata.\n\n**Code Description**: The ydl_progress_each function is responsible for handling the progress of video downloads. It first checks if the provided entry is valid. If the entry is None or empty, it logs a warning message indicating that the video is not available and skips further processing. \n\nNext, the function checks if the entry is already present in the download archive by calling the ydl.in_download_archive method. If the entry is found in the archive, the function terminates early, as there is no need to download it again.\n\nIf the entry is not in the download archive, the function proceeds to verify whether the item exists in the Internet Archive by invoking the check_if_ia_item_exists function. This function takes the entry as an argument and checks for the existence of the item based on its metadata. If the item does not exist, ydl_progress_each calls ydl.extract_info with the entry's 'webpage_url' to extract the necessary information about the video. Following this, it updates the set of downloaded file basenames by calling the create_basenames_from_ydl_info_dict function, passing the ydl instance and the entry. This function generates a set of unique basenames from the extracted information.\n\nIf the item is found to exist in the Internet Archive, ydl_progress_each records the download in the archive by calling ydl.record_download_archive with the entry as an argument. This ensures that the download status is tracked for future reference.\n\nOverall, ydl_progress_each coordinates the process of checking for existing downloads, extracting video information, and updating the download archive, ensuring that duplicate downloads are avoided and that the status of each entry is properly recorded.\n\n**Note**: It is crucial that the entry passed to ydl_progress_each contains the necessary keys, particularly 'webpage_url', to avoid potential errors during the execution of the function. Proper validation of the entry is essential for the function to operate correctly.\n\n**Output Example**: The function does not return a value but may log messages indicating the status of the video download process, such as warnings for unavailable videos or confirmations of recorded downloads."
      ],
      "code_start_line": 120,
      "code_end_line": 130,
      "params": [
        "entry"
      ],
      "have_return": true,
      "code_content": "        def ydl_progress_each(entry):\n            if not entry:\n                self.logger.warning('Video \"%s\" is not available. Skipping.' % url)\n                return\n            if ydl.in_download_archive(entry):\n                return\n            if not check_if_ia_item_exists(entry):\n                ydl.extract_info(entry['webpage_url'])\n                downloaded_files_basename.update(self.create_basenames_from_ydl_info_dict(ydl, entry))\n            else:\n                ydl.record_download_archive(entry)\n",
      "name_column": 12,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [
        "tubeup/TubeUp.py/TubeUp/get_resource_basenames/check_if_ia_item_exists",
        "tubeup/TubeUp.py/TubeUp/create_basenames_from_ydl_info_dict"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "ydl_progress_hook",
      "md_content": [
        "**ydl_progress_hook**: The function of ydl_progress_hook is to handle and display the progress of a download operation, providing real-time feedback based on the status of the download.\n\n**parameters**: The parameters of this Function.\n· d: A dictionary containing the current status and relevant data about the download process.\n\n**Code Description**: The ydl_progress_hook function is designed to monitor the progress of a download and provide updates to the user. It takes a single parameter, d, which is expected to be a dictionary containing various keys that indicate the current status of the download and other relevant information.\n\nThe function first checks if the status of the download is 'downloading' and if the verbose mode is enabled. If both conditions are met, it constructs a message template based on the available data in the dictionary. The message template varies depending on which keys are present in the dictionary:\n\n- If '_total_bytes_str' is available, it indicates the total size of the download, and the message will include the percentage downloaded, total size, speed, and estimated time of arrival (ETA).\n- If '_total_bytes_estimate_str' is available instead, it suggests that the total size is estimated, and the message will reflect that.\n- If '_downloaded_bytes_str' is present, it will show the amount downloaded along with the speed and elapsed time if available.\n- If none of these specific keys are present, a generic message will be constructed that includes the percentage, speed, and ETA.\n\nThe constructed message is then printed to the standard output, providing real-time feedback to the user about the download progress.\n\nIf the status indicates that the download is 'finished', the function logs a message indicating the successful download of the specified filename. It also logs the detailed information contained in the dictionary for debugging purposes. If verbose mode is enabled, it prints a confirmation message to the user.\n\nIn the case of an 'error' status, the function prepares an error message indicating that there was an issue during the download. This message is logged as an error, and if verbose mode is enabled, it is also printed to the user.\n\n**Note**: It is important to ensure that the dictionary passed to this function contains the expected keys to avoid any KeyError exceptions. The function relies on the presence of specific keys to construct the output messages accurately. Additionally, the verbose mode should be managed appropriately to control the amount of output displayed to the user."
      ],
      "code_start_line": 132,
      "code_end_line": 170,
      "params": [
        "d"
      ],
      "have_return": false,
      "code_content": "        def ydl_progress_hook(d):\n            if d['status'] == 'downloading' and self.verbose:\n                if d.get('_total_bytes_str') is not None:\n                    msg_template = ('%(_percent_str)s of %(_total_bytes_str)s '\n                                    'at %(_speed_str)s ETA %(_eta_str)s')\n                elif d.get('_total_bytes_estimate_str') is not None:\n                    msg_template = ('%(_percent_str)s of '\n                                    '~%(_total_bytes_estimate_str)s at '\n                                    '%(_speed_str)s ETA %(_eta_str)s')\n                elif d.get('_downloaded_bytes_str') is not None:\n                    if d.get('_elapsed_str'):\n                        msg_template = ('%(_downloaded_bytes_str)s at '\n                                        '%(_speed_str)s (%(_elapsed_str)s)')\n                    else:\n                        msg_template = ('%(_downloaded_bytes_str)s '\n                                        'at %(_speed_str)s')\n                else:\n                    msg_template = ('%(_percent_str)s % at '\n                                    '%(_speed_str)s ETA %(_eta_str)s')\n\n                process_msg = '\\r[download] ' + (msg_template % d) + '\\033[K'\n                sys.stdout.write(process_msg)\n                sys.stdout.flush()\n\n            if d['status'] == 'finished':\n                msg = '\\nDownloaded %s' % d['filename']\n\n                self.logger.debug(d)\n                self.logger.info(msg)\n                if self.verbose:\n                    print(msg)\n\n            if d['status'] == 'error':\n                # TODO: Complete the error message\n                msg = 'Error when downloading the video'\n\n                self.logger.error(msg)\n                if self.verbose:\n                    print(msg)\n",
      "name_column": 12,
      "item_status": "doc_up_to_date",
      "who_reference_me": [],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "create_basenames_from_ydl_info_dict",
      "md_content": [
        "**create_basenames_from_ydl_info_dict**: The function of create_basenames_from_ydl_info_dict is to create basenames from a given YoutubeDL info dictionary.\n\n**parameters**: The parameters of this Function.\n· ydl: A `youtube_dl.YoutubeDL` instance used to prepare filenames.\n· info_dict: A dictionary containing information about the media, which is utilized to generate the basenames.\n\n**Code Description**: The create_basenames_from_ydl_info_dict function is designed to extract and create a set of basenames from the information provided in the info_dict parameter, which is typically obtained from the YoutubeDL library. The function begins by determining the type of media from the info_dict, defaulting to 'video' if the type is not specified. It logs the type of media being processed for debugging purposes.\n\nIf the media type is identified as a 'playlist', the function iterates through each entry in the playlist, preparing the filename for each video using the YoutubeDL instance. If the media type is a single video, it directly prepares the filename from the info_dict. The prepared filenames are stored in a set to ensure uniqueness.\n\nSubsequently, the function processes each filename to remove the file extension and any specific formatting (like quality indicators) using regular expressions. The cleaned basenames are then collected into another set, which is returned as the output of the function.\n\nThis function is called within the context of other functions, such as get_resource_basenames and ydl_progress_each. In get_resource_basenames, it is invoked to update the set of downloaded file basenames after extracting information from each URL. In ydl_progress_each, it is used to create basenames for individual entries in a playlist, ensuring that the correct filenames are generated for each video being processed.\n\n**Note**: It is important to ensure that the info_dict passed to this function is correctly formatted and contains the necessary keys, as the function relies on these to generate the basenames accurately.\n\n**Output Example**: A possible appearance of the code's return value could be a set containing strings like:\n{'Video and Blog Competition 2017 - Bank Indonesia & NET TV #BIGoesToCampus [hlG3LeFaQwU]'} or \n{'Live Streaming Rafid Aslam [7gjgkH5iPaE]', 'Cara Membuat Laptop Menjadi Hotspot WiFi Dengan CMD [YjFwMSDNphM]', ...}"
      ],
      "code_start_line": 198,
      "code_end_line": 228,
      "params": [
        "self",
        "ydl",
        "info_dict"
      ],
      "have_return": true,
      "code_content": "    def create_basenames_from_ydl_info_dict(self, ydl, info_dict):\n        \"\"\"\n        Create basenames from YoutubeDL info_dict.\n\n        :param ydl:        A `youtube_dl.YoutubeDL` instance.\n        :param info_dict:  A ydl info_dict that will be used to create\n                           the basenames.\n        :return:           A set that contains basenames that created from\n                           the `info_dict`.\n        \"\"\"\n        info_type = info_dict.get('_type', 'video')\n        self.logger.debug('Creating basenames from ydl info dict with type %s'\n                          % info_type)\n\n        filenames = set()\n\n        if info_type == 'playlist':\n            # Iterate and get the filenames through the playlist\n            for video in info_dict['entries']:\n                filenames.add(ydl.prepare_filename(video))\n        else:\n            filenames.add(ydl.prepare_filename(info_dict))\n\n        basenames = set()\n\n        for filename in filenames:\n            filename_without_ext = os.path.splitext(filename)[0]\n            file_basename = re.sub(r'(\\.f\\d+)', '', filename_without_ext)\n            basenames.add(file_basename)\n\n        return basenames\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_create_basenames_from_ydl_info_dict_video",
        "tests/test_tubeup.py/TubeUpTests/test_create_basenames_from_ydl_info_dict_playlist",
        "tubeup/TubeUp.py/TubeUp/get_resource_basenames/ydl_progress_each",
        "tubeup/TubeUp.py/TubeUp/get_resource_basenames"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "generate_ydl_options",
      "md_content": [
        "**generate_ydl_options**: The function of generate_ydl_options is to generate a dictionary that contains options that will be used by yt-dlp.\n\n**parameters**: The parameters of this Function.\n· ydl_progress_hook: A function that will be called during the download process by youtube_dl.\n· cookie_file: An optional parameter that specifies a cookie file for YoutubeDL.\n· proxy_url: An optional parameter that specifies a proxy URL for YoutubeDL.\n· ydl_username: An optional parameter that specifies the username that will be used to download the resources with youtube_dl.\n· ydl_password: An optional parameter that specifies the password of the related username, which will be used to download the resources with youtube_dl.\n· use_download_archive: An optional boolean parameter that indicates whether to record the video URL to the download archive. If set to True, this will download only videos not listed in the archive file and record the IDs of all downloaded videos in it.\n· ydl_output_template: An optional parameter that specifies the output template for the downloaded files.\n\n**Code Description**: The generate_ydl_options function constructs a dictionary named ydl_opts that contains various configuration options for the yt-dlp library, which is a fork of youtube-dl. The function begins by setting default values for several options, such as output template, verbosity, and error handling. It then conditionally adds options based on the parameters provided by the user. For instance, if a cookie file is specified, it adds the 'cookiefile' option; if a proxy URL is provided, it adds the 'proxy' option. Similarly, it includes the username and password if they are supplied. If the use_download_archive parameter is set to True, it specifies the path for the download archive.\n\nThis function is called by various test methods within the TubeUpTests class, which are designed to validate the behavior of the generate_ydl_options function under different scenarios. For example, the test_generate_ydl_options_with_download_archive method checks if the function correctly includes the download archive option when use_download_archive is set to True. Other tests verify the inclusion of proxy settings, user credentials, and the effect of the verbose mode on the output options. Each of these tests compares the actual output of the function with the expected output, ensuring that the function behaves as intended.\n\n**Note**: It is important to ensure that the parameters passed to the function are valid and correctly formatted, as incorrect values may lead to unexpected behavior during the download process.\n\n**Output Example**: A possible appearance of the code's return value when calling the function with a mocked progress hook and enabling the download archive might look like this:\n```python\n{\n    'outtmpl': '/path/to/downloads/%(id)s.%(ext)s',\n    'restrictfilenames': True,\n    'quiet': True,\n    'verbose': False,\n    'progress_with_newline': True,\n    'forcetitle': True,\n    'continuedl': True,\n    'retries': 9001,\n    'fragment_retries': 9001,\n    'forcejson': False,\n    'writeinfojson': True,\n    'writedescription': True,\n    'writethumbnail': True,\n    'writeannotations': True,\n    'writesubtitles': True,\n    'allsubtitles': True,\n    'ignoreerrors': True,\n    'fixup': 'warn',\n    'nooverwrites': True,\n    'consoletitle': True,\n    'prefer_ffmpeg': True,\n    'call_home': False,\n    'logger': <logger_instance>,\n    'progress_hooks': [<mocked_progress_hook>],\n    'download_archive': '/path/to/root/.ytdlarchive'\n}\n```"
      ],
      "code_start_line": 230,
      "code_end_line": 310,
      "params": [
        "self",
        "ydl_progress_hook",
        "cookie_file",
        "proxy_url",
        "ydl_username",
        "ydl_password",
        "use_download_archive",
        "ydl_output_template"
      ],
      "have_return": true,
      "code_content": "    def generate_ydl_options(self,\n                             ydl_progress_hook,\n                             cookie_file=None,\n                             proxy_url=None,\n                             ydl_username=None,\n                             ydl_password=None,\n                             use_download_archive=False,\n                             ydl_output_template=None):\n        \"\"\"\n        Generate a dictionary that contains options that will be used\n        by yt-dlp.\n\n        :param ydl_progress_hook:     A function that will be called during the\n                                      download process by youtube_dl.\n        :param proxy_url:             A proxy url for YoutubeDL.\n        :param ydl_username:          Username that will be used to download the\n                                      resources with youtube_dl.\n        :param ydl_password:          Password of the related username, will be\n                                      used to download the resources with\n                                      youtube_dl.\n        :param use_download_archive:  Record the video url to the download archive.\n                                      This will download only videos not listed in\n                                      the archive file. Record the IDs of all\n                                      downloaded videos in it.\n        :return:                      A dictionary that contains options that will\n                                      be used by youtube_dl.\n        \"\"\"\n        ydl_opts = {\n            'outtmpl': os.path.join(self.dir_path['downloads'],\n                                    self.output_template),\n            'restrictfilenames': True,\n            'quiet': not self.verbose,\n            'verbose': self.verbose,\n            'progress_with_newline': True,\n            'forcetitle': True,\n            'continuedl': True,\n            'retries': 9001,\n            'fragment_retries': 9001,\n            'forcejson': False,\n            'writeinfojson': True,\n            'writedescription': True,\n            'writethumbnail': True,\n            'writeannotations': True,\n            'writesubtitles': True,\n            'allsubtitles': True,\n            'ignoreerrors': True,  # Geo-blocked,\n                                   # copyrighted/private/deleted\n                                   # will be printed to STDOUT and channel\n                                   # ripping will  continue uninterupted,\n                                   # use with verbose off\n            'fixup': 'warn',  # Slightly more verbosity for debugging\n                              # problems\n            'nooverwrites': True,  # Don't touch what's already been\n                                   # downloaded speeds things\n            'consoletitle': True,   # Download percentage in console title\n            'prefer_ffmpeg': True,  # `ffmpeg` is better than `avconv`,\n                                    # let's prefer it's use\n            # Warns on out of date youtube-dl script, helps debugging for\n            # youtube-dl devs\n            'call_home': False,\n            'logger': self.logger,\n            'progress_hooks': [ydl_progress_hook]\n        }\n\n        if cookie_file is not None:\n            ydl_opts['cookiefile'] = cookie_file\n\n        if proxy_url is not None:\n            ydl_opts['proxy'] = proxy_url\n\n        if ydl_username is not None:\n            ydl_opts['username'] = ydl_username\n\n        if ydl_password is not None:\n            ydl_opts['password'] = ydl_password\n\n        if use_download_archive:\n            ydl_opts['download_archive'] = os.path.join(self.dir_path['root'],\n                                                        '.ytdlarchive')\n\n        return ydl_opts\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options_with_download_archive",
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options",
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options_with_proxy",
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options_with_ydl_account",
        "tests/test_tubeup.py/TubeUpTests/test_generate_ydl_options_with_verbose_mode",
        "tubeup/TubeUp.py/TubeUp/get_resource_basenames"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "upload_ia",
      "md_content": [
        "**upload_ia**: The function of upload_ia is to upload a video to archive.org along with its associated metadata.\n\n**parameters**: The parameters of this Function.\n· parameter1: videobasename - A video base name that represents the file to be uploaded.\n· parameter2: custom_meta - A custom metadata dictionary that will be used by the internetarchive library when uploading to archive.org.\n\n**Code Description**: The upload_ia function is responsible for uploading a video file and its associated metadata to archive.org. It begins by constructing the path to the metadata JSON file corresponding to the video base name provided. The function reads this JSON file to extract video metadata, which is essential for the upload process.\n\nBefore proceeding with the upload, the function checks for the presence of incomplete video download files (e.g., files with extensions such as .part or .temp). If any such files are found, the function raises an exception, preventing the upload of incomplete content.\n\nThe function then generates an item name by calling the get_itemname function, which constructs a sanitized identifier based on the video metadata. Following this, it creates a structured metadata dictionary suitable for archive.org by invoking the create_archive_org_metadata_from_youtubedl_meta function, passing the extracted video metadata.\n\nThe function also handles the deletion of empty files that should not be uploaded, such as empty description and annotations files. It checks the existence and content of these files using the check_is_file_empty function, removing them if they are found to be empty.\n\nNext, the function prepares to upload the video files by gathering all files that match the video base name. It retrieves the necessary S3 access keys from the internetarchive configuration file to authenticate the upload process.\n\nFinally, the function uploads the files to archive.org using the internetarchive library's upload method, passing the gathered files and metadata. Upon successful upload, it returns a tuple containing the item name and the metadata used during the upload process.\n\nThe upload_ia function is called by the archive_urls method, which is designed to download and upload videos from a list of URLs. This highlights the function's role in the broader context of managing video uploads to archive.org, ensuring that the content is properly identified and categorized.\n\n**Note**: It is crucial to ensure that the video base name provided corresponds to a complete and valid video file, and that the metadata JSON file exists and is correctly formatted. Additionally, the custom_meta parameter should be a valid dictionary if provided, as it will be merged with the generated metadata.\n\n**Output Example**: A possible return value from the function could look like this:\n```python\n('youtube-6iRV8liah8A', {'mediatype': 'movies', 'creator': 'Video Background', 'collection': 'opensource_movies', 'title': 'Mountain 3 - Video Background HD 1080p', 'description': 'Mountain 3 - Video Background HD 1080p<br>If you use this video please put credits to my channel in description:<br>https://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© Don\\'t forget to SUBSCRIBE, LIKE, COMMENT and RATE. Hope you all enjoy!', 'date': '2015-01-05', 'year': '2015', 'subject': 'Youtube;video;Entertainment;Video Background;Footage;Animation;Cinema;stock video footage;Royalty free videos;Creative Commons videos;free movies online;youtube;HD;1080p;Amazing Nature;Mountain;', 'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A', 'licenseurl': 'https://creativecommons.org/licenses/by/3.0/', 'scanner': 'TubeUp Video Stream Mirroring Application 1.0'})\n```"
      ],
      "code_start_line": 312,
      "code_end_line": 382,
      "params": [
        "self",
        "videobasename",
        "custom_meta"
      ],
      "have_return": true,
      "code_content": "    def upload_ia(self, videobasename, custom_meta=None):\n        \"\"\"\n        Upload video to archive.org.\n\n        :param videobasename:  A video base name.\n        :param custom_meta:    A custom meta, will be used by internetarchive\n                               library when uploading to archive.org.\n        :return:               A tuple containing item name and metadata used\n                               when uploading to archive.org and whether the item\n                               already exists.\n        \"\"\"\n        json_metadata_filepath = videobasename + '.info.json'\n        with open(json_metadata_filepath, 'r', encoding='utf-8') as f:\n            vid_meta = json.load(f)\n\n        # Exit if video download did not complete, don't upload .part files to IA\n        for ext in ['*.part', '*.f303.*', '*.f302.*', '*.ytdl', '*.f251.*', '*.248.*', '*.f247.*', '*.temp']:\n            if glob.glob(videobasename + ext):\n                msg = 'Video download incomplete, please re-run or delete video stubs in downloads folder, exiting...'\n                raise Exception(msg)\n\n        itemname = get_itemname(vid_meta)\n        metadata = self.create_archive_org_metadata_from_youtubedl_meta(\n            vid_meta)\n\n        # Delete empty description file\n        description_file_path = videobasename + '.description'\n        if (os.path.exists(description_file_path) and\n            (('description' in vid_meta and\n             vid_meta['description'] == '') or\n                check_is_file_empty(description_file_path))):\n            os.remove(description_file_path)\n\n        # Delete empty annotations.xml file so it isn't uploaded\n        annotations_file_path = videobasename + '.annotations.xml'\n        if (os.path.exists(annotations_file_path) and\n            (('annotations' in vid_meta and\n             vid_meta['annotations'] in {'', EMPTY_ANNOTATION_FILE}) or\n                check_is_file_empty(annotations_file_path))):\n            os.remove(annotations_file_path)\n\n        # Upload all files with videobase name: e.g. video.mp4,\n        # video.info.json, video.srt, etc.\n        files_to_upload = glob.glob(videobasename + '*')\n\n        # Upload the item to the Internet Archive\n        item = internetarchive.get_item(itemname)\n\n        if custom_meta:\n            metadata.update(custom_meta)\n\n        # Parse internetarchive configuration file.\n        parsed_ia_s3_config = parse_config_file(self.ia_config_path)[2]['s3']\n        s3_access_key = parsed_ia_s3_config['access']\n        s3_secret_key = parsed_ia_s3_config['secret']\n\n        if None in {s3_access_key, s3_secret_key}:\n            msg = ('`internetarchive` configuration file is not configured'\n                   ' properly.')\n\n            self.logger.error(msg)\n            if self.verbose:\n                print(msg)\n            raise Exception(msg)\n\n        item.upload(files_to_upload, metadata=metadata, retries=9001,\n                    request_kwargs=dict(timeout=(9001, 9001)), delete=True,\n                    verbose=self.verbose, access_key=s3_access_key,\n                    secret_key=s3_secret_key)\n\n        return itemname, metadata\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_upload_ia",
        "tubeup/TubeUp.py/TubeUp/archive_urls"
      ],
      "reference_who": [
        "tubeup/utils.py/get_itemname",
        "tubeup/utils.py/check_is_file_empty",
        "tubeup/TubeUp.py/TubeUp/create_archive_org_metadata_from_youtubedl_meta"
      ],
      "special_reference_type": [
        false,
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "archive_urls",
      "md_content": [
        "**archive_urls**: The function of archive_urls is to download and upload videos from youtube_dl supported sites to archive.org.\n\n**parameters**: The parameters of this Function.\n· urls: A list of URLs that will be downloaded and uploaded to archive.org.\n· custom_meta: A custom metadata that will be used when uploading the file with archive.org.\n· cookie_file: A cookie file for YoutubeDL.\n· proxy: A proxy URL for YoutubeDL.\n· ydl_username: Username that will be used to download the resources with youtube_dl.\n· ydl_password: Password of the related username, will be used to download the resources with youtube_dl.\n· use_download_archive: Record the video URL to the download archive. This will download only videos not listed in the archive file and record the IDs of all downloaded videos in it.\n· ignore_existing_item: Ignores the check for existing items on archive.org.\n\n**Code Description**: The archive_urls function is designed to facilitate the process of downloading videos from a list of URLs and subsequently uploading them to archive.org. The function begins by calling the get_resource_basenames method, which retrieves the basenames of the resources that need to be downloaded. This method takes several parameters, including the list of URLs, cookie file, proxy settings, and user credentials for youtube_dl. The retrieved basenames represent the files that have been successfully downloaded.\n\nOnce the basenames are obtained, the function iterates over each basename. For each video file, it calls the upload_ia method, which is responsible for uploading the video file along with its associated metadata to archive.org. The upload_ia method also accepts a custom_meta parameter, allowing the user to provide additional metadata during the upload process.\n\nThe archive_urls function yields a tuple for each uploaded video, containing the identifier and metadata of the file that has been uploaded to archive.org. This allows for efficient handling of multiple uploads, as the function can be used in a loop or as part of a larger process.\n\nThis function is called by the main method in the __main__.py file, where it processes command-line arguments to gather the necessary parameters for execution. It is also tested in the test_archive_urls method within the test_tubeup.py file, which verifies its functionality by mocking requests and checking the expected results against the actual output.\n\n**Note**: It is essential to ensure that the URLs provided are valid and accessible, as the function relies on the youtube_dl library to extract information and download the resources. Additionally, proper configuration of parameters related to authentication and proxy settings is necessary to avoid errors during the download and upload processes.\n\n**Output Example**: A possible appearance of the code's return value could be a list of tuples like:\n[('youtube-KdsN9YhkDrY', {'mediatype': 'movies', 'creator': 'RelaxingWorld', 'title': 'Epic Ramadan - Video Background HD1080p', ...})]"
      ],
      "code_start_line": 384,
      "code_end_line": 416,
      "params": [
        "self",
        "urls",
        "custom_meta",
        "cookie_file",
        "proxy",
        "ydl_username",
        "ydl_password",
        "use_download_archive",
        "ignore_existing_item"
      ],
      "have_return": true,
      "code_content": "    def archive_urls(self, urls, custom_meta=None,\n                     cookie_file=None, proxy=None,\n                     ydl_username=None, ydl_password=None,\n                     use_download_archive=False,\n                     ignore_existing_item=False):\n        \"\"\"\n        Download and upload videos from youtube_dl supported sites to\n        archive.org\n\n        :param urls:                  List of url that will be downloaded and uploaded\n                                      to archive.org\n        :param custom_meta:           A custom metadata that will be used when\n                                      uploading the file with archive.org.\n        :param cookie_file:           A cookie file for YoutubeDL.\n        :param proxy_url:             A proxy url for YoutubeDL.\n        :param ydl_username:          Username that will be used to download the\n                                      resources with youtube_dl.\n        :param ydl_password:          Password of the related username, will be used\n                                      to download the resources with youtube_dl.\n        :param use_download_archive:  Record the video url to the download archive.\n                                      This will download only videos not listed in\n                                      the archive file. Record the IDs of all\n                                      downloaded videos in it.\n        :param ignore_existing_item:  Ignores the check for existing items on archive.org.\n        :return:                      Tuple containing identifier and metadata of the\n                                      file that has been uploaded to archive.org.\n        \"\"\"\n        downloaded_file_basenames = self.get_resource_basenames(\n            urls, cookie_file, proxy, ydl_username, ydl_password, use_download_archive,\n            ignore_existing_item)\n        for basename in downloaded_file_basenames:\n            identifier, meta = self.upload_ia(basename, custom_meta)\n            yield identifier, meta\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_archive_urls",
        "tubeup/__main__.py/main"
      ],
      "reference_who": [
        "tubeup/TubeUp.py/TubeUp/get_resource_basenames",
        "tubeup/TubeUp.py/TubeUp/upload_ia"
      ],
      "special_reference_type": [
        false,
        false
      ]
    },
    {
      "type": "FunctionDef",
      "name": "determine_collection_type",
      "md_content": [
        "**determine_collection_type**: The function of determine_collection_type is to determine the type of collection based on the provided URL.\n\n**parameters**: The parameters of this Function.\n· url: A string representing the URL for which the collection type will be determined.\n\n**Code Description**: The determine_collection_type function analyzes the provided URL to ascertain its collection type. It utilizes the urlparse function to extract the network location (netloc) from the URL. If the netloc matches 'soundcloud.com', the function returns the string 'opensource_audio', indicating that the collection type is audio-related. For any other URL, the function defaults to returning 'opensource_movies', suggesting that the collection type is video-related. \n\nThis function is called within the create_archive_org_metadata_from_youtubedl_meta function, where it is used to determine the appropriate collection type for a video based on its URL. The result of determine_collection_type is then utilized to set the 'mediatype' field in the metadata dictionary, which is crucial for categorizing the content when uploading to archive.org. Additionally, the function is tested in the test_determine_collection_type unit test, ensuring that it correctly identifies collection types for both SoundCloud and YouTube URLs.\n\n**Note**: It is important to ensure that the URL passed to this function is valid and properly formatted, as the function relies on the urlparse method to extract the netloc. Invalid URLs may lead to unexpected behavior.\n\n**Output Example**: \n- For the input URL 'https://soundcloud.com/testurl', the function will return 'opensource_audio'.\n- For the input URL 'https://www.youtube.com/watch?v=testVideo', the function will return 'opensource_movies'."
      ],
      "code_start_line": 419,
      "code_end_line": 428,
      "params": [
        "url"
      ],
      "have_return": true,
      "code_content": "    def determine_collection_type(url):\n        \"\"\"\n        Determine collection type for an url.\n\n        :param url:  URL that the collection type will be determined.\n        :return:     String, name of a collection.\n        \"\"\"\n        if urlparse(url).netloc == 'soundcloud.com':\n            return 'opensource_audio'\n        return 'opensource_movies'\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_determine_collection_type",
        "tubeup/TubeUp.py/TubeUp/create_archive_org_metadata_from_youtubedl_meta"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "determine_licenseurl",
      "md_content": [
        "**determine_licenseurl**: The function of determine_licenseurl is to retrieve the appropriate license URL based on the provided video metadata.\n\n**parameters**: The parameters of this Function.\n· vid_meta: A dictionary containing metadata about the video, which may include a 'license' key indicating the type of license associated with the video.\n\n**Code Description**: The determine_licenseurl function is designed to extract the license URL from a given video metadata dictionary. It initializes an empty string for the license URL and defines a dictionary of known licenses, mapping license names to their corresponding URLs. The function checks if the 'license' key exists in the vid_meta dictionary and if it has a value. If so, it retrieves the corresponding URL from the licenses dictionary using the license name as the key. If the license is not found, the function returns an empty string. \n\nThis function is called within the create_archive_org_metadata_from_youtubedl_meta function, which is responsible for creating metadata for uploads to archive.org based on YouTube-dl generated metadata. The license URL obtained from determine_licenseurl is included in the metadata dictionary returned by create_archive_org_metadata_from_youtubedl_meta. This integration ensures that the uploaded content is properly attributed with the correct licensing information, which is crucial for compliance with copyright and licensing regulations.\n\n**Note**: It is important to ensure that the vid_meta dictionary contains a valid 'license' key with an appropriate value for the function to return a meaningful license URL. If the license is not recognized, the function will return an empty string, which may affect the completeness of the metadata.\n\n**Output Example**: If the input vid_meta contains the following:\n```python\nvid_meta = {\n    'license': 'Creative Commons Attribution license (reuse allowed)'\n}\n```\nThe function would return:\n```\n'https://creativecommons.org/licenses/by/3.0/'\n```"
      ],
      "code_start_line": 431,
      "code_end_line": 452,
      "params": [
        "vid_meta"
      ],
      "have_return": true,
      "code_content": "    def determine_licenseurl(vid_meta):\n        \"\"\"\n        Determine licenseurl for an url\n\n        :param vid_meta:\n        :return:\n        \"\"\"\n        licenseurl = ''\n        licenses = {\n            \"Creative Commons Attribution license (reuse allowed)\": \"https://creativecommons.org/licenses/by/3.0/\",\n            \"Attribution-NonCommercial-ShareAlike\": \"https://creativecommons.org/licenses/by-nc-sa/2.0/\",\n            \"Attribution-NonCommercial\": \"https://creativecommons.org/licenses/by-nc/2.0/\",\n            \"Attribution-NonCommercial-NoDerivs\": \"https://creativecommons.org/licenses/by-nc-nd/2.0/\",\n            \"Attribution\": \"https://creativecommons.org/licenses/by/2.0/\",\n            \"Attribution-ShareAlike\": \"https://creativecommons.org/licenses/by-sa/2.0/\",\n            \"Attribution-NoDerivs\": \"https://creativecommons.org/licenses/by-nd/2.0/\"\n        }\n\n        if 'license' in vid_meta and vid_meta['license']:\n            licenseurl = licenses.get(vid_meta['license'])\n\n        return licenseurl\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tubeup/TubeUp.py/TubeUp/create_archive_org_metadata_from_youtubedl_meta"
      ],
      "reference_who": [],
      "special_reference_type": []
    },
    {
      "type": "FunctionDef",
      "name": "create_archive_org_metadata_from_youtubedl_meta",
      "md_content": [
        "**create_archive_org_metadata_from_youtubedl_meta**: The function of create_archive_org_metadata_from_youtubedl_meta is to generate a metadata dictionary suitable for uploading video content to archive.org based on YouTube-dl generated metadata.\n\n**parameters**: The parameters of this Function.\n· vid_meta: A dict containing YouTube-dl generated metadata about the video.\n\n**Code Description**: The create_archive_org_metadata_from_youtubedl_meta function processes the metadata dictionary provided by YouTube-dl (vid_meta) to create a structured metadata dictionary that can be used with the internetarchive library for uploading content to archive.org. \n\nThe function begins by extracting the title and webpage URL from the vid_meta dictionary. It then determines the collection type (either 'opensource_audio' or 'opensource_movies') by calling the TubeUp.determine_collection_type function, which analyzes the URL to ascertain its type.\n\nNext, the function attempts to identify the uploader of the video. It checks for various keys in the vid_meta dictionary, such as 'creator', 'uploader', and 'uploader_url', to find the appropriate uploader name. If none of these keys provide a valid uploader, it defaults to using 'tubeup.py'.\n\nThe upload date is also extracted from vid_meta. If the 'upload_date' key is present and valid, it is converted to an ISO format. If not, the function defaults to the current date. \n\nThe function constructs a tags string that includes the extractor key and any available categories or tags from vid_meta. It ensures that the resulting string does not exceed 255 bytes, as required by archive.org's subject field.\n\nThe license URL is determined by calling the TubeUp.determine_licenseurl function, which retrieves the appropriate license URL based on the metadata provided. \n\nThe description of the video is processed to replace raw newlines with HTML line breaks, ensuring compatibility with archive.org's display requirements.\n\nFinally, the function compiles all the gathered information into a metadata dictionary, which includes fields such as 'mediatype', 'creator', 'collection', 'title', 'description', 'date', 'year', 'subject', 'originalurl', and 'licenseurl'. It also includes a 'scanner' field to track uploads made by the TubeUp application.\n\nThis function is called by the upload_ia function within the TubeUp class, which handles the actual uploading of video files to archive.org. The metadata generated by create_archive_org_metadata_from_youtubedl_meta is crucial for ensuring that the uploaded content is correctly categorized and attributed.\n\n**Note**: It is important to ensure that the vid_meta dictionary contains valid keys and values, as the function relies on this data to generate accurate metadata. Missing or malformed data may lead to incomplete or incorrect metadata being returned.\n\n**Output Example**: \nA possible return value from the function could look like this:\n```python\n{\n    'mediatype': 'movies',\n    'creator': 'Video Background',\n    'collection': 'opensource_movies',\n    'title': 'Mountain 3 - Video Background HD 1080p',\n    'description': 'Mountain 3 - Video Background HD 1080p<br>If you use this video please put credits to my channel in description:<br>https://www.youtube.com/channel/UCWpsozCMdAnfI16rZHQ9XDg<br>© Don\\'t forget to SUBSCRIBE, LIKE, COMMENT and RATE. Hope you all enjoy!',\n    'date': '2015-01-05',\n    'year': '2015',\n    'subject': 'Youtube;video;Entertainment;Video Background;Footage;Animation;Cinema;stock video footage;Royalty free videos;Creative Commons videos;free movies online;youtube;HD;1080p;Amazing Nature;Mountain;',\n    'originalurl': 'https://www.youtube.com/watch?v=6iRV8liah8A',\n    'licenseurl': 'https://creativecommons.org/licenses/by/3.0/',\n    'scanner': 'TubeUp Video Stream Mirroring Application 1.0'\n}\n```"
      ],
      "code_start_line": 455,
      "code_end_line": 553,
      "params": [
        "vid_meta"
      ],
      "have_return": true,
      "code_content": "    def create_archive_org_metadata_from_youtubedl_meta(vid_meta):\n        \"\"\"\n        Create an archive.org from youtubedl-generated metadata.\n\n        :param vid_meta: A dict containing youtubedl-generated metadata.\n        :return:         A dict containing metadata to be used by\n                         internetarchive library.\n        \"\"\"\n        title = '%s' % (vid_meta['title'])\n        videourl = vid_meta['webpage_url']\n\n        collection = TubeUp.determine_collection_type(videourl)\n\n        # Some video services don't tell you the uploader,\n        # use our program's name in that case.\n        try:\n            if vid_meta['extractor_key'] == 'TwitchClips' and 'creator' in vid_meta and vid_meta['creator']:\n                uploader = vid_meta['creator']\n            elif 'uploader' in vid_meta and vid_meta['uploader']:\n                uploader = vid_meta['uploader']\n            elif 'uploader_url' in vid_meta and vid_meta['uploader_url']:\n                uploader = vid_meta['uploader_url']\n            else:\n                uploader = 'tubeup.py'\n        except TypeError:  # apparently uploader is null as well\n            uploader = 'tubeup.py'\n\n        try:  # some videos don't give an upload date\n            d = datetime.strptime(vid_meta['upload_date'], '%Y%m%d')\n            upload_date = d.isoformat().split('T')[0]\n            upload_year = upload_date[:4]  # 20150614 -> 2015\n        except (KeyError, TypeError):\n            # Use current date and time as default values\n            upload_date = time.strftime(\"%Y-%m-%d\")\n            upload_year = time.strftime(\"%Y\")\n\n        # load up tags into an IA compatible semicolon-separated string\n        # example: Youtube;video;\n        tags_string = '%s;video;' % vid_meta['extractor_key']\n\n        if 'categories' in vid_meta:\n            # add categories as tags as well, if they exist\n            try:\n                for category in vid_meta['categories']:\n                    tags_string += '%s;' % category\n            except Exception:\n                print(\"No categories found.\")\n\n        if 'tags' in vid_meta:  # some video services don't have tags\n            try:\n                if 'tags' in vid_meta is None:\n                    tags_string += '%s;' % vid_meta['id']\n                    tags_string += '%s;' % 'video'\n                else:\n                    for tag in vid_meta['tags']:\n                        tags_string += '%s;' % tag\n            except Exception:\n                print(\"Unable to process tags successfully.\")\n\n        # IA's subject field has a 255 bytes length limit, so we need to truncate tags_string\n        while len(tags_string.encode('utf-8')) > 255:\n            tags_list = tags_string.split(';')\n            tags_list.pop()\n            tags_string = ';'.join(tags_list)\n\n        # license\n        licenseurl = TubeUp.determine_licenseurl(vid_meta)\n\n        # if there is no description don't upload the empty .description file\n        description_text = vid_meta.get('description', '')\n        if description_text is None:\n            description_text = ''\n        # archive.org does not display raw newlines\n        description = re.sub('\\r?\\n', '<br>', description_text)\n\n        metadata = dict(\n            mediatype=('audio' if collection == 'opensource_audio'\n                       else 'movies'),\n            creator=uploader,\n            collection=collection,\n            title=title,\n            description=description,\n            date=upload_date,\n            year=upload_year,\n            subject=tags_string,\n            originalurl=videourl,\n            licenseurl=licenseurl,\n\n            # Set 'scanner' metadata pair to allow tracking of TubeUp\n            # powered uploads, per request from archive.org\n            scanner='TubeUp Video Stream Mirroring Application {}'.format(__version__))\n\n        # add channel url if it exists\n        if 'uploader_url' in vid_meta:\n            metadata[\"channel\"] = vid_meta[\"uploader_url\"]\n        elif 'channel_url' in vid_meta:\n            metadata[\"channel\"] = vid_meta[\"channel_url\"]\n\n        return metadata\n",
      "name_column": 8,
      "item_status": "doc_up_to_date",
      "who_reference_me": [
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_description_text_null",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_no_uploader",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_no_date",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_twitch_clips",
        "tests/test_tubeup.py/TubeUpTests/test_create_archive_org_metadata_from_youtubedl_meta_mass_of_tags",
        "tubeup/TubeUp.py/TubeUp/upload_ia"
      ],
      "reference_who": [
        "tubeup/TubeUp.py/TubeUp/determine_collection_type",
        "tubeup/TubeUp.py/TubeUp/determine_licenseurl"
      ],
      "special_reference_type": [
        false,
        false
      ]
    }
  ]
}